<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant confidence="0.000000" no="0">
<note confidence="0.953432333333333">
Proceedings of the 40th Annual Meeting of the Association for
Computational Linguistics (ACL), Philadelphia, July 2002, pp. 48-55.
OT Syntax: Decidability of Generation-based Optimization
</note>
<author confidence="0.9276">
Jonas Kuhn
</author>
<affiliation confidence="0.9511895">
Department of Linguistics
Stanford University
</affiliation>
<email confidence="0.996463">
jonask@stanford.edu
</email>
<sectionHeader confidence="0.993915" genericHeader="abstract">
Abstract
</sectionHeader>
<bodyText confidence="0.999665272727273">In Optimality-Theoretic Syntax, optimization with unrestricted expressive power on the side of the OT constraints is undecidable. This paper provides a proof for the decidability of optimization based on constraints expressed with reference to local subtrees (which is in the spirit of OT theory). The proof builds on Kaplan and Wedekind’s (2000) construction showing that LFG generation produces contextfree languages.</bodyText>
<sectionHeader confidence="0.998978" genericHeader="introduction">
1 Introduction
</sectionHeader>
<bodyText confidence="0.999551">Optimality-Theoretic (OT) grammar systems are an interesting alternative to classical formal grammars, as they construe the task of learning from data in a meaning-based way: a form is defined as grammatical if it is optimal (most harmonic) within a set of generation alternatives for an underlying logical form. The harmony of a candidate analysis depends on a language-specific ranking ( ) of violable constraints, thus the learning task amounts to adjusting the ranking over a given set of constraints.</bodyText>
<listItem confidence="0.676367">(1) Candidate is more harmonic than iff it incurs fewer violations of the highest-ranking constraint in which and differ.</listItem>
<bodyText confidence="0.986047333333333">The comparison-based setup of OT learning is closely related to discriminative learning approaches in probabilistic parsing (Johnson et al., 1999; Riezler et al., 2000; Riezler et al., 2002),1 however the comparison of generation alternatives – rather than parsing alternatives – adds the possibility of systematically learning the basic language-specific grammatical principles (which in probabilistic parsing are typically fixed a priori, using either a treebankderived or a manually written grammar for the given language).</bodyText>
<footnote confidence="0.99522">
This work was supported by a postdoctoral fellowship of
the German Academic Exchange Service (DAAD).
1This is for instance pointed out by (Johnson, 1998).
</footnote>
<bodyText confidence="0.999720545454545">The “base grammar” assumed as given can be highly unrestricted in the OT setup. Using a linguistically motivated set of constraints, learning proceeds with a bias for unmarked linguistic structures (cf.e.g., (Bresnan et al., 2001)). For computational OT syntax, an interleaving of candidate generation and constraint checking has been proposed (Kuhn, 2000). But the decidability of the optimization task in OT syntax, i.e., the identification of the optimal candidate(s) in a potentially infinite candidate set, has not been proven yet.2</bodyText>
<sectionHeader confidence="0.961952" genericHeader="method">
2 Undecidability for unrestricted OT
</sectionHeader>
<bodyText confidence="0.9963638">Assume that the candidate set is characterized by a context-free grammar (cfg) , plus one additional candidate ‘yes’. There are two constraints ( ): is violated if the candidate is neither ‘yes’ nor a structure generated by a cfg ; is violated only by ‘yes’. Now, ‘yes’ is in the language defined by this system iff there are no structures in that are also in . But the emptiness problem for the intersection of two context-free languages is known to be undecidable, so the optimization task for unrestricted OT is undecidable too.3 However, it is not in the spirit of OT to have extremely powerful individual constraints; the explanatory power should rather arise from interaction of simple constraints.</bodyText>
<sectionHeader confidence="0.998365" genericHeader="method">
3 OT-LFG
</sectionHeader>
<bodyText confidence="0.9882975">Following (Bresnan, 2000; Kuhn, 2000; Kuhn, 2001), we define a restricted OT system based on Lexical-Functional Grammar (LFG) representations: c(ategory) structure/f(unctional) structure pairs like(4),(5).</bodyText>
<footnote confidence="0.801068333333333">
2Most computational OT work so far focuses on candidates
and constraints expressible as regular languages/rational rela-
tions, based on (Frank and Satta, 1998) (e.g., (Eisner, 1997;
Karttunen, 1998; Gerdemann and van Noord, 2000)).
3Cf. also (Johnson, 1998) for the sketch of an undecidability
argument and (Kuhn, 2001, 4.2, 6.3) for further constructions.
</footnote>
<bodyText confidence="0.9710684">Each c-structure tree node is mapped to a node in the f-structure graph by the function. The mapping is specified by fannotations in the grammar rules (below category symbols, cf.(2)) and lexicon entries (3).4 abbreviates , i.e., the f-structure corresponding to the present node’s mother category.</bodyText>
<figure confidence="0.764597">
(1) c-structure
ROOT
VP
NP V
</figure>
<footnote confidence="0.730246">
4abbreviates , i.e., the present category’simage;
</footnote>
<bodyText confidence="0.981161607142857">The correct f-structure for a sentence is the minimal model satisfying all properly instantiated fannotations. In OT-LFG, the universe of possible candidates is defined by an LFG (encoding inviolable principles, like an X-bar scheme). A particular candidate set is the set Gen – i.e., the c-/fstructure pairs in , which have the input as their f-structure. Constraints are expressed as local configurations in the c-/f-structure pairs. They have one of the following implicational forms:5 where are descriptions of nonterminals of ; are standard LFG f-annotations of constraining equations withas the only f-structure metavariable.where are descriptions of nonterminals of ; refer to the mother in a local subtree configuration,refer to the same daughter category; are regular expressions over nonterminals;are standard f-annotations as in (6). Any of the descriptions can be maximally unspecific; (6) can for example be instantiated by the OPSPEC constraint (OP)=+ (DF) (an operator must be the value of a discourse function, (Bresnan, 2000)) with the category information unspecified. An OT-LFG system is thus characterized by a base grammar and a set of constraints, with a</bodyText>
<equation confidence="0.605605">
language-specific ranking relation :
.
</equation>
<bodyText confidence="0.968428">The evaluation function Eval picks the most harmonic from a set of candidates, based on the constraints and ranking. The language (set of analyses)6 generated by an OT system is defined as</bodyText>
<sectionHeader confidence="0.994809" genericHeader="method">
4 LFG generation
</sectionHeader>
<bodyText confidence="0.9764565">Our decidability proof for generation-based optimization builds on the result of (Kaplan and Wedekind, 2000) (K&amp;W00) that LFG generation produces context-free languages.</bodyText>
<footnote confidence="0.9772888">
5Note that with GPSG-style category-level feature percola-
tion it is possible to refer to (finitely many) nonlocal configura-
tions at the local tree level.
6The string language is obtained by taking the terminal
string of the c-structure part of the analyses.
</footnote>
<figure confidence="0.9769417">
=
FP
(2) ROOT
NP FP
TOPIC
COMP* OBJ
(NP) F
SUBJ
F FP
F
VP (NP) V
(SUBJ)=
VP
FP
VP
FP
COMP
(3) Mary NP (PRED)=‘Mary’
(NUM)=SG
V NP
V
OBJ
that F
had F (TNS)=PAST
seen V (PRED)=‘see(SUBJ) (OBJ)’
(ASP)=PERF
thought V (PRED)=‘think(SUBJ) (COMP)’
(TNS)=PAST
laughed V (PRED)=‘laugh(SUBJ)’
(TNS)=PAST
SUBJ
OBJ
John V FP
thought F
F FP
that NP F
Mary F VP
had V
V NP
seen Titanic
(4) f-structure
PRED ‘think(SUBJ) (COMP)’
TNS PAST
PRED ‘John’
NUM SG
PRED ‘see(SUBJ) (OBJ)’
TNS PAST
ASP PERF
PRED ‘Mary’
NUM SG
PRED ‘Titanic’
NUM SG
SUBJ
COMP
Eval Gen
SUBJ
PRED)=‘Mary’
NUM)=SG
PRED)=‘laugh’
TNS)=PAST
</figure>
<listItem confidence="0.680366666666667">(8) Given an arbitrary LFG grammarand a cycle-free fstructure, a cfgcan be constructed that generates exactly the strings to whichassigns the f-structure.</listItem>
<bodyText confidence="0.98629325">I will refer to the resulting cfg as . K&amp;W00 present a constructive proof, folding all fstructural contributions of lexical entries and LFG rules into the c-structural rewrite rules (which is possible since we know in advance the range of fstructural objects that can instantiate the f-structure meta-variables in the rules). I illustrate the specialization steps with grammar (2) and lexicon (3) and for generation from f-structure (5). Initially, the generalized format of right-hand sides in LFG rules is converted to the standard context-free notation (resolving regular expressions by explicit disjunction or recursive rules). Fstructure (5) contains five substructures: the root fstructure, plus the embedded f-structures under the paths SUBJ, COMP, COMP SUBJ, and COMP OBJ. Any relevant metavariable (,) in the grammar must end up instantiated to one of these. So for each path from the root f-structure, a distinct variable is introduced:, subscripted with the (abbreviated and possibly empty) feature path: . Rule augmentation step 1 adds to each category name a concrete f-structure to which the category corresponds. So for FP, we get FP:, FP: , FP: , FP: , and FP: . The rules are multiplied out to cover all combinations of augmented categories obeying the original f-annotations.7 Step 2 adds a set of instantiated f-annotation schemes to each symbol, based on the instantiation of metavariables from step 1. One instance of the lexicon entry Mary look as follows: PRED)=‘Mary’</bodyText>
<listItem confidence="0.821265">(9) NP: : Mary NUM)=SG</listItem>
<bodyText confidence="0.958988">The rules are again multiplied out to cover all combinations for which the set of f-constraints on the mother is the union of all daughters’ fconstraints, plus the appropriately instantiated rulespecific annotations. So, for the VP rule based PRED)=‘Mary’ on the categories NP: : and</bodyText>
<equation confidence="0.8118915">
NUM)=SG
V: :
</equation>
<footnote confidence="0.417715">
7VP:NP: V:is allowed, while
</footnote>
<bodyText confidence="0.759555">VP: NP: V: is excluded, since the=annotation of Vin the VP rule (2) enforces thatVPV .</bodyText>
<equation confidence="0.94670375">
VP::
PRED)=‘Mary’
NP: : V:
NUM)=SG :
</equation>
<bodyText confidence="0.999926238095238">With this bottom-up construction it is ensured that each new category ROOT::... (corresponding to the original root symbol) contains a complete possible collection of instantiated f-constraints. To exclude analyses whose f-structure is not(for which we are generating strings) a new start symbol is introduced “above” the original root symbol. Only for the sets of f-constraints that haveas their minimal model, rules of the form ROOT ROOT::... are introduced (this also excludes inconsistent fconstraint sets). With the cfg , standard techniques for cfg’s can be applied, e.g., if there are infinitely many possible analyses for a given f-structure, the smallest one(s) can be produced, based on the pumping lemma for context-free languages. Grammar (2) does indeed produce infinitely many analyses for the input f-structure (5). It overgenerates in several respects: The functional projection FP can be stacked due to recursions like the following (with the augmented FP reoccuring in the Frules):</bodyText>
<equation confidence="0.994410666666667">
FP: :
F: :
F: : is one of the augmented categories we get
</equation>
<bodyText confidence="0.999663428571429">for that in (3), so ((2),(5)) generates an arbitrary number of thats on top of any FP. A similar repetition effect will arise for the auxiliary had.8 Other choices in generation arise from the freedom of generating the subject in the specifier of VP or FP and from the possibility of (unbounded) topicalization of the object (the first disjunction of the FP rule in (2)</bodyText>
<footnote confidence="0.824840666666667">
8The F entries do not contribute any PRED value, which
would exclude doubling due to the instantiated symbol charac-
ter of PRED values (cf. K&amp;W00, fn. 2).
</footnote>
<page confidence="0.553473">
PRED)=‘laugh’
</page>
<figure confidence="0.99016953125">
TNS)=PAST , we get the rule
PRED)=‘laugh’
TNS)=PAST
PRED)=‘see...’
TNS)=PAST
SUBJ
PRED)=‘Mary’
OBJ
PRED)=‘Titanic’
PRED)=‘see...’
TNS)=PAST
SUBJ
PRED)=‘Mary’
OBJ
PRED)=‘Titanic’
F: :FP: :
F: :
PRED)=‘see...’
TNS)=PAST
SUBJ
PRED)=‘Mary’
OBJ
PRED)=‘Titanic’
PRED)=‘see...’
TNS)=PAST
SUBJ
PRED)=‘Mary’
OBJ
PRED)=‘Titanic’
contains a functional-uncertainty equation):
(10) a. John thought that Titanic, Mary had seen.
b. Titanic, John thought that Mary had seen.
</figure>
<sectionHeader confidence="0.730914" genericHeader="method">
5 LFG generation in OT-LFG
</sectionHeader>
<bodyText confidence="0.99722715">While grammar (2) would be considered defective as a classical LFG grammar, it constitutes a reasonable example of a candidate generation grammar ( ) in OT. Here, it is the OT constraints that enforce language-specific restrictions, so has to ensure that all candidates are generated in the first place. For instance, expletive elements as do in Who do you know will arise by passing a recursion in the cfg constructed during generation. A candidate containing such a vacuous cycle can still become the winner of the OT competition if the Faithfulness constraint punishing expletives is outranked by some constraint favoring an aspect of the recursive structure. So the harmony is increased by going through the recursion a certain number of times. It is for this very reason, that Who do you know is predicted to be grammatical in English. So, in OT-LFG it is not sufficient to apply just the construction; I use an additional step: prior to application of , the LFG grammar</bodyText>
<sectionHeader confidence="0.994965" genericHeader="method">
6 The conversion
</sectionHeader>
<bodyText confidence="0.9933838125">Preprocessing Like K&amp;W00, I assume an initial conversion of the c-structure part of rules into standard context-free form, i.e., the right-hand side is a category string rather than a regular expression. This ensures that for a given local subtree, each constraint (of form (6) or (7)) can be applied only a finite number of times: ifis the arity of the longest right-hand side of a rule, the maximal number of local violations is(since some constraints of type (7) can be instantiated to all daughters). Grammar conversion With the number of local violations bounded, we can encode all candidate distinctions with respect to constraint violations at the local-subtree level with finite means: The set of categories in the newly constructed LFG grammar is the finite set (11) : the set of categories in
:
a nonterminal symbol of ,
the size of the constraint set ,
,</bodyText>
<figureCaption confidence="0.343148">
the arity of the longest rhs in rules of
</figureCaption>
<bodyText confidence="0.727448">The rules in are constructed in such a way that for each rule ( ), where converted to a different form (depending on the constraint set), which is still an LFG grammar but has category symbols which reflect local constraint violations.</bodyText>
<table confidence="0.854701206896552">
XX ...X
in and each sequence ,
, all rules of the form
X: X : ...X:
are included such that (the number of violations
of constraint incurred local to the rule) and the
f-annotations ... are specified as follows:
(12) for of form (6) :
,
a.;
( )
( )
; ;
if Xdoes not match the condition;
if Xmatches;
( )
;;
( )
; ;
( )
; ;
if Xmatches bothand;
if Xmatchesbut not;
if Xmatches bothand ;
(13) for of form (7) :
( )
a.;
if Xdoes not match the condition;
is
</table>
<bodyText confidence="0.970939833333333">When the construction is applied to , all “pumping” structures generated by the cfg can indeed be ignored since all OT-relevant candidates are already contained in the finite set of nonrecursive structures. So, finally the ranking of the constraints is taken into consideration in order to determine the harmony of the candidates in this finite subset.</bodyText>
<equation confidence="0.780825333333333">
b.
;
iv.;
</equation>
<bodyText confidence="0.548200666666667">if Xmatches, Xmatches, X ... X match, X♦ ... X match, but (at least) one of them does not match the respective description in the consequent</bodyText>
<equation confidence="0.84007">
( );
v.;
if Xmatches bothand ; Xmatches both and
; X ... X matchand; X♦ ... X match
and.
</equation>
<bodyText confidence="0.9936083">Note that the constraint profile of the daughter categories does not play any role in the determination of constraint violations local to the subtree under consideration (only the sequences are restricted by the conditions (12) and (13)). So for each new rule type, all combinations of constraint profiles on the daughters are constructed (creating a large but finite number of rules).9 This ensures that no sentence that can be parsed (or generated) by is excluded from (as stated by fact (14)):10</bodyText>
<listItem confidence="0.543334">(14) Coverage preseveration</listItem>
<bodyText confidence="0.887616157894737">All strings generated by an LFG grammarare also generated by . The original analysis can be recovered from an analysis by applying a projection function Cat to all c-structure categories: 9For one rule/constraint combination several new rules can result; e.g., if the right-hand side of a rule (X) matches both the antecedent () and the consequent () category description of a constraint of form (6), three clauses apply: (12b), (12c), and (12d). So, we get two new rules with the count of 0 local violations of the constraint and two rules with count 1, with a difference in the f-annotations. 10Providing all possible combinations of augmented category symbols on the right-hand rule sides in ensures that the newly constructed rules can be reached from the root symbol in a derivation. It is also guaranteed that whenever a rule in contributes to an analysis, at least one of the rules constructed from will contribute to the corresponding analysis in . This is ensured since the subclauses in (12) and (13) cover the full space of logical possibilities. We can overload the function name Cat with a function applying to the set of analyses produced by an LFG grammar by defining Cat applying Cat to all category symbols. Coverage preservation of theconstruction holds also for the projected c-category skeleton (cf. the argumentation in fn. 10): (15) C-structure level coverage preservation For an LFG grammar: Cat Each category inencodes the number of local violations for all constraints. Since all constraints are locally evaluable by assumption, all constraints violated by a candidate analysis have to be incurred local to some subtree. Hence the total number of constraint violations incurred by a candidate can be computed by simply summing over all category-encoded local violation profiles:</bodyText>
<equation confidence="0.305089">
(16) Total number of constraint violations
</equation>
<bodyText confidence="0.958814166666667">Let Nodesbe the multiset of categories occurring in the c-structure tree, then the total number of violations of constraint incurred by an analysis is Define Total</bodyText>
<sectionHeader confidence="0.913649" genericHeader="method">
7 Applying on
</sectionHeader>
<bodyText confidence="0.9957749">Since is a standard LFG grammar, we can apply the construction to it to get a cfg for a given f-structure . The category symbols then have the form X: :: , with and arising from the construction. We can overload the projection function Cat again such that Cat :: : for all augmented category symbol of the new format; likewise Catfor a cfg. Since theconstruction (strongly) preserves the language generated, coverage preservation holds also after the application of to and , respectively: (17) Cat</bodyText>
<subsubsectionHeader confidence="0.638128">
Cat
</subsubsectionHeader>
<bodyText confidence="0.831553534883721">But since the symbols in reflect local constraint violations, Cat has the property that all instances ofrecursion in the if X♦does not match, or X ... X do not match, or X ... X do not match; if Xmatches bothand; Xmatches both and ; X ... X matchand; X♦ ... X match and; if Xmatches bothand; Xmatches both and ; X ... X matchand; X♦ ... X match and; Cat: for every category in (11) ,is derived fromby resulting cfg create candidates that are at most as harmonic as their non-recursive counterparts. Assuming a projection function CatCount :: : :, we can state more formally: (18) If and are CatCount projections of trees produced by the cfg , using exactly the same rules, and contains a superset of the nodes that contains, then , for all from Total, and Total . This fact follows from definition of Total (16): the violation counts in the additional nodes in will add to the total of constraint violations (and if none of the additional nodes contains any local constraint violation at all, the total will be the same as in ). Intuitively, the effect of the augmentation of the category format is that certain recursions in the pure construction (which one may think of as a loop) are unfolded, leading to a longer loop. The new loop is sufficiently large to make all relevant distinctions. This result can be directly exploited in processing: if all non-recursive analyses are generated (of which there are only finitely many) it is guaranteed that a subset of the optimal candidates is among them. If the grammar does not contain any violation-free recursion, we even know that we have generated all optimal candidates.</bodyText>
<listItem confidence="0.908646">(19) A recursion with the derivation path is called violation-free iff all categories dominated by the upper occurrence of , but not dominated by the lower occurrence of have the form with Note that if there is an applicable violation-free recursion, the set of optimal candidates is infinite; so if the constraint set is set up properly in a linguistic analysis, one would assume that violation-free recursion should not arise.(Kuhn, 2000) excludes the application of such recursions by a similar condition as offline parsability (which excludes vacuous recursions over a string in parsing), but with the construction, this condition is not necessary for decidability of the generation-based optimization task.</listItem>
<bodyText confidence="0.963368333333333">The cfg produced by can be transformed further to only generate the optimal candidates according to the constraint ranking of the OT system , eliminating all but the violation-free recursions in the grammar:</bodyText>
<figure confidence="0.95856575">
(20) Creating a cfg that produces all optimal candidates
a. Define
contains no
recursion.
</figure>
<figureCaption confidence="0.7513514">
is finite and can be easily computed, by keeping
track of the rules already used in an analysis.
b. Redefine Eval to apply on a set of context-free
analyses with augmented category symbols with counts
of local constraint violations:
</figureCaption>
<bodyText confidence="0.825306533333334">Eval is maximally harmonic in , under ranking Using the function Total defined in (16), this function is straightforward to compute for finite sets, i.e., in particular Eval . c. Augment the category format further by one index component.11 Introduce index for all categories in of the form X: :: , where for . Introduce a new unique index for each node of the form X: :: , where for some occurring in the analyses Eval (i.e., different occurrences of the same category are distinguished). d. Construct the cfg S , where are the indexed symbols of step c.; S is a new start symbol; the rules are (i) those rules from which were used in the analyses in Eval – with the original symbols replaced by the indexed symbols –, (ii) the rules in , in which the mother category and all daughter categories are of the form X: :: ,✟ for (with the new index added), and (iii) one rule S S: for each of the indexed versions S: of the start symbols of . With the index introduced in step (20c), the original recursion in the cfg is eliminated in all but the violation-free cases. The grammar Cat produces (the c-structure of) the set of optimal candidates for the input :12 11The projection function Cat is again overloaded to also remove the index on the categories. 12Like K&amp;W00, I make the assumption that the input fstructure in generation is fully specified (i.e., all the candidates have the form ), but the result can be extended to allow for the addition of a finite amount of f-structure information in generation. Then, the specified routine is computed separately for each possible f-structural extension and the results are compared in the end. (21) Cat Eval Gen , i.e., the set of c-structures for the optimal candidates for input f-structureaccording to the OT system .</bodyText>
<sectionHeader confidence="0.989758" genericHeader="method">
8 Proof
</sectionHeader>
<bodyText confidence="0.997384821428572">To prove fact (21) we will show that the c-structure of an arbitrary candidate analysis generated from with is contained in Cat iff all other candidates are equally or less harmonic. Take an arbitrary candidate c-structure generated from with such that Cat . We have to show that all other candidatesgenerated from are equally or less harmonic than. Assume there were athat is more harmonic than. Then there must be some constraint , such thatviolates fewer times thandoes, and is ranked higher than any other constraint in whichanddiffer. Constraints have to be incurred within some local subtree; somust contain a local violation configuration thatdoes not contain, and by the construction (12)/(13) the -augmented analysis of– call it– must make use of some violation-marked rule not used in . Now there are three possibilities: (i) Bothandare free of recursion. Then the fact thatavoids the highest-ranking constraint violation excludesfrom Cat (by construction step (20b)). This gives us a contradiction with our assumption. (ii)contains a recursion andis free of recursion. If the recursion inis violationfree, then there is an equally harmonic recursionfree candidate. But this is also less harmonic than, such that it would have been excluded from Cat too. This again means that would also be excluded (for lack of the relevant rules in the non-recursive part). On the other hand, if it were the recursion inthat incurred the additional violation (as compared to), then there would be a more harmonic recursion-free candidate. However, this would exclude the presence ofin by construction step (20c,d) (only violation-free recursion is possible). So we get another contradiction to the assumption that Cat . (iii)contains a recursion. If this recursion is violation-free, we can pick the equally harmonic candidate avoiding the recursion to be our, and we are back to case (i) and (ii). Likewise, if the recursion indoes incur some violation, not using the recursion leads to an even more harmonic candidate, for which again cases (i) and (ii) will apply. All possible cases lead to a contradiction with the assumptions, so no candidate is more harmonic than our Cat . We still have to prove that if the c-structureof a candidate analysis generated from with is equally or more harmonic than all other candidates, then it is contained in Cat . We can construct an augmented versionof, such that Cat and then show that there is a homomorphism mappingto some analysis with Cat. We can use the constraint marking construction and the construction to construct the tree with augmented category symbols of the analysis . The result of K&amp;W00 plus (17) guarantee that Cat . Now, there has to be a homomorphism from the categories in to the categories of some analysis in . is also based on (with an additional index on each category and some categories and rules of having no counterpart in , we know that the augmented treeeither contains no recursion or only violation-free recursion. If it does contain such violation-free recursions we map all categories on the recursion paths to the indexed form :, and furthermore consider the variant of avoiding the recursion(s). For our (non-recursive) tree, there is guaranteed to be a counterpart in the finite set of non-recursive trees in with all categories pairwise identical apart from the index in . We pick this tree and map each of the categories into the -indexed counterpart. The existence of this homomorphism guarantees that an analysis exists with Cat Cat .</bodyText>
<sectionHeader confidence="0.997479" genericHeader="conclusion">
9 Conclusion
</sectionHeader>
<bodyText confidence="0.96354987804878">We showed that for OT-LFG systems in which all constraints can be expressed relative to a local subtree in c-structure, the generation task from (noncyclic13) f-structures is solvable. The infinity of 13The non-cyclicity condition is inherited from K&amp;W00; in linguistically motivated applications of the LFG formalism, cru). Since we know thatis equally or more harmonic than any other candidate generated from QED the conceptually underlying candidate set does not preclude a computational approach. It is obvious that the construction proposed here has the purpose of bringing out the principled computability, rather than suggesting a particular algorithm for implementation. However on this basis, an implementation can be easily devised. The locality condition on constraint-checking seems unproblematic for linguistically relevant constraints, since a GPSG-style slash mechanism permits reference to (finitely many) nonlocal configurations from any given category (cf. fn. 5).14 Decidability of generation-based optimization (from a given input f-structure) alone does not imply that the recognition and parsing tasks for an OT grammar system defined as in sec. 3 are decidable: for these tasks, a string is given and it has to be shown that the string is optimal for some underlying input f-structure (cf. (Johnson, 1998)). However, a similar construction as the one presented here can be devised for parsing-based optimization (even for an LFG-style grammar that does not obey the offline parsability condition). So, if the language generated by an OT system is defined based on (strong) bidirectional optimality (Kuhn, 2001, ch. 5), decidability of both the general parsing and generation problem follows.15 For the unidirectionally defined OT language (as in sec. 3), decidability of parsing can be guaranteed under the assumption of a contextual recoverability condition in parsing (Kuhn, in preparation).</bodyText>
<sectionHeader confidence="0.999375" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.99500961971831">
Joan Bresnan, Shipra Dingare, and Christopher Manning.
2001. Soft constraints mirror hard constraints: Voice
and person in English and Lummi. In Proceedings of
the LFG 2001 Conference. CSLI Publications.
cial use of cyclicity in underlying semantic feature graphs has
never been made.
14A hypothetical constraint that is excluded would be a paral-
lelism constraint comparing two subtree structures of arbitrary
depth. Such a constraint seems unnatural in a model of gram-
maticality. Parallelism of conjuncts does play a role in models
of human parsing preferences; however, here it seems reason-
able to assume an upper bound on the depth of parallel struc-
tures to be compared (due to memory restrictions).
15Parsing: for a given string, parsing-based optimization
is used to determine the optimal underlying f-structure; then
generation-based optimization is used to check whether the
original string comes out optimal in this direction too. Gen-
eration is symmetrical, starting with an f-structure.
Joan Bresnan. 2000. Optimal syntax. In Joost Dekkers,
Frank van der Leeuw, and Jeroen van de Weijer, edi-
tors, Optimality Theory: Phonology, Syntax, and Ac-
quisition. Oxford University Press.
Jason Eisner. 1997. Efficient generation in primitive
optimality theory. In Proceedings of the ACL 1997,
Madrid.
Robert Frank and Giorgio Satta. 1998. Optimality theory
and the generative complexity of constraint violation.
Computational Linguistics, 24(2):307–316.
Dale Gerdemann and Gertjan van Noord. 2000. Approx-
imation and exactness in finite state Optimality The-
ory. In SIGPHON 2000, Finite State Phonology. 5th
Workshop of the ACL Special Interest Group in Comp.
Phonology, Luxembourg.
Mark Johnson, Stuart Geman, Stephen Canon, Zhiyi Chi,
and Stefan Riezler. 1999. Estimators for stochastic
“unification-based” grammars. In Proceedings of the
37th Annual Meeting of the Association for Computa-
tional Linguistics (ACL’99), College Park, MD, pages
535–541.
Mark Johnson. 1998. Optimality-theoretic Lexical Func-
tional Grammar. In Proceedings of the 11th Annual
CUNY Conference on Human Sentence Processing,
Rutgers University.
Ronald M. Kaplan and J¨urgen Wedekind. 2000.
LFG generation produces context-free languages.
In Proceedings of COLING-2000, pages 297–302,
Saarbr¨ucken.
Lauri Karttunen. 1998. The proper treatment of optimal-
ity in computational phonology. In Proceedings of the
Internat. Workshop on Finite-State Methods in Natural
Language Processing, FSMNLP’98, pages 1–12.
Jonas Kuhn. 2000. Processing Optimality-theoretic syn-
tax by interleaved chart parsing and generation. In
Proceedings ofACL 2000, pages 360–367, Hongkong.
Jonas Kuhn. 2001. Formal and Computational As-
pects of Optimality-theoretic Syntax. Ph.D. thesis, In-
stitut f¨ur maschinelle Sprachverarbeitung, Universit¨at
Stuttgart.
Jonas Kuhn. in preparation. Decidability of generation
and parsing for OT syntax. Ms., Stanford University.
Stefan Riezler, Detlef Prescher, Jonas Kuhn, and Mark
Johnson. 2000. Lexicalized stochastic modeling of
constraint-based grammars using log-linear measures
and EM training. In Proceedings of the 38th Annual
Meeting ofthe Association for Computational Linguis-
tics (ACL’00), Hong Kong, pages 480–487.
Stefan Riezler, Dick Crouch, Ron Kaplan, Tracy King,
John Maxwell, and Mark Johnson. 2002. Parsing the
Wall Street Journal using a Lexical-Functional Gram-
mar and discriminative estimation techniques. This
conference.
</reference>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant confidence="0.921957" no="0">
<note confidence="0.997597">Proceedings of the 40th Annual Meeting of the Association for Computational Linguistics (ACL), Philadelphia, July 2002, pp. 48-55.</note>
<title confidence="0.992909">OT Syntax: Decidability of Generation-based Optimization</title>
<author confidence="0.999994">Jonas Kuhn</author>
<affiliation confidence="0.999959">Department of Linguistics Stanford University</affiliation>
<email confidence="0.999337">jonask@stanford.edu</email>
<abstract confidence="0.99434075">In Optimality-Theoretic Syntax, optimization with unrestricted expressive power on the side of the OT constraints is undecidable. This paper provides a proof for the decidability of optimization based on constraints expressed with reference to local subtrees (which is in the spirit of OT theory). The proof builds on Kaplan and Wedekind’s (2000) construction showing that LFG generation produces contextfree languages.</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>Joan Bresnan</author>
<author>Shipra Dingare</author>
<author>Christopher Manning</author>
</authors>
<title>Soft constraints mirror hard constraints: Voice and person in English and Lummi.</title>
<date>2001</date>
<booktitle>In Proceedings of the LFG</booktitle>
<contexts>
<context citStr="Bresnan et al., 2001" endWordPosition="336" position="2250" startWordPosition="333">sibility of systematically learning the basic language-specific grammatical principles (which in probabilistic parsing are typically fixed a priori, using either a treebankderived or a manually written grammar for the given This work was supported by a postdoctoral fellowship of the German Academic Exchange Service (DAAD). 1This is for instance pointed out by (Johnson, 1998). language). The “base grammar” assumed as given can be highly unrestricted in the OT setup. Using a linguistically motivated set of constraints, learning proceeds with a bias for unmarked linguistic structures (cf. e.g., (Bresnan et al., 2001)). For computational OT syntax, an interleaving of candidate generation and constraint checking has been proposed (Kuhn, 2000). But the decidability of the optimization task in OT syntax, i.e., the identification of the optimal candidate(s) in a potentially infinite candidate set, has not been proven yet.2 2 Undecidability for unrestricted OT Assume that the candidate set is characterized by a context-free grammar (cfg) , plus one additional candidate ‘yes’. There are two constraints ( ): is violated if the candidate is neither ‘yes’ nor a structure generated by a cfg ; is violated only by ‘ye</context>
</contexts>
<marker>Bresnan, Dingare, Manning, 2001</marker>
<rawString>Joan Bresnan, Shipra Dingare, and Christopher Manning. 2001. Soft constraints mirror hard constraints: Voice and person in English and Lummi. In Proceedings of the LFG 2001 Conference. CSLI Publications. cial use of cyclicity in underlying semantic feature graphs has never been made.</rawString>
</citation>
<citation valid="false">
<title>14A hypothetical constraint that is excluded would be a parallelism constraint comparing two subtree structures of arbitrary depth. Such a constraint seems unnatural in a model of grammaticality. Parallelism of conjuncts does play a role in models of human parsing preferences; however, here it seems reasonable to assume an upper bound on the depth of parallel structures to be compared (due to memory restrictions). 15Parsing: for a given string, parsing-based optimization is used to determine the optimal underlying f-structure; then generation-based optimization is used to check whether the original string comes out optimal in this direction too. Generation is symmetrical, starting with an f-structure.</title>
<marker/>
<rawString>14A hypothetical constraint that is excluded would be a parallelism constraint comparing two subtree structures of arbitrary depth. Such a constraint seems unnatural in a model of grammaticality. Parallelism of conjuncts does play a role in models of human parsing preferences; however, here it seems reasonable to assume an upper bound on the depth of parallel structures to be compared (due to memory restrictions). 15Parsing: for a given string, parsing-based optimization is used to determine the optimal underlying f-structure; then generation-based optimization is used to check whether the original string comes out optimal in this direction too. Generation is symmetrical, starting with an f-structure.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Joan Bresnan</author>
</authors>
<title>Optimal syntax.</title>
<date>2000</date>
<booktitle>Optimality Theory: Phonology, Syntax, and Acquisition.</booktitle>
<editor>In Joost Dekkers, Frank van der Leeuw, and Jeroen van de Weijer, editors,</editor>
<publisher>Oxford University Press.</publisher>
<contexts>
<context citStr="Bresnan, 2000" endWordPosition="513" position="3333" startWordPosition="512">re two constraints ( ): is violated if the candidate is neither ‘yes’ nor a structure generated by a cfg ; is violated only by ‘yes’. Now, ‘yes’ is in the language defined by this system iff there are no structures in that are also in . But the emptiness problem for the intersection of two context-free languages is known to be undecidable, so the optimization task for unrestricted OT is undecidable too.3 However, it is not in the spirit of OT to have extremely powerful individual constraints; the explanatory power should rather arise from interaction of simple constraints. 3 OT-LFG Following (Bresnan, 2000; Kuhn, 2000; Kuhn, 2001), we define a restricted OT system based on Lexical-Functional Grammar (LFG) representations: c(ategory) structure/f(unctional) structure 2Most computational OT work so far focuses on candidates and constraints expressible as regular languages/rational relations, based on (Frank and Satta, 1998) (e.g., (Eisner, 1997; Karttunen, 1998; Gerdemann and van Noord, 2000)). 3Cf. also (Johnson, 1998) for the sketch of an undecidability argument and (Kuhn, 2001, 4.2, 6.3) for further constructions. pairs like(4),(5). Each c-structure tree node is mapped to a node in the f-struct</context>
<context citStr="Bresnan, 2000" endWordPosition="811" position="5293" startWordPosition="810">pairs. They have one of the following implicational forms:5 where are descriptions of nonterminals of ; are standard LFG f-annotations of constraining equations withas the only f-structure metavariable. where are descriptions of nonterminals of ; refer to the mother in a local subtree configuration,refer to the same daughter category; are regular expressions over nonterminals;are standard f-annotations as in (6). Any of the descriptions can be maximally unspecific; (6) can for example be instantiated by the OPSPEC constraint (OP)=+ (DF) (an operator must be the value of a discourse function, (Bresnan, 2000)) with the category information unspecified. An OT-LFG system is thus characterized by a base grammar and a set of constraints, with a language-specific ranking relation : . The evaluation function Eval picks the most harmonic from a set of candidates, based on the constraints and ranking. The language (set of analyses)6 generated by an OT system is defined as 4 LFG generation Our decidability proof for generation-based optimization builds on the result of (Kaplan and Wedekind, 2000) (K&amp;W00) that LFG generation produces context-free languages. 5Note that with GPSG-style category-level feature </context>
</contexts>
<marker>Bresnan, 2000</marker>
<rawString>Joan Bresnan. 2000. Optimal syntax. In Joost Dekkers, Frank van der Leeuw, and Jeroen van de Weijer, editors, Optimality Theory: Phonology, Syntax, and Acquisition. Oxford University Press.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Jason Eisner</author>
</authors>
<title>Efficient generation in primitive optimality theory.</title>
<date>1997</date>
<booktitle>In Proceedings of the ACL 1997,</booktitle>
<location>Madrid.</location>
<contexts>
<context citStr="Eisner, 1997" endWordPosition="559" position="3675" startWordPosition="558">o the optimization task for unrestricted OT is undecidable too.3 However, it is not in the spirit of OT to have extremely powerful individual constraints; the explanatory power should rather arise from interaction of simple constraints. 3 OT-LFG Following (Bresnan, 2000; Kuhn, 2000; Kuhn, 2001), we define a restricted OT system based on Lexical-Functional Grammar (LFG) representations: c(ategory) structure/f(unctional) structure 2Most computational OT work so far focuses on candidates and constraints expressible as regular languages/rational relations, based on (Frank and Satta, 1998) (e.g., (Eisner, 1997; Karttunen, 1998; Gerdemann and van Noord, 2000)). 3Cf. also (Johnson, 1998) for the sketch of an undecidability argument and (Kuhn, 2001, 4.2, 6.3) for further constructions. pairs like(4),(5). Each c-structure tree node is mapped to a node in the f-structure graph by the function. The mapping is specified by fannotations in the grammar rules (below category symbols, cf. (2)) and lexicon entries (3).4 (1) c-structure ROOT VP NP V 4abbreviates , i.e., the present category’simage; abbreviates , i.e., the f-structure corresponding to the present node’s mother category. The correct f-structure f</context>
</contexts>
<marker>Eisner, 1997</marker>
<rawString>Jason Eisner. 1997. Efficient generation in primitive optimality theory. In Proceedings of the ACL 1997, Madrid.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Robert Frank</author>
<author>Giorgio Satta</author>
</authors>
<title>Optimality theory and the generative complexity of constraint violation.</title>
<date>1998</date>
<journal>Computational Linguistics,</journal>
<volume>24</volume>
<issue>2</issue>
<contexts>
<context citStr="Frank and Satta, 1998" endWordPosition="556" position="3654" startWordPosition="553">s is known to be undecidable, so the optimization task for unrestricted OT is undecidable too.3 However, it is not in the spirit of OT to have extremely powerful individual constraints; the explanatory power should rather arise from interaction of simple constraints. 3 OT-LFG Following (Bresnan, 2000; Kuhn, 2000; Kuhn, 2001), we define a restricted OT system based on Lexical-Functional Grammar (LFG) representations: c(ategory) structure/f(unctional) structure 2Most computational OT work so far focuses on candidates and constraints expressible as regular languages/rational relations, based on (Frank and Satta, 1998) (e.g., (Eisner, 1997; Karttunen, 1998; Gerdemann and van Noord, 2000)). 3Cf. also (Johnson, 1998) for the sketch of an undecidability argument and (Kuhn, 2001, 4.2, 6.3) for further constructions. pairs like(4),(5). Each c-structure tree node is mapped to a node in the f-structure graph by the function. The mapping is specified by fannotations in the grammar rules (below category symbols, cf. (2)) and lexicon entries (3).4 (1) c-structure ROOT VP NP V 4abbreviates , i.e., the present category’simage; abbreviates , i.e., the f-structure corresponding to the present node’s mother category. The </context>
</contexts>
<marker>Frank, Satta, 1998</marker>
<rawString>Robert Frank and Giorgio Satta. 1998. Optimality theory and the generative complexity of constraint violation. Computational Linguistics, 24(2):307–316.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Dale Gerdemann</author>
<author>Gertjan van Noord</author>
</authors>
<title>Approximation and exactness in finite state Optimality Theory.</title>
<date>2000</date>
<booktitle>In SIGPHON 2000, Finite State Phonology. 5th Workshop of the ACL Special Interest Group in Comp. Phonology,</booktitle>
<location>Luxembourg.</location>
<marker>Gerdemann, van Noord, 2000</marker>
<rawString>Dale Gerdemann and Gertjan van Noord. 2000. Approximation and exactness in finite state Optimality Theory. In SIGPHON 2000, Finite State Phonology. 5th Workshop of the ACL Special Interest Group in Comp. Phonology, Luxembourg.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Mark Johnson</author>
<author>Stuart Geman</author>
<author>Stephen Canon</author>
<author>Zhiyi Chi</author>
<author>Stefan Riezler</author>
</authors>
<title>Estimators for stochastic “unification-based” grammars.</title>
<date>1999</date>
<booktitle>In Proceedings of the 37th Annual Meeting of the Association for Computational Linguistics (ACL’99),</booktitle>
<pages>535--541</pages>
<location>College Park, MD,</location>
<contexts>
<context citStr="Johnson et al., 1999" endWordPosition="218" position="1482" startWordPosition="215"> a meaning-based way: a form is defined as grammatical if it is optimal (most harmonic) within a set of generation alternatives for an underlying logical form. The harmony of a candidate analysis depends on a language-specific ranking ( ) of violable constraints, thus the learning task amounts to adjusting the ranking over a given set of constraints. (1) Candidate is more harmonic than iff it incurs fewer violations of the highest-ranking constraint in which and differ. The comparison-based setup of OT learning is closely related to discriminative learning approaches in probabilistic parsing (Johnson et al., 1999; Riezler et al., 2000; Riezler et al., 2002),1 however the comparison of generation alternatives – rather than parsing alternatives – adds the possibility of systematically learning the basic language-specific grammatical principles (which in probabilistic parsing are typically fixed a priori, using either a treebankderived or a manually written grammar for the given This work was supported by a postdoctoral fellowship of the German Academic Exchange Service (DAAD). 1This is for instance pointed out by (Johnson, 1998). language). The “base grammar” assumed as given can be highly unrestricted </context>
</contexts>
<marker>Johnson, Geman, Canon, Chi, Riezler, 1999</marker>
<rawString>Mark Johnson, Stuart Geman, Stephen Canon, Zhiyi Chi, and Stefan Riezler. 1999. Estimators for stochastic “unification-based” grammars. In Proceedings of the 37th Annual Meeting of the Association for Computational Linguistics (ACL’99), College Park, MD, pages 535–541.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Mark Johnson</author>
</authors>
<title>Optimality-theoretic Lexical Functional Grammar.</title>
<date>1998</date>
<booktitle>In Proceedings of the 11th Annual CUNY Conference on Human Sentence Processing,</booktitle>
<institution>Rutgers University.</institution>
<contexts>
<context citStr="Johnson, 1998" endWordPosition="298" position="2006" startWordPosition="297">lated to discriminative learning approaches in probabilistic parsing (Johnson et al., 1999; Riezler et al., 2000; Riezler et al., 2002),1 however the comparison of generation alternatives – rather than parsing alternatives – adds the possibility of systematically learning the basic language-specific grammatical principles (which in probabilistic parsing are typically fixed a priori, using either a treebankderived or a manually written grammar for the given This work was supported by a postdoctoral fellowship of the German Academic Exchange Service (DAAD). 1This is for instance pointed out by (Johnson, 1998). language). The “base grammar” assumed as given can be highly unrestricted in the OT setup. Using a linguistically motivated set of constraints, learning proceeds with a bias for unmarked linguistic structures (cf. e.g., (Bresnan et al., 2001)). For computational OT syntax, an interleaving of candidate generation and constraint checking has been proposed (Kuhn, 2000). But the decidability of the optimization task in OT syntax, i.e., the identification of the optimal candidate(s) in a potentially infinite candidate set, has not been proven yet.2 2 Undecidability for unrestricted OT Assume that</context>
<context citStr="Johnson, 1998" endWordPosition="570" position="3752" startWordPosition="569">t is not in the spirit of OT to have extremely powerful individual constraints; the explanatory power should rather arise from interaction of simple constraints. 3 OT-LFG Following (Bresnan, 2000; Kuhn, 2000; Kuhn, 2001), we define a restricted OT system based on Lexical-Functional Grammar (LFG) representations: c(ategory) structure/f(unctional) structure 2Most computational OT work so far focuses on candidates and constraints expressible as regular languages/rational relations, based on (Frank and Satta, 1998) (e.g., (Eisner, 1997; Karttunen, 1998; Gerdemann and van Noord, 2000)). 3Cf. also (Johnson, 1998) for the sketch of an undecidability argument and (Kuhn, 2001, 4.2, 6.3) for further constructions. pairs like(4),(5). Each c-structure tree node is mapped to a node in the f-structure graph by the function. The mapping is specified by fannotations in the grammar rules (below category symbols, cf. (2)) and lexicon entries (3).4 (1) c-structure ROOT VP NP V 4abbreviates , i.e., the present category’simage; abbreviates , i.e., the f-structure corresponding to the present node’s mother category. The correct f-structure for a sentence is the minimal model satisfying all properly instantiated fanno</context>
<context citStr="Johnson, 1998" endWordPosition="4423" position="26634" startWordPosition="4422">ation can be easily devised. The locality condition on constraint-checking seems unproblematic for linguistically relevant constraints, since a GPSG-style slash mechanism permits reference to (finitely many) nonlocal configurations from any given category (cf. fn. 5).14 Decidability of generation-based optimization (from a given input f-structure) alone does not imply that the recognition and parsing tasks for an OT grammar system defined as in sec. 3 are decidable: for these tasks, a string is given and it has to be shown that the string is optimal for some underlying input f-structure (cf. (Johnson, 1998)). However, a similar construction as the one presented here can be devised for parsing-based optimization (even for an LFG-style grammar that does not obey the offline parsability condition). So, if the language generated by an OT system is defined based on (strong) bidirectional optimality (Kuhn, 2001, ch. 5), decidability of both the general parsing and generation problem follows.15 For the unidirectionally defined OT language (as in sec. 3), decidability of parsing can be guaranteed under the assumption of a contextual recoverability condition in parsing (Kuhn, in preparation). References</context>
</contexts>
<marker>Johnson, 1998</marker>
<rawString>Mark Johnson. 1998. Optimality-theoretic Lexical Functional Grammar. In Proceedings of the 11th Annual CUNY Conference on Human Sentence Processing, Rutgers University.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Ronald M Kaplan</author>
<author>J¨urgen Wedekind</author>
</authors>
<title>LFG generation produces context-free languages.</title>
<date>2000</date>
<booktitle>In Proceedings of COLING-2000,</booktitle>
<pages>297--302</pages>
<contexts>
<context citStr="Kaplan and Wedekind, 2000" endWordPosition="890" position="5781" startWordPosition="887">n for example be instantiated by the OPSPEC constraint (OP)=+ (DF) (an operator must be the value of a discourse function, (Bresnan, 2000)) with the category information unspecified. An OT-LFG system is thus characterized by a base grammar and a set of constraints, with a language-specific ranking relation : . The evaluation function Eval picks the most harmonic from a set of candidates, based on the constraints and ranking. The language (set of analyses)6 generated by an OT system is defined as 4 LFG generation Our decidability proof for generation-based optimization builds on the result of (Kaplan and Wedekind, 2000) (K&amp;W00) that LFG generation produces context-free languages. 5Note that with GPSG-style category-level feature percolation it is possible to refer to (finitely many) nonlocal configurations at the local tree level. 6The string language is obtained by taking the terminal string of the c-structure part of the analyses. = FP (2) ROOT NP FP TOPIC COMP* OBJ (NP) F SUBJ F FP F VP (NP) V (SUBJ)= VP FP VP FP COMP (3) Mary NP (PRED)=‘Mary’ (NUM)=SG V NP V OBJ that F had F (TNS)=PAST seen V (PRED)=‘see(SUBJ) (OBJ)’ (ASP)=PERF thought V (PRED)=‘think(SUBJ) (COMP)’ (TNS)=PAST laughed V (PRED)=‘laugh(SUBJ</context>
</contexts>
<marker>Kaplan, Wedekind, 2000</marker>
<rawString>Ronald M. Kaplan and J¨urgen Wedekind. 2000. LFG generation produces context-free languages. In Proceedings of COLING-2000, pages 297–302, Saarbr¨ucken.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Lauri Karttunen</author>
</authors>
<title>The proper treatment of optimality in computational phonology.</title>
<date>1998</date>
<booktitle>In Proceedings of the Internat. Workshop on Finite-State Methods in Natural Language Processing, FSMNLP’98,</booktitle>
<pages>1--12</pages>
<contexts>
<context citStr="Karttunen, 1998" endWordPosition="561" position="3692" startWordPosition="560">tion task for unrestricted OT is undecidable too.3 However, it is not in the spirit of OT to have extremely powerful individual constraints; the explanatory power should rather arise from interaction of simple constraints. 3 OT-LFG Following (Bresnan, 2000; Kuhn, 2000; Kuhn, 2001), we define a restricted OT system based on Lexical-Functional Grammar (LFG) representations: c(ategory) structure/f(unctional) structure 2Most computational OT work so far focuses on candidates and constraints expressible as regular languages/rational relations, based on (Frank and Satta, 1998) (e.g., (Eisner, 1997; Karttunen, 1998; Gerdemann and van Noord, 2000)). 3Cf. also (Johnson, 1998) for the sketch of an undecidability argument and (Kuhn, 2001, 4.2, 6.3) for further constructions. pairs like(4),(5). Each c-structure tree node is mapped to a node in the f-structure graph by the function. The mapping is specified by fannotations in the grammar rules (below category symbols, cf. (2)) and lexicon entries (3).4 (1) c-structure ROOT VP NP V 4abbreviates , i.e., the present category’simage; abbreviates , i.e., the f-structure corresponding to the present node’s mother category. The correct f-structure for a sentence is </context>
</contexts>
<marker>Karttunen, 1998</marker>
<rawString>Lauri Karttunen. 1998. The proper treatment of optimality in computational phonology. In Proceedings of the Internat. Workshop on Finite-State Methods in Natural Language Processing, FSMNLP’98, pages 1–12.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Jonas Kuhn</author>
</authors>
<title>Processing Optimality-theoretic syntax by interleaved chart parsing and generation.</title>
<date>2000</date>
<booktitle>In Proceedings ofACL 2000,</booktitle>
<pages>360--367</pages>
<contexts>
<context citStr="Kuhn, 2000" endWordPosition="353" position="2376" startWordPosition="352">ed a priori, using either a treebankderived or a manually written grammar for the given This work was supported by a postdoctoral fellowship of the German Academic Exchange Service (DAAD). 1This is for instance pointed out by (Johnson, 1998). language). The “base grammar” assumed as given can be highly unrestricted in the OT setup. Using a linguistically motivated set of constraints, learning proceeds with a bias for unmarked linguistic structures (cf. e.g., (Bresnan et al., 2001)). For computational OT syntax, an interleaving of candidate generation and constraint checking has been proposed (Kuhn, 2000). But the decidability of the optimization task in OT syntax, i.e., the identification of the optimal candidate(s) in a potentially infinite candidate set, has not been proven yet.2 2 Undecidability for unrestricted OT Assume that the candidate set is characterized by a context-free grammar (cfg) , plus one additional candidate ‘yes’. There are two constraints ( ): is violated if the candidate is neither ‘yes’ nor a structure generated by a cfg ; is violated only by ‘yes’. Now, ‘yes’ is in the language defined by this system iff there are no structures in that are also in . But the emptiness p</context>
<context citStr="Kuhn, 2000" endWordPosition="3174" position="19196" startWordPosition="3173">subset of the optimal candidates is among them. If the grammar does not contain any violation-free recursion, we even know that we have generated all optimal candidates. (19) A recursion with the derivation path is called violation-free iff all categories dominated by the upper occurrence of , but not dominated by the lower occurrence of have the form with Note that if there is an applicable violation-free recursion, the set of optimal candidates is infinite; so if the constraint set is set up properly in a linguistic analysis, one would assume that violation-free recursion should not arise. (Kuhn, 2000) excludes the application of such recursions by a similar condition as offline parsability (which excludes vacuous recursions over a string in parsing), but with the construction, this condition is not necessary for decidability of the generation-based optimization task. The cfg produced by can be transformed further to only generate the optimal candidates according to the constraint ranking of the OT system , eliminating all but the violation-free recursions in the grammar: (20) Creating a cfg that produces all optimal candidates a. Define contains no recursion. is finite and can be easily co</context>
</contexts>
<marker>Kuhn, 2000</marker>
<rawString>Jonas Kuhn. 2000. Processing Optimality-theoretic syntax by interleaved chart parsing and generation. In Proceedings ofACL 2000, pages 360–367, Hongkong.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Jonas Kuhn</author>
</authors>
<title>Formal and Computational Aspects of Optimality-theoretic Syntax.</title>
<date>2001</date>
<tech>Ph.D. thesis,</tech>
<institution>Institut f¨ur maschinelle Sprachverarbeitung, Universit¨at Stuttgart.</institution>
<contexts>
<context citStr="Kuhn, 2001" endWordPosition="517" position="3358" startWordPosition="516">violated if the candidate is neither ‘yes’ nor a structure generated by a cfg ; is violated only by ‘yes’. Now, ‘yes’ is in the language defined by this system iff there are no structures in that are also in . But the emptiness problem for the intersection of two context-free languages is known to be undecidable, so the optimization task for unrestricted OT is undecidable too.3 However, it is not in the spirit of OT to have extremely powerful individual constraints; the explanatory power should rather arise from interaction of simple constraints. 3 OT-LFG Following (Bresnan, 2000; Kuhn, 2000; Kuhn, 2001), we define a restricted OT system based on Lexical-Functional Grammar (LFG) representations: c(ategory) structure/f(unctional) structure 2Most computational OT work so far focuses on candidates and constraints expressible as regular languages/rational relations, based on (Frank and Satta, 1998) (e.g., (Eisner, 1997; Karttunen, 1998; Gerdemann and van Noord, 2000)). 3Cf. also (Johnson, 1998) for the sketch of an undecidability argument and (Kuhn, 2001, 4.2, 6.3) for further constructions. pairs like(4),(5). Each c-structure tree node is mapped to a node in the f-structure graph by the function</context>
</contexts>
<marker>Kuhn, 2001</marker>
<rawString>Jonas Kuhn. 2001. Formal and Computational Aspects of Optimality-theoretic Syntax. Ph.D. thesis, Institut f¨ur maschinelle Sprachverarbeitung, Universit¨at Stuttgart.</rawString>
</citation>
<citation valid="false">
<authors>
<author>Jonas Kuhn</author>
</authors>
<title>in preparation. Decidability of generation and parsing for OT syntax. Ms.,</title>
<institution>Stanford University.</institution>
<marker>Kuhn, </marker>
<rawString>Jonas Kuhn. in preparation. Decidability of generation and parsing for OT syntax. Ms., Stanford University.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Stefan Riezler</author>
<author>Detlef Prescher</author>
<author>Jonas Kuhn</author>
<author>Mark Johnson</author>
</authors>
<title>Lexicalized stochastic modeling of constraint-based grammars using log-linear measures and EM training.</title>
<date>2000</date>
<booktitle>In Proceedings of the 38th Annual Meeting ofthe Association for Computational Linguistics (ACL’00), Hong Kong,</booktitle>
<pages>480--487</pages>
<contexts>
<context citStr="Riezler et al., 2000" endWordPosition="223" position="1504" startWordPosition="219">a form is defined as grammatical if it is optimal (most harmonic) within a set of generation alternatives for an underlying logical form. The harmony of a candidate analysis depends on a language-specific ranking ( ) of violable constraints, thus the learning task amounts to adjusting the ranking over a given set of constraints. (1) Candidate is more harmonic than iff it incurs fewer violations of the highest-ranking constraint in which and differ. The comparison-based setup of OT learning is closely related to discriminative learning approaches in probabilistic parsing (Johnson et al., 1999; Riezler et al., 2000; Riezler et al., 2002),1 however the comparison of generation alternatives – rather than parsing alternatives – adds the possibility of systematically learning the basic language-specific grammatical principles (which in probabilistic parsing are typically fixed a priori, using either a treebankderived or a manually written grammar for the given This work was supported by a postdoctoral fellowship of the German Academic Exchange Service (DAAD). 1This is for instance pointed out by (Johnson, 1998). language). The “base grammar” assumed as given can be highly unrestricted in the OT setup. Using</context>
</contexts>
<marker>Riezler, Prescher, Kuhn, Johnson, 2000</marker>
<rawString>Stefan Riezler, Detlef Prescher, Jonas Kuhn, and Mark Johnson. 2000. Lexicalized stochastic modeling of constraint-based grammars using log-linear measures and EM training. In Proceedings of the 38th Annual Meeting ofthe Association for Computational Linguistics (ACL’00), Hong Kong, pages 480–487.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Stefan Riezler</author>
<author>Dick Crouch</author>
<author>Ron Kaplan</author>
<author>Tracy King</author>
<author>John Maxwell</author>
<author>Mark Johnson</author>
</authors>
<title>Parsing the Wall Street Journal using a Lexical-Functional Grammar and discriminative estimation techniques. This conference.</title>
<date>2002</date>
<contexts>
<context citStr="Riezler et al., 2002" endWordPosition="227" position="1527" startWordPosition="224">rammatical if it is optimal (most harmonic) within a set of generation alternatives for an underlying logical form. The harmony of a candidate analysis depends on a language-specific ranking ( ) of violable constraints, thus the learning task amounts to adjusting the ranking over a given set of constraints. (1) Candidate is more harmonic than iff it incurs fewer violations of the highest-ranking constraint in which and differ. The comparison-based setup of OT learning is closely related to discriminative learning approaches in probabilistic parsing (Johnson et al., 1999; Riezler et al., 2000; Riezler et al., 2002),1 however the comparison of generation alternatives – rather than parsing alternatives – adds the possibility of systematically learning the basic language-specific grammatical principles (which in probabilistic parsing are typically fixed a priori, using either a treebankderived or a manually written grammar for the given This work was supported by a postdoctoral fellowship of the German Academic Exchange Service (DAAD). 1This is for instance pointed out by (Johnson, 1998). language). The “base grammar” assumed as given can be highly unrestricted in the OT setup. Using a linguistically motiv</context>
</contexts>
<marker>Riezler, Crouch, Kaplan, King, Maxwell, Johnson, 2002</marker>
<rawString>Stefan Riezler, Dick Crouch, Ron Kaplan, Tracy King, John Maxwell, and Mark Johnson. 2002. Parsing the Wall Street Journal using a Lexical-Functional Grammar and discriminative estimation techniques. This conference.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>