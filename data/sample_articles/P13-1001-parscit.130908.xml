<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant confidence="0.000002" no="0">
<title confidence="0.999237">
A Shift-Reduce Parsing Algorithm for Phrase-based
String-to-Dependency Translation
</title>
<author confidence="0.999535">
Yang Liu
</author>
<affiliation confidence="0.957038">
State Key Laboratory of Intelligent Technology and Systems
Tsinghua National Laboratory for Information Science and Technology
Department of Computer Science and Technology
Tsinghua University, Beijing 100084, China
</affiliation>
<email confidence="0.995166">
liuyang2011@tsinghua.edu.cn
</email>
<sectionHeader confidence="0.993768" genericHeader="abstract">
Abstract
</sectionHeader>
<bodyText confidence="0.999927666666667">We introduce a shift-reduce parsing algorithm for phrase-based string-todependency translation. As the algorithm generates dependency trees for partial translations left-to-right in decoding, it allows for efficient integration of both n-gram and dependency language models. To resolve conflicts in shift-reduce parsing, we propose a maximum entropy model trained on the derivation graph of training data. As our approach combines the merits of phrase-based and string-todependency models, it achieves significant improvements over the two baselines on the NIST Chinese-English datasets.</bodyText>
<sectionHeader confidence="0.998991" genericHeader="introduction">
1 Introduction
</sectionHeader>
<bodyText confidence="0.999736619047619">Modern statistical machine translation approaches can be roughly divided into two broad categories: phrase-based and syntax-based. Phrase-based approaches treat phrase, which is usually a sequence of consecutive words, as the basic unit of translation (Koehn et al., 2003; Och and Ney, 2004). As phrases are capable of memorizing local context, phrase-based approaches excel at handling local word selection and reordering. In addition, it is straightforward to integrate n-gram language models into phrase-based decoders in which translation always grows left-to-right. As a result, phrase-based decoders only need to maintain the boundary words on one end to calculate language model probabilities. However, as phrase-based decoding usually casts translation as a string concatenation problem and permits arbitrary permutation, it proves to be NP-complete (Knight, 1999). Syntax-based approaches, on the other hand, model the hierarchical structure of natural languages (Wu, 1997; Yamada and Knight, 2001; Chiang, 2005; Quirk et al., 2005; Galley et al., 2006; Liu et al., 2006; Huang et al., 2006; Shen et al., 2008; Mi and Huang, 2008; Zhang et al., 2008). As syntactic information can be exploited to provide linguistically-motivated reordering rules, predicting non-local permutation is computationally tractable in syntax-based approaches. Unfortunately, as syntax-based decoders often generate target-language words in a bottom-up way using the CKY algorithm, integrating n-gram language models becomes more expensive because they have to maintain target boundary words at both ends of a partial translation (Chiang, 2007; Huang and Chiang, 2007). Moreover, syntax-based approaches often suffer from the rule coverage problem since syntactic constraints rule out a large portion of nonsyntactic phrase pairs, which might help decoders generalize well to unseen data (Marcu et al., 2006). Furthermore, the introduction of nonterminals makes the grammar size significantly bigger than phrase tables and leads to higher memory requirement (Chiang, 2007). As a result, incremental decoding with hierarchical structures has attracted increasing attention in recent years. While some authors try to integrate syntax into phrase-based decoding (Galley and Manning, 2008; Galley and Manning, 2009; Feng et al., 2010), others develop incremental algorithms for syntax-based models (Watanabe et al., 2006; Huang and Mi, 2010; Dyer and Resnik, 2010; Feng et al., 2012). Despite these successful efforts, challenges still remain for both directions. While parsing algorithms can be used to parse partial translations in phrase-based decoding, the search space is significantly enlarged since there are exponentially many parse trees for exponentially many translations. On the other hand, although target words can be generated left-to-right by altering the way of tree transversal in syntaxbased models, it is still difficult to reach full rule coverage as compared with phrase table.</bodyText>
<page confidence="0.822342">
1
</page>
<note confidence="0.6500013">
Proceedings of the 51st Annual Meeting of the Association for Computational Linguistics, pages 1–10,
Sofia, Bulgaria, August 4-9 2013. c�2013 Association for Computational Linguistics
zongtong jiang yu siyue lai lundun fangwen
The President will visit London in April
source phrase target phrase dependency category
r1 fangwen visit {} fixed
r2 yu siyue in April {1 → 2} fixed
r3 zongtong jiang The President will {2 → 1} floating left
r4 yu siyue lai lundun London in April {2 → 3} floating right
r5 zongtong jiang President will {} ill-formed
</note>
<figureCaption confidence="0.998539">
Figure 1: A training example consisting of a (romanized) Chinese sentence, an English dependency
tree, and the word alignment between them.</figureCaption>
<bodyText confidence="0.964953071428571">Each translation rule is composed of a source phrase, a target phrase with a set of dependency arcs.Following Shen et al. (2008), we distinguish between fixed, floating, and ill-formed structures. In this paper, we propose a shift-reduce parsing algorithm for phrase-based string-to-dependency translation. The basic unit of translation in our model is string-to-dependency phrase pair, which consists of a phrase on the source side and a dependency structure on the target side. The algorithm generates well-formed dependency structures for partial translations left-to-right using string-todependency phrase pairs. Therefore, our approach is capable of combining the advantages of both phrase-based and syntax-based approaches:</bodyText>
<listItem confidence="0.87505928">1. compact rule table: our rule table is a subset of the original string-to-dependency grammar (Shen et al., 2008; Shen et al., 2010) by excluding rules with non-terminals. 2. full rule coverage: all phrase pairs, both syntactic and non-syntactic, can be used in our algorithm. This is the same with Moses (Koehn et al., 2007). 3. efficient integration of n-gram language model: as translation grows left-to-right in our algorithm, integrating n-gram language models is straightforward. 4. exploiting syntactic information: as the shift-reduce parsing algorithm generates target language dependency trees in decoding, dependency language models (Shen et al., 2008; Shen et al., 2010) can be used to encourage linguistically-motivated reordering. 5. resolving local parsing ambiguity: as dependency trees for phrases are memorized in rules, our approach avoids resolving local parsing ambiguity and explores in a smaller search space than parsing word-by-word on the fly in decoding (Galley and Manning, 2009).</listItem>
<bodyText confidence="0.999669">We evaluate our method on the NIST ChineseEnglish translation datasets. Experiments show that our approach significantly outperforms both phrase-based (Koehn et al., 2007) and string-todependency approaches (Shen et al., 2008) in terms of BLEU and TER.</bodyText>
<sectionHeader confidence="0.846216" genericHeader="method">
2 Shift-Reduce Parsing for Phrase-based
String-to-Dependency Translation
</sectionHeader>
<bodyText confidence="0.969394">Figure 1 shows a training example consisting of a (romanized) Chinese sentence, an English dependency tree, and the word alignment between them. Following Shen et al. (2008), string-todependency rules without non-terminals can be extracted from the training example. As shown in Figure 1, each rule is composed of a source phrase and a target dependency structure.</bodyText>
<listItem confidence="0.7350942">Shen et al.(2008) divide dependency structures into two broad categories: 1. well-formed (a) fixed: the head is known or fixed; step action rule stack coverage
0 0 0 0 0 0 0 0
1 S r3 [The President will] 0 0 0 0 0 0 0
2 S r1 [The President will] [visit] 0 0 0 0 0 0 0
3 Rl [The President will visit] 0 0 0 0 0 0 0
4 S r4 [The President will visit] [London in April] 0 0 0 0 0 0 0
5 Rr [The President will visit London in April] 0 0 0 0 0 0 0</listItem>
<page confidence="0.994812">
2
</page>
<figureCaption confidence="0.934924">
Figure 2: Shift-reduce parsing with string-to-dependency phrase pairs. For each state, the algorithm
maintains a stack to store items (i.e., well-formed dependency structures).</figureCaption>
<listItem confidence="0.790216375">At each step, it chooses one action to extend a state: shift (S), reduce left (Rl), or reduce right (Rr). The decoding process terminates when all source words are covered and there is a complete dependency tree in the stack. (b) floating: sibling nodes of a common head, but the head itself is unspecified or floating. Each of the siblings must be a complete constituent. 2. ill-formed: neither fixed nor floating.</listItem>
<bodyText confidence="0.997525529411765">We further distinguish between left and right floating structures according to the position of head. For example, as “The President will” is the left dependant of its head “visit”, it is a left floating structure. To integrate the advantages of phrase-based and string-to-dependency models, we propose a shift-reduce algorithm for phrase-based string-todependency translation. Figure 2 shows an example. We describe a state (i.e., parser configuration) as a tuple (S, C) where S is a stack that stores items and C is a coverage vector that indicates which source words have been translated. Each item s E S is a well-formed dependency structure. The algorithm starts with an empty state. At each step, it chooses one of the three actions (Huang et al., 2009) to extend a state:</bodyText>
<listItem confidence="0.9818125">1. shift (S): move a target dependency structure onto the stack; 2. reduce left (Rl): combine the two items on the stack, st and st−1 (t &gt; 2), with the root of st as the head and replace them with a combined item; 3. reduce right (Rr): combine the two items on the stack, st and st−1 (t &gt; 2), with the root of st−1 as the head and replace them with a combined item.</listItem>
<bodyText confidence="0.999112">The decoding process terminates when all source words are covered and there is a complete dependency tree in the stack. Note that unlike monolingual shift-reduce parsers (Nivre, 2004; Zhang and Clark, 2008; Huang et al., 2009), our algorithm does not maintain a queue for remaining words of the input because the future dependency structure to be shifted is unknown in advance in the translation scenario. Instead, we use a coverage vector on the source side to determine when to terminate the algorithm. For an input sentence of J words, the number of actions is 2K −1, where K is the number of rules used in decoding. 1 There are always K shifts and 1Empirically, we find that the average number of stacks for J words is about 1.5 × J on the Chinese-English data.</bodyText>
<page confidence="0.953356">
3
</page>
<figure confidence="0.999568230769231">
[The President] [will] [visit]
S
Rl
[The President] [will visit]
Rl
[The President will visit]
[The President] [will] [visit] [London]
Rr
[The President] [will] [visit London]
Rl S
[The President] [will visit London]
[The President will visit] [London]
[The President will visit London]
</figure>
<figureCaption confidence="0.993776">
Figure 3: Ambiguity in shift-reduce parsing.
</figureCaption>
<figure confidence="0.60407">
Rl
Rr
st−1 st legal action(s)
yes S
</figure>
<construct confidence="0.60211225">
h yes S
l yes S
r no
h h yes S, Rl, Rr
h l yes S
h r yes Rr
l h yes Rl
l l yes S
l r no
r h no
r l no
r r no
</construct>
<tableCaption confidence="0.913449">
Table 1: Conflicts in shift-reduce parsing. st and
st−1 are the top two items in the stack of a state.</tableCaption>
<bodyText confidence="0.9820726875">We use “h” to denote fixed structure, “l” to denote left floating structure, and “r” to denote right floating structure. It is clear that only “h+h” is ambiguous.K − 1 reductions. It is easy to verify that the reduce left and reduce right actions are equivalent to the left adjoining and right adjoining operations defined by Shen et al.(2008). They suffice to operate on wellformed structures and produce projective dependency parse trees. Therefore, with dependency structures present in the stacks, it is possible to use dependency language models to encourage linguistically plausible phrase reordering.</bodyText>
<sectionHeader confidence="0.8483535" genericHeader="method">
3 A Maximum Entropy Based
Shift-Reduce Parsing Model
</sectionHeader>
<bodyText confidence="0.9999586">Shift-reduce parsing is efficient but suffers from parsing errors caused by syntactic ambiguity. Figure 3 shows two (partial) derivations for a dependency tree. Consider the item on the top, the algorithm can either apply a shift action to move a new item or apply a reduce left action to obtain a bigger structure. This is often referred to as conflict in the shift-reduce dependency parsing literature (Huang et al., 2009). In this work, the shift-reduce parser faces four types of conflicts:</bodyText>
<listItem confidence="0.998926">1. shift vs. shift; 2. shift vs. reduce left; 3. shift vs. reduce right; 4. reduce left vs. reduce right.</listItem>
<bodyText confidence="0.99913">Fortunately, if we distinguish between left and right floating structures, it is possible to rule out most conflicts. Table 1 shows the relationship between conflicts, dependency structures and actions. We use st and st−1 to denote the top two items in the stack.“h” stands for fixed structure, “l” for left floating structure, and “r” for right floating structure.</bodyText>
<page confidence="0.968993">
4
</page>
<figure confidence="0.5492596">
[The President will visit London][in April]
DT NNP MD VB NNP IN IN
type feature templates
Unigram c Wh(St) Wh(St−1)
Wlc(St) Wrc(St−1) Th(St)
Th(St−1) Tlc(St) Trc(St−1)
Bigram Wh(St) ◦ Wh(St−1) Th(St) ◦ Th(St−1) Wh(St) ◦ Th(St)//
Wh(St−1) ◦ Th(St−1) Wh(St) ◦ Wrc(St−1) Wh(St−1) ◦ Wlc(St)
Trigram c ◦ Wh(St) ◦ W(St−1) c ◦ Th(St) ◦ Th(St−1) Wh(St) ◦ Wh(St−1) ◦ Tlc(St)
Wh(St) ◦ Wh(St−1) ◦ Trc(St−1) Th(St) ◦ Th(St−1) ◦ Tlc(St) Th(St) ◦ Th(St−1) ◦ Trc(St−1)
</figure>
<figureCaption confidence="0.843019">
Figure 4: Feature templates for maximum entropy based shift-reduce parsing model. c is a boolean
value that indicate whether all source words are covered (shift is prohibited if true), Wh(·) and Th(·)
are functions that get the root word and tag of an item, Wl,(·) and Tl,(·) returns the word and tag of
the left most child of the root, Wr,(·) amd Tr,(·) returns the word and tag of the right most child of the
root. Symbol o denotes feature conjunction. In this example, c = true, Wh(st) = in, Th(st) = IN,
</figureCaption>
<equation confidence="0.717176">
Wh(st−1) = visit, Wl,(st−1) = London.
</equation>
<bodyText confidence="0.999971375">If the stack is empty, the only applicable action is shift. If there is only one item in the stack and the item is either fixed or left floating, the only applicable action is shift. Note that it is illegal to shift a right floating structure onto an empty stack because it will never be reduced. If the stack contains at least two items, only “h+h” is ambiguous and the others are either unambiguous or illegal. Therefore, we only need to focus on how to resolve conflicts for the “h+h” case (i.e., the top two items in a stack are both fixed structures). We propose a maximum entropy model to resolve the conflicts for “h+h”: 2 where a E {5, Rl, Rr} is an action, c is a boolean value that indicates whether all source words are covered (shift is prohibited if true), st and st−1 are the top two items on the stack, h(a, c, st, st−1) is a vector of binary features and θ is a vector of feature weights.</bodyText>
<equation confidence="0.953934333333333">
Pe(a |c, st, st−1) =ea pxp (p h(a, c' st, t s
tt )i))
ex( θ · h(ac,s
</equation>
<bodyText confidence="0.999795454545454">Figure 4 shows the feature templates used in our experiments. Wh(·) and Th(·) are functions that get the root word and tag of an item, Wl,(·) and Tl,(·) returns the word and tag of the left most child of the root, Wr,(·)</bodyText>
<footnote confidence="0.772908666666667">
2The shift-shift conflicts always exist because there are
usually multiple rules that can be shifted. This can be re-
volved using standard features in phrase-based models.
</footnote>
<bodyText confidence="0.991740058823529">word and tag of the right most child of the root. In this example, c = true, Wh(st) = in, Th(st) = IN, Wh(st−1) = visit, Wl,(st−1) = London. To train the model, we need an “oracle” or goldstandard action sequence for each training example. Unfortunately, such oracle turns out to be non-unique even for monolingual shift-reduce dependency parsing (Huang et al., 2009). The situation for phrase-based shift-reduce parsing aggravates because there are usually multiple ways of segmenting sentence into phrases. To alleviate this problem, we introduce a structure called derivation graph to compactly represent all derivations of a training example. Figure 3 shows a (partial) derivation graph, in which a node corresponds to a state and an edge corresponds to an action. The graph begins with an empty state and ends with the given training example. More formally, a derivation graph is a directed acyclic graph G = (V, E) where V is a set of nodes and E is a set of edges. Each node v corresponds to a state in the shift-reduce parsing process. There are two distinguished nodes: v0, the staring empty state, and v|V |, the ending completed state. Each edge e = (a, i, j) transits node vi to node vj via an action a E {5, Rl, Rr}. To build the derivation graph, our algorithm starts with an empty state and iteratively extends an unprocessed state until reaches the completed state. During the process, states that violate the training example are discarded. Even so, there are still exponentially many states for a training example, especially for long sentences. Fortunately, we and Tr,(·) returns the</bodyText>
<page confidence="0.829934">
5
</page>
<construct confidence="0.189702">
Algorithm 1 Beam-search shift-reduce parsing.
</construct>
<listItem confidence="0.934265846153846">1: procedure PARSE(f) 2: V ← 0 3: ADD(vo, V[0]) 4: k ← 0 5: while V[k] =� 0 do 6: for all v E V[k] do 7: for all a E {S, Rl, Rr} do 8: EXTEND(f, v, a, V) 9: end for 10: end for 11: k ← k + 1 12: end while 13: end procedure only need to focus on “h+h” states.</listItem>
<bodyText confidence="0.872642333333333">In addition, we follow Huang et al.(2009) to use the heuristic of “shortest stack” to always prefer Rl to S.</bodyText>
<sectionHeader confidence="0.998267" genericHeader="method">
4 Decoding
</sectionHeader>
<bodyText confidence="0.994781">Our decoder is based on a linear model (Och, 2003) with the following features:</bodyText>
<listItem confidence="0.9957307">1. relative frequencies in two directions; 2. lexical weights in two directions; 3. phrase penalty; 4. distance-based reordering model; 5. lexicaized reordering model; 6. n-gram language model model; 7. word penalty; 8. ill-formed structure penalty; 9. dependency language model; 10. maximum entropy parsing model.</listItem>
<bodyText confidence="0.997487272727273">In practice, we extend deterministic shiftreduce parsing with beam search (Zhang and Clark, 2008; Huang et al., 2009). As shown in Algorithm 1, the algorithm maintains a list of stacks V and each stack groups states with the same number of accumulated actions (line 2). The stack list V initializes with an empty state vo (line 3). Then, the states in the stack are iteratively extended until there are no incomplete states (lines 4-12). The search space is constrained by discarding any state that has a score worse than:</bodyText>
<listItem confidence="0.988568">1. β multiplied with the best score in the stack, or 2. the score of b-th best state in the stack.</listItem>
<bodyText confidence="0.999557848484849">As the stack of a state keeps changing during the decoding process, the context information needed to calculate dependency language model and maximum entropy model probabilities (e.g., root word, leftmost child, etc.) changes dynamically as well. As a result, the chance of risk-free hypothesis recombination (Koehn et al., 2003) significantly decreases because complicated contextual information is much less likely to be identical. Therefore, we use hypergraph reranking (Huang and Chiang, 2007; Huang, 2008), which proves to be effective for integrating non-local features into dynamic programming, to alleviate this problem. The decoding process is divided into two passes. In the first pass, only standard features (i.e., features 1-7 in the list in the beginning of this section) are used to produce a hypergraph. 3 In the second pass, we use the hypergraph reranking algorithm (Huang, 2008) to find promising translations using additional dependency features (i.e., features 8-10 in the list). As hypergraph is capable of storing exponentially many derivations compactly, the negative effect of propagating mistakes made in the first pass to the second pass can be minimized. To improve rule coverage, we follow Shen et al. (2008) to use ill-formed structures in decoding. If an ill-formed structure has a single root, it can treated as a (pseudo) fixed structure; otherwise it is transformed to one (pseudo) left floating structure and one (pseudo) right floating structure. We use a feature to count how many ill-formed structures are used in decoding.</bodyText>
<sectionHeader confidence="0.999456" genericHeader="evaluation and result">
5 Experiments
</sectionHeader>
<bodyText confidence="0.9998105">We evaluated our phrase-based string-todependency translation system on ChineseEnglish translation. The training data consists of 2.9M pairs of sentences with 76.0M Chinese words and 82.2M English words. We used the Stanford parser (Klein and Manning, 2003) to get dependency trees for English sentences. We used the SRILM toolkit (Stolcke, 2002) to train a system MT02 (tune) MT03 MT04 MT05
BLEU TER BLEU TER BLEU TER BLEU TER
phrase 34.88 57.00 33.82 57.19 35.48 56.48 32.52 57.62
dependency 35.23 56.12 34.20 56.36 36.01 55.55 33.06 56.94
this work 35.71** 55.87** 34.81**+ 55.94**+ 36.37** 55.02**+ 33.53** 56.58**</bodyText>
<footnote confidence="0.9751505">
3Note that the first pass does not work like a phrase-based
decoder because it yields dependency trees on the target side.
A uniform model (i.e., each action has a fixed probability of
1/3) is used to resolve “h+h” conflicts.
</footnote>
<page confidence="0.997579">
6
</page>
<tableCaption confidence="0.8071842">
Table 2: Comparison with Moses (Koehn et al., 2007) and a re-implementation of the bottom-up string-
to-dependency decoder (Shen et al., 2008) in terms of uncased BLEU and TER. We use randomiza-
tion test (Riezler and Maxwell, 2005) to calculate statistical significance. *: significantly better than
Moses (p &lt; 0.05), **: significantly better than Moses (p &lt; 0.01), +: significantly better than string-to-
dependency (p &lt; 0.05), ++: significantly better than string-to-dependency (p &lt; 0.01).
</tableCaption>
<table confidence="0.998684">
features BLEU TER
standard 34.79 56.93
+ depLM 35.29* 56.17**
+ maxent 35.40** 56.09**
+ depLM &amp; maxent 35.71** 55.87**
</table>
<tableCaption confidence="0.999111">
Table 3: Contribution of maximum entropy shift-
reduce parsing model.</tableCaption>
<bodyText confidence="0.995645904761905">“standard” denotes using standard features of phrase-based system. Adding dependency language model (“depLM”) and the maximum entropy shift-reduce parsing model (“maxent”) significantly improves BLEU and TER on the development set, both separately and jointly. 4-gram language model on the Xinhua portion of the GIGAWORD coprus, which contians 238M English words. A 3-gram dependency language model was trained on the English dependency trees. We used the 2002 NIST MT ChineseEnglish dataset as the development set and the 2003-2005 NIST datasets as the testsets. We evaluated translation quality using uncased BLEU (Papineni et al., 2002) and TER (Snover et al., 2006). The features were optimized with respect to BLEU using the minimum error rate training algorithm (Och, 2003). We chose the following two systems that are closest to our work as baselines:</bodyText>
<listItem confidence="0.995677">1. The Moses phrase-based decoder (Koehn et al., 2007). 2. A re-implementation of bottom-up string-todependency decoder (Shen et al., 2008).</listItem>
<footnote confidence="0.560163333333333">
All the three systems share with the same target-
side parsed, word-aligned training data. The his-
togram pruning parameter b is set to 100 and
</footnote>
<table confidence="0.990897666666667">
rules coverage BLEU TER
well-formed 44.87 34.42 57.35
all 100.00 35.71** 55.87**
</table>
<tableCaption confidence="0.9096608">
Table 4: Comparison of well-formed and ill-
formed structures. Using all rules significantly
outperforms using only well-formed structures.
BLEU and TER scores are calculated on the de-
velopment set.
</tableCaption>
<bodyText confidence="0.999974851851852">phrase table limit is set to 20 for all the three systems. Moses shares the same feature set with our system except for the dependency features. For the bottom-up string-to-dependency system, we included both well-formed and ill-formed structures in chart parsing. To control the grammar size, we only extracted “tight” initial phrase pairs (i.e., the boundary words of a phrase must be aligned) as suggested by (Chiang, 2007). For our system, we used the Le Zhang’s maximum entropy modeling toolkit to train the shift-reduce parsing model after extracting 32.6M events from the training data. 4 We set the iteration limit to 100. The accuracy on the training data is 90.18%. Table 2 gives the performance of Moses, the bottom-up string-to-dependency system, and our system in terms of uncased BLEU and TER scores. From the same training data, Moses extracted 103M bilingual phrases, the bottomup string-to-dependency system extracted 587M string-to-dependency rules, and our system extracted 124M phrase-based dependency rules. We find that our approach outperforms both baselines systematically on all testsets. We use randomization test (Riezler and Maxwell, 2005) to calculate statistical significance. As our system can take full advantage of lexicalized reordering and dependency language models without loss in rule coverage, it achieves significantly better results than Moses on all test sets.</bodyText>
<footnote confidence="0.96936">
4http://homepages.inf.ed.ac.uk/lzhang10/maxent.html
</footnote>
<page confidence="0.998152">
7
</page>
<figure confidence="0.989032">
BLEU
0 2 4 6 8 10 12
distortion limit
</figure>
<figureCaption confidence="0.996935">
Figure 5: Performance of Moses and our system
with various distortion limits.
</figureCaption>
<bodyText confidence="0.998299405405405">The gains in TER are much larger than BLEU because dependency language models do not model n-grams directly. Compared with the bottom-up string-to-dependency system, our system outperforms consistently but not significantly in all cases. The average decoding time for Moses is 3.67 seconds per sentence, bottomup string-to-dependency is 13.89 seconds, and our system is 4.56 seconds. Table 3 shows the effect of hypergraph reranking. In the first pass, our decoder uses standard phrase-based features to build a hypergraph. The BLEU score is slightly lower than Moses with the same configuration. One possible reason is that our decoder organizes stacks with respect to actions, whereas Moses groups partial translations with the same number of covered source words in stacks. In the second pass, our decoder reranks the hypergraph with additional dependency features. We find that adding dependency language and maximum entropy shift-reduce models consistently brings significant improvements, both separately and jointly. We analyzed translation rules extracted from the training data. Among them, well-formed structures account for 43.58% (fixed 33.21%, floating left 9.01%, and floating right 1.36%) and illformed structures 56.42%. As shown in Table 4, using all rules clearly outperforms using only well-formed structures. Figure 5 shows the performance of Moses and our system with various distortion limits on the development set. Our system consistently outperforms Moses in all cases, suggesting that adding dependency helps improve phrase reordering.</bodyText>
<sectionHeader confidence="0.999697" genericHeader="related work">
6 Related Work
</sectionHeader>
<bodyText confidence="0.999821957446809">The work of Galley and Manning (2009) is closest in spirit to ours. They introduce maximum spanning tree (MST) parsing (McDonald et al., 2005) into phrase-based translation. The system is phrase-based except that an MST parser runs to parse partial translations at the same time. One challenge is that MST parsing itself is not incremental, making it expensive to identify loops during hypothesis expansion. On the contrary, shiftreduce parsing is naturally incremental and can be seamlessly integrated into left-to-right phrasebased decoding. More importantly, in our work dependency trees are memorized for phrases rather than being generated word by word on the fly in decoding. This treatment might not only reduce decoding complexity but also potentially revolve local parsing ambiguity. Our decoding algorithm is similar to Gimpel and Smith (2011)’s lattice parsing algorithm as we divide decoding into two steps: hypergraph generation and hypergraph rescoring. The major difference is that our hypergraph is not a phrasal lattice because each phrase pair is associated with a dependency structure on the target side. In other words, our second pass is to find the Viterbi derivation with addition features rather than parsing the phrasal lattice. In addition, their algorithm produces phrasal dependency parse trees while the leaves of our dependency trees are words, making dependency language models can be directly used. Shift-reduce parsing has been successfully used in phrase-based decoding but limited to adding structural constraints. Galley and Manning (2008) propose a shift-reduce algorithm to integrate a hierarchical reordering model into phrase-based systems. Feng et al. (2010) use shift-reduce parsing to impose ITG (Wu, 1997) constraints on phrase permutation. Our work differs from theirs by going further to incorporate linguistic syntax into phrase-based decoding. Along another line, a number of authors have developed incremental algorithms for syntaxbased models (Watanabe et al., 2006; Huang and Mi, 2010; Dyer and Resnik, 2010; Feng et al., 2012). Watanabe et al. (2006) introduce an Earlystyle top-down parser based on binary-branching Greibach Normal Form. Huang et al. (2010), Dyer and Resnik (2010), and Feng et al.(2012) use dotted rules to change the tree transversal to generate target words left-to-right, either top-down or bottom-up.</bodyText>
<figure confidence="0.993280818181818">
34.50
34.00
33.50
33.00
32.50
32.00
31.50
31.00
30.50
this work
Moses
</figure>
<page confidence="0.991285">
8
</page>
<sectionHeader confidence="0.996741" genericHeader="conclusion">
7 Conclusion
</sectionHeader>
<bodyText confidence="0.999843842105263">We have presented a shift-reduce parsing algorithm for phrase-based string-to-dependency translation. The algorithm generates dependency structures incrementally using string-todependency phrase pairs. Therefore, our approach is capable of combining the advantages of both phrase-based and string-to-dependency models, it outperforms the two baselines on Chineseto-English translation. In the future, we plan to include more contextual information (e.g., the uncovered source phrases) in the maximum entropy model to resolve conflicts. Another direction is to adapt the dynamic programming algorithm proposed by Huang and Sagae (2010) to improve our string-todependency decoder. It is also interesting to compare with applying word-based shift-reduce parsing to phrase-based decoding similar to (Galley and Manning, 2009).</bodyText>
<sectionHeader confidence="0.997477" genericHeader="acknowledgments">
Acknowledgments
</sectionHeader>
<bodyText confidence="0.999869125">This research is supported by the 863 Program under the grant No 2012AA011102 and No. 2011AA01A207, by the Singapore National Research Foundation under its International Research Centre @ Singapore Funding Initiative and administered by the IDM Programme Office, and by a Research Fund No. 20123000007 from Tsinghua MOE-Microsoft Joint Laboratory.</bodyText>
<sectionHeader confidence="0.998501" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.999678919354839">
David Chiang. 2005. A hiearchical phrase-based
model for statistical machine translation. In Proc.
of ACL 2005.
David Chiang. 2007. Hierarchical phrase-based trans-
lation. Computational Linguistics, 33(2):201–228.
Chris Dyer and Philip Resnik. 2010. Context-free re-
ordering, finite-state translation. In Proc. of NAACL
2010.
Yang Feng, Haitao Mi, Yang Liu, and Qun Liu.
2010. An efficient shift-reduce decoding algorithm
for phrased-based machine translation. In Proc. of
COLING 2010.
Yang Feng, Yang Liu, Qun Liu, and Trevor Cohn.
2012. Left-to-right tree-to-string decoding with pre-
diction. In Proc. of EMNLP 2012.
Michel Galley and Christopher D. Manning. 2008. A
simple and effective hierarchical phrase reordering
model. In Proc. of EMNLP 2008.
Michel Galley and Christopher D. Manning. 2009.
Quadratic-time dependency parsing for machine
translation. In Proc. ofACL 2009.
Michel Galley, Jonathan Graehl, Kevin Knight, Daniel
Marcu, Steve DeNeefe, Wei Wang, and Ignacio
Thayer. 2006. Scalable inference and training of
context-rich syntactic translation models. In Proc.
ofACL 2006.
Kevin Gimpel and Noah A. Smith. 2011. Quasi-
synchronous phrase dependency grammars for ma-
chine translation. In Proc. of EMNLP 2011.
Liang Huang and David Chiang. 2007. Forest rescor-
ing: Faster decoding with integrated language mod-
els. In Proc. of ACL 2007.
Liang Huang and Haitao Mi. 2010. Efficient incre-
mental decoding for tree-to-string translation. In
Proc. of EMNLP 2010.
Liang Huang and Kenji Sagae. 2010. Dynamic pro-
gramming for linear-time incremental parsing. In
Proc. of ACL 2010.
Liang Huang, Kevin Knight, and Aravind Joshi. 2006.
Statistical syntax-directed translation with extended
domain of locality. In Proc. of AMTA 2006.
Liang Huang, Wenbin Jiang, and Qun Liu. 2009.
Bilingually-constrained (monolingual) shift-reduce
parsing. In Proc. of EMNLP 2009.
Liang Huang. 2008. Forest reranking: Discrimina-
tive parsing with non-local features. In Proc. ofACL
2008.
Dan Klein and Christopher Manning. 2003. Accurate
unlexicalized parsing. In Proc. ofACL 2003.
Kevin Knight. 1999. Decoding complexity in word-
replacement translation models. Computational
Linguistics.
Philipp Koehn, Franz Och, and Daniel Marcu. 2003.
Statistical phrase-based translation. In Proc. of
NAACL 2003.
Philipp Koehn, Hieu Hoang, Alexandra Birch, Chris
Callison-Burch, Marcello Federico, Nicola Bertoldi,
Brooke Cowan, Wade Shen, Christine Moran,
Richard Zens, Chris Dyer, Ondrej Bojar, Alexandra
Constantin, and Evan Herbst. 2007. Moses: Open
source toolkit for statistical machine translation. In
Proc. of ACL 2007.
</reference>
<page confidence="0.998172">
9
</page>
<bodyText confidence="0.978192666666667">Kenji Yamada and Kevin Knight. 2001. A syntaxbased statistical translation model. In Proc. of ACL 2001. Yang Liu, Qun Liu, and Shouxun Lin. 2006. Treeto-string alignment template for statistical machine translation. In Proc. of ACL 2006.</bodyText>
<reference confidence="0.999449642857142">
Daniel Marcu, Wei Wang, Abdessamad Echihabi, and
Kevin Knight. 2006. Spmt: Statistical machine
translation with syntactified target language phrases.
In Proc. of EMNLP 2006.
R. McDonald, F. Pereira, K. Ribarov, and J. Hajic.
2005. Non-projective dependency parsing using
spanning tree algorithms. In Proc. of EMNLP 2005.
Haitao Mi and Liang Huang. 2008. Forest-based trans-
lation. In Proc. ofACL 2008.
Joakim Nivre. 2004. Incrementality in deterministic
dependency parsing. In Proc. of ACL 2004 Work-
shop Incremental Parsing: Bringning Engineering
and Cognition Together.
Franz Och and Hermann Ney. 2004. The alignment
template approach to statistical machine translation.
Computational Linguistics, 30(4).
Franz Och. 2003. Minimum error rate training in sta-
tistical machine translation. In Proc. of ACL 2003.
Kishore Papineni, Salim Roukos, Todd Ward, and Wei-
Jing Zhu. 2002. Bleu: a method for automatic eval-
uation of machine translation. In Proc. ofACL 2002.
Chris Quirk, Arul Menezes, and Colin Cherry. 2005.
Dependency treelet translation: Syntactically in-
formed phrasal smt. In Proc. ofACL 2005.
S. Riezler and J. Maxwell. 2005. On some pitfalls
in automatic evaluation and significance testing for
mt. In Proc. ofACL 2005 Workshop on Intrinsic and
Extrinsic Evaluation Measures for Machine Trans-
lation and/or Summarization.
Libin Shen, Jinxi Xu, and Ralph Weischedel. 2008. A
new string-to-dependency machine translation algo-
rithm with a target dependency language model. In
Proc. ofACL 2008.
Libin Shen, Jinxi Xu, and Ralph Weischedel. 2010.
String-to-dependency statistical machine transla-
tion. Computational Linguistics, 36(4).
Matthew Snover, Bonnie Dorr, Richard Schwartz, Lin-
nea Micciulla, and John Makhoul. 2006. A study of
translation edit rate with targeted human annotation.
In Proc. ofAMTA 2006.
Andreas Stolcke. 2002. Srilm - an extensible language
modeling toolkit. In Proc. of ICSLP 2002.
Taro Watanabe, Hajime Tsukuda, and Hideki Isozaki.
2006. Left-to-right target generation for hierarchical
phrase-based translation. In Proc. of ACL 2006.
Dekai Wu. 1997. Stochastic inversion transduction
grammars and bilingual parsing of parallel corpora.
Computational Linguistics.
Yue Zhang and Stephen Clark. 2008. A tale of
two parsers: investigating and combining graph-
based and transition-based dependency parsing us-
ing beam search. In Proc. of EMNLP 2008.
Min Zhang, Hongfei Jiang, Aiti Aw, Haizhou Li,
Chew Lim Tan, and Sheng Li. 2008. A tree
sequence alignment-based tree-to-tree translation
model. In Proc. of ACL 2008.
</reference>
<page confidence="0.997799">
10
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant confidence="0.502993" no="0">
<title confidence="0.999235">A Shift-Reduce Parsing Algorithm for String-to-Dependency Translation</title>
<author confidence="0.850666">Yang</author>
<affiliation confidence="0.89601575">State Key Laboratory of Intelligent Technology and Tsinghua National Laboratory for Information Science and Department of Computer Science and Tsinghua University, Beijing 100084,</affiliation>
<email confidence="0.787842">liuyang2011@tsinghua.edu.cn</email>
<abstract confidence="0.9923903125">We introduce a shift-reduce parsing algorithm for phrase-based string-todependency translation. As the algorithm generates dependency trees for partial translations left-to-right in decoding, it allows for efficient integration of both and dependency language models. To resolve conflicts in shift-reduce parsing, we propose a maximum entropy model trained on the derivation graph of training data. As our approach combines the merits of phrase-based and string-todependency models, it achieves significant improvements over the two baselines on the NIST Chinese-English datasets.</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>David Chiang</author>
</authors>
<title>A hiearchical phrase-based model for statistical machine translation.</title>
<date>2005</date>
<booktitle>In Proc. of ACL</booktitle>
<contexts>
<context citStr="Chiang, 2005" endWordPosition="272" position="1968" startWordPosition="271">and reordering. In addition, it is straightforward to integrate n-gram language models into phrase-based decoders in which translation always grows left-to-right. As a result, phrase-based decoders only need to maintain the boundary words on one end to calculate language model probabilities. However, as phrase-based decoding usually casts translation as a string concatenation problem and permits arbitrary permutation, it proves to be NP-complete (Knight, 1999). Syntax-based approaches, on the other hand, model the hierarchical structure of natural languages (Wu, 1997; Yamada and Knight, 2001; Chiang, 2005; Quirk et al., 2005; Galley et al., 2006; Liu et al., 2006; Huang et al., 2006; Shen et al., 2008; Mi and Huang, 2008; Zhang et al., 2008). As syntactic information can be exploited to provide linguistically-motivated reordering rules, predicting non-local permutation is computationally tractable in syntax-based approaches. Unfortunately, as syntax-based decoders often generate target-language words in a bottom-up way using the CKY algorithm, integrating n-gram language models becomes more expensive because they have to maintain target boundary words at both ends of a partial translation (Chi</context>
</contexts>
<marker>Chiang, 2005</marker>
<rawString>David Chiang. 2005. A hiearchical phrase-based model for statistical machine translation. In Proc. of ACL 2005.</rawString>
</citation>
<citation valid="true">
<authors>
<author>David Chiang</author>
</authors>
<title>Hierarchical phrase-based translation.</title>
<date>2007</date>
<journal>Computational Linguistics,</journal>
<volume>33</volume>
<issue>2</issue>
<contexts>
<context citStr="Chiang, 2007" endWordPosition="365" position="2577" startWordPosition="364">005; Quirk et al., 2005; Galley et al., 2006; Liu et al., 2006; Huang et al., 2006; Shen et al., 2008; Mi and Huang, 2008; Zhang et al., 2008). As syntactic information can be exploited to provide linguistically-motivated reordering rules, predicting non-local permutation is computationally tractable in syntax-based approaches. Unfortunately, as syntax-based decoders often generate target-language words in a bottom-up way using the CKY algorithm, integrating n-gram language models becomes more expensive because they have to maintain target boundary words at both ends of a partial translation (Chiang, 2007; Huang and Chiang, 2007). Moreover, syntax-based approaches often suffer from the rule coverage problem since syntactic constraints rule out a large portion of nonsyntactic phrase pairs, which might help decoders generalize well to unseen data (Marcu et al., 2006). Furthermore, the introduction of nonterminals makes the grammar size significantly bigger than phrase tables and leads to higher memory requirement (Chiang, 2007). As a result, incremental decoding with hierarchical structures has attracted increasing attention in recent years. While some authors try to integrate syntax into phrase</context>
<context citStr="Chiang, 2007" endWordPosition="3048" position="18122" startWordPosition="3047">core worse than: 1. β multiplied with the best score in the stack, or 2. the score of b-th best state in the stack. As the stack of a state keeps changing during the decoding process, the context information needed to calculate dependency language model and maximum entropy model probabilities (e.g., root word, leftmost child, etc.) changes dynamically as well. As a result, the chance of risk-free hypothesis recombination (Koehn et al., 2003) significantly decreases because complicated contextual information is much less likely to be identical. Therefore, we use hypergraph reranking (Huang and Chiang, 2007; Huang, 2008), which proves to be effective for integrating non-local features into dynamic programming, to alleviate this problem. The decoding process is divided into two passes. In the first pass, only standard features (i.e., features 1-7 in the list in the beginning of this section) are used to produce a hypergraph. 3 In the second pass, we use the hypergraph reranking algorithm (Huang, 2008) to find promising translations using additional dependency features (i.e., features 8-10 in the list). As hypergraph is capable of storing exponentially many derivations compactly, the negative effe</context>
<context citStr="Chiang, 2007" endWordPosition="3750" position="22569" startWordPosition="3749">omparison of well-formed and illformed structures. Using all rules significantly outperforms using only well-formed structures. BLEU and TER scores are calculated on the development set. phrase table limit is set to 20 for all the three systems. Moses shares the same feature set with our system except for the dependency features. For the bottom-up string-to-dependency system, we included both well-formed and ill-formed structures in chart parsing. To control the grammar size, we only extracted “tight” initial phrase pairs (i.e., the boundary words of a phrase must be aligned) as suggested by (Chiang, 2007). For our system, we used the Le Zhang’s maximum entropy modeling toolkit to train the shift-reduce parsing model after extracting 32.6M events from the training data. 4 We set the iteration limit to 100. The accuracy on the training data is 90.18%. Table 2 gives the performance of Moses, the bottom-up string-to-dependency system, and our system in terms of uncased BLEU and TER scores. From the same training data, Moses extracted 103M bilingual phrases, the bottomup string-to-dependency system extracted 587M string-to-dependency rules, and our system extracted 124M phrase-based dependency rule</context>
</contexts>
<marker>Chiang, 2007</marker>
<rawString>David Chiang. 2007. Hierarchical phrase-based translation. Computational Linguistics, 33(2):201–228.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Chris Dyer</author>
<author>Philip Resnik</author>
</authors>
<title>Context-free reordering, finite-state translation.</title>
<date>2010</date>
<booktitle>In Proc. of NAACL</booktitle>
<contexts>
<context citStr="Dyer and Resnik, 2010" endWordPosition="489" position="3393" startWordPosition="486">ight help decoders generalize well to unseen data (Marcu et al., 2006). Furthermore, the introduction of nonterminals makes the grammar size significantly bigger than phrase tables and leads to higher memory requirement (Chiang, 2007). As a result, incremental decoding with hierarchical structures has attracted increasing attention in recent years. While some authors try to integrate syntax into phrase-based decoding (Galley and Manning, 2008; Galley and Manning, 2009; Feng et al., 2010), others develop incremental algorithms for syntax-based models (Watanabe et al., 2006; Huang and Mi, 2010; Dyer and Resnik, 2010; Feng et al., 2012). Despite these successful efforts, challenges still remain for both directions. While parsing algorithms can be used to parse partial translations in phrase-based decoding, the search space is significantly enlarged since there are exponentially many parse trees for exponentially many translations. On the other hand, although target words can be generated left-to-right by altering the way of tree transversal in syntaxbased models, it is still difficult to reach full rule coverage as compared with phrase table. 1 Proceedings of the 51st Annual Meeting of the Association for</context>
<context citStr="Dyer and Resnik, 2010" endWordPosition="4483" position="27351" startWordPosition="4480">reduce parsing has been successfully used in phrase-based decoding but limited to adding structural constraints. Galley and Manning (2008) propose a shift-reduce algorithm to integrate a hierarchical reordering model into phrase-based systems. Feng et al. (2010) use shift-reduce parsing to impose ITG (Wu, 1997) constraints on phrase permutation. Our work differs from theirs by going further to incorporate linguistic syntax into phrase-based decoding. Along another line, a number of authors have developed incremental algorithms for syntaxbased models (Watanabe et al., 2006; Huang and Mi, 2010; Dyer and Resnik, 2010; Feng et al., 2012). Watanabe et al. (2006) introduce an Earlystyle top-down parser based on binary-branching Greibach Normal Form. Huang et al. (2010), Dyer 34.50 34.00 33.50 33.00 32.50 32.00 31.50 31.00 30.50 this work Moses 8 and Resnik (2010), and Feng et al. (2012) use dotted rules to change the tree transversal to generate target words left-to-right, either top-down or bottom-up. 7 Conclusion We have presented a shift-reduce parsing algorithm for phrase-based string-to-dependency translation. The algorithm generates dependency structures incrementally using string-todependency phrase p</context>
</contexts>
<marker>Dyer, Resnik, 2010</marker>
<rawString>Chris Dyer and Philip Resnik. 2010. Context-free reordering, finite-state translation. In Proc. of NAACL 2010.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Yang Feng</author>
<author>Haitao Mi</author>
<author>Yang Liu</author>
<author>Qun Liu</author>
</authors>
<title>An efficient shift-reduce decoding algorithm for phrased-based machine translation.</title>
<date>2010</date>
<booktitle>In Proc. of COLING</booktitle>
<contexts>
<context citStr="Feng et al., 2010" endWordPosition="469" position="3264" startWordPosition="466">ffer from the rule coverage problem since syntactic constraints rule out a large portion of nonsyntactic phrase pairs, which might help decoders generalize well to unseen data (Marcu et al., 2006). Furthermore, the introduction of nonterminals makes the grammar size significantly bigger than phrase tables and leads to higher memory requirement (Chiang, 2007). As a result, incremental decoding with hierarchical structures has attracted increasing attention in recent years. While some authors try to integrate syntax into phrase-based decoding (Galley and Manning, 2008; Galley and Manning, 2009; Feng et al., 2010), others develop incremental algorithms for syntax-based models (Watanabe et al., 2006; Huang and Mi, 2010; Dyer and Resnik, 2010; Feng et al., 2012). Despite these successful efforts, challenges still remain for both directions. While parsing algorithms can be used to parse partial translations in phrase-based decoding, the search space is significantly enlarged since there are exponentially many parse trees for exponentially many translations. On the other hand, although target words can be generated left-to-right by altering the way of tree transversal in syntaxbased models, it is still dif</context>
<context citStr="Feng et al. (2010)" endWordPosition="4428" position="26992" startWordPosition="4425">a dependency structure on the target side. In other words, our second pass is to find the Viterbi derivation with addition features rather than parsing the phrasal lattice. In addition, their algorithm produces phrasal dependency parse trees while the leaves of our dependency trees are words, making dependency language models can be directly used. Shift-reduce parsing has been successfully used in phrase-based decoding but limited to adding structural constraints. Galley and Manning (2008) propose a shift-reduce algorithm to integrate a hierarchical reordering model into phrase-based systems. Feng et al. (2010) use shift-reduce parsing to impose ITG (Wu, 1997) constraints on phrase permutation. Our work differs from theirs by going further to incorporate linguistic syntax into phrase-based decoding. Along another line, a number of authors have developed incremental algorithms for syntaxbased models (Watanabe et al., 2006; Huang and Mi, 2010; Dyer and Resnik, 2010; Feng et al., 2012). Watanabe et al. (2006) introduce an Earlystyle top-down parser based on binary-branching Greibach Normal Form. Huang et al. (2010), Dyer 34.50 34.00 33.50 33.00 32.50 32.00 31.50 31.00 30.50 this work Moses 8 and Resnik</context>
</contexts>
<marker>Feng, Mi, Liu, Liu, 2010</marker>
<rawString>Yang Feng, Haitao Mi, Yang Liu, and Qun Liu. 2010. An efficient shift-reduce decoding algorithm for phrased-based machine translation. In Proc. of COLING 2010.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Yang Feng</author>
<author>Yang Liu</author>
<author>Qun Liu</author>
<author>Trevor Cohn</author>
</authors>
<title>Left-to-right tree-to-string decoding with prediction.</title>
<date>2012</date>
<booktitle>In Proc. of EMNLP</booktitle>
<contexts>
<context citStr="Feng et al., 2012" endWordPosition="493" position="3413" startWordPosition="490">ralize well to unseen data (Marcu et al., 2006). Furthermore, the introduction of nonterminals makes the grammar size significantly bigger than phrase tables and leads to higher memory requirement (Chiang, 2007). As a result, incremental decoding with hierarchical structures has attracted increasing attention in recent years. While some authors try to integrate syntax into phrase-based decoding (Galley and Manning, 2008; Galley and Manning, 2009; Feng et al., 2010), others develop incremental algorithms for syntax-based models (Watanabe et al., 2006; Huang and Mi, 2010; Dyer and Resnik, 2010; Feng et al., 2012). Despite these successful efforts, challenges still remain for both directions. While parsing algorithms can be used to parse partial translations in phrase-based decoding, the search space is significantly enlarged since there are exponentially many parse trees for exponentially many translations. On the other hand, although target words can be generated left-to-right by altering the way of tree transversal in syntaxbased models, it is still difficult to reach full rule coverage as compared with phrase table. 1 Proceedings of the 51st Annual Meeting of the Association for Computational Lingu</context>
<context citStr="Feng et al., 2012" endWordPosition="4487" position="27371" startWordPosition="4484"> successfully used in phrase-based decoding but limited to adding structural constraints. Galley and Manning (2008) propose a shift-reduce algorithm to integrate a hierarchical reordering model into phrase-based systems. Feng et al. (2010) use shift-reduce parsing to impose ITG (Wu, 1997) constraints on phrase permutation. Our work differs from theirs by going further to incorporate linguistic syntax into phrase-based decoding. Along another line, a number of authors have developed incremental algorithms for syntaxbased models (Watanabe et al., 2006; Huang and Mi, 2010; Dyer and Resnik, 2010; Feng et al., 2012). Watanabe et al. (2006) introduce an Earlystyle top-down parser based on binary-branching Greibach Normal Form. Huang et al. (2010), Dyer 34.50 34.00 33.50 33.00 32.50 32.00 31.50 31.00 30.50 this work Moses 8 and Resnik (2010), and Feng et al. (2012) use dotted rules to change the tree transversal to generate target words left-to-right, either top-down or bottom-up. 7 Conclusion We have presented a shift-reduce parsing algorithm for phrase-based string-to-dependency translation. The algorithm generates dependency structures incrementally using string-todependency phrase pairs. Therefore, our</context>
</contexts>
<marker>Feng, Liu, Liu, Cohn, 2012</marker>
<rawString>Yang Feng, Yang Liu, Qun Liu, and Trevor Cohn. 2012. Left-to-right tree-to-string decoding with prediction. In Proc. of EMNLP 2012.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Michel Galley</author>
<author>Christopher D Manning</author>
</authors>
<title>A simple and effective hierarchical phrase reordering model.</title>
<date>2008</date>
<booktitle>In Proc. of EMNLP</booktitle>
<contexts>
<context citStr="Galley and Manning, 2008" endWordPosition="461" position="3218" startWordPosition="458">g, 2007). Moreover, syntax-based approaches often suffer from the rule coverage problem since syntactic constraints rule out a large portion of nonsyntactic phrase pairs, which might help decoders generalize well to unseen data (Marcu et al., 2006). Furthermore, the introduction of nonterminals makes the grammar size significantly bigger than phrase tables and leads to higher memory requirement (Chiang, 2007). As a result, incremental decoding with hierarchical structures has attracted increasing attention in recent years. While some authors try to integrate syntax into phrase-based decoding (Galley and Manning, 2008; Galley and Manning, 2009; Feng et al., 2010), others develop incremental algorithms for syntax-based models (Watanabe et al., 2006; Huang and Mi, 2010; Dyer and Resnik, 2010; Feng et al., 2012). Despite these successful efforts, challenges still remain for both directions. While parsing algorithms can be used to parse partial translations in phrase-based decoding, the search space is significantly enlarged since there are exponentially many parse trees for exponentially many translations. On the other hand, although target words can be generated left-to-right by altering the way of tree tran</context>
<context citStr="Galley and Manning (2008)" endWordPosition="4409" position="26868" startWordPosition="4406">rgraph rescoring. The major difference is that our hypergraph is not a phrasal lattice because each phrase pair is associated with a dependency structure on the target side. In other words, our second pass is to find the Viterbi derivation with addition features rather than parsing the phrasal lattice. In addition, their algorithm produces phrasal dependency parse trees while the leaves of our dependency trees are words, making dependency language models can be directly used. Shift-reduce parsing has been successfully used in phrase-based decoding but limited to adding structural constraints. Galley and Manning (2008) propose a shift-reduce algorithm to integrate a hierarchical reordering model into phrase-based systems. Feng et al. (2010) use shift-reduce parsing to impose ITG (Wu, 1997) constraints on phrase permutation. Our work differs from theirs by going further to incorporate linguistic syntax into phrase-based decoding. Along another line, a number of authors have developed incremental algorithms for syntaxbased models (Watanabe et al., 2006; Huang and Mi, 2010; Dyer and Resnik, 2010; Feng et al., 2012). Watanabe et al. (2006) introduce an Earlystyle top-down parser based on binary-branching Greiba</context>
</contexts>
<marker>Galley, Manning, 2008</marker>
<rawString>Michel Galley and Christopher D. Manning. 2008. A simple and effective hierarchical phrase reordering model. In Proc. of EMNLP 2008.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Michel Galley</author>
<author>Christopher D Manning</author>
</authors>
<title>Quadratic-time dependency parsing for machine translation.</title>
<date>2009</date>
<booktitle>In Proc. ofACL</booktitle>
<contexts>
<context citStr="Galley and Manning, 2009" endWordPosition="465" position="3244" startWordPosition="462">-based approaches often suffer from the rule coverage problem since syntactic constraints rule out a large portion of nonsyntactic phrase pairs, which might help decoders generalize well to unseen data (Marcu et al., 2006). Furthermore, the introduction of nonterminals makes the grammar size significantly bigger than phrase tables and leads to higher memory requirement (Chiang, 2007). As a result, incremental decoding with hierarchical structures has attracted increasing attention in recent years. While some authors try to integrate syntax into phrase-based decoding (Galley and Manning, 2008; Galley and Manning, 2009; Feng et al., 2010), others develop incremental algorithms for syntax-based models (Watanabe et al., 2006; Huang and Mi, 2010; Dyer and Resnik, 2010; Feng et al., 2012). Despite these successful efforts, challenges still remain for both directions. While parsing algorithms can be used to parse partial translations in phrase-based decoding, the search space is significantly enlarged since there are exponentially many parse trees for exponentially many translations. On the other hand, although target words can be generated left-to-right by altering the way of tree transversal in syntaxbased mod</context>
<context citStr="Galley and Manning, 2009" endWordPosition="942" position="6356" startWordPosition="939">ranslation grows left-to-right in our algorithm, integrating n-gram language models is straightforward. 4. exploiting syntactic information: as the shift-reduce parsing algorithm generates target language dependency trees in decoding, dependency language models (Shen et al., 2008; Shen et al., 2010) can be used to encourage linguistically-motivated reordering. 5. resolving local parsing ambiguity: as dependency trees for phrases are memorized in rules, our approach avoids resolving local parsing ambiguity and explores in a smaller search space than parsing word-by-word on the fly in decoding (Galley and Manning, 2009). We evaluate our method on the NIST ChineseEnglish translation datasets. Experiments show that our approach significantly outperforms both phrase-based (Koehn et al., 2007) and string-todependency approaches (Shen et al., 2008) in terms of BLEU and TER. 2 Shift-Reduce Parsing for Phrase-based String-to-Dependency Translation Figure 1 shows a training example consisting of a (romanized) Chinese sentence, an English dependency tree, and the word alignment between them. Following Shen et al. (2008), string-todependency rules without non-terminals can be extracted from the training example. As sh</context>
<context citStr="Galley and Manning (2009)" endWordPosition="4171" position="25330" startWordPosition="4168">ents, both separately and jointly. We analyzed translation rules extracted from the training data. Among them, well-formed structures account for 43.58% (fixed 33.21%, floating left 9.01%, and floating right 1.36%) and illformed structures 56.42%. As shown in Table 4, using all rules clearly outperforms using only well-formed structures. Figure 5 shows the performance of Moses and our system with various distortion limits on the development set. Our system consistently outperforms Moses in all cases, suggesting that adding dependency helps improve phrase reordering. 6 Related Work The work of Galley and Manning (2009) is closest in spirit to ours. They introduce maximum spanning tree (MST) parsing (McDonald et al., 2005) into phrase-based translation. The system is phrase-based except that an MST parser runs to parse partial translations at the same time. One challenge is that MST parsing itself is not incremental, making it expensive to identify loops during hypothesis expansion. On the contrary, shiftreduce parsing is naturally incremental and can be seamlessly integrated into left-to-right phrasebased decoding. More importantly, in our work dependency trees are memorized for phrases rather than being ge</context>
</contexts>
<marker>Galley, Manning, 2009</marker>
<rawString>Michel Galley and Christopher D. Manning. 2009. Quadratic-time dependency parsing for machine translation. In Proc. ofACL 2009.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Michel Galley</author>
<author>Jonathan Graehl</author>
<author>Kevin Knight</author>
<author>Daniel Marcu</author>
<author>Steve DeNeefe</author>
<author>Wei Wang</author>
<author>Ignacio Thayer</author>
</authors>
<title>Scalable inference and training of context-rich syntactic translation models.</title>
<date>2006</date>
<booktitle>In Proc. ofACL</booktitle>
<contexts>
<context citStr="Galley et al., 2006" endWordPosition="280" position="2009" startWordPosition="277"> straightforward to integrate n-gram language models into phrase-based decoders in which translation always grows left-to-right. As a result, phrase-based decoders only need to maintain the boundary words on one end to calculate language model probabilities. However, as phrase-based decoding usually casts translation as a string concatenation problem and permits arbitrary permutation, it proves to be NP-complete (Knight, 1999). Syntax-based approaches, on the other hand, model the hierarchical structure of natural languages (Wu, 1997; Yamada and Knight, 2001; Chiang, 2005; Quirk et al., 2005; Galley et al., 2006; Liu et al., 2006; Huang et al., 2006; Shen et al., 2008; Mi and Huang, 2008; Zhang et al., 2008). As syntactic information can be exploited to provide linguistically-motivated reordering rules, predicting non-local permutation is computationally tractable in syntax-based approaches. Unfortunately, as syntax-based decoders often generate target-language words in a bottom-up way using the CKY algorithm, integrating n-gram language models becomes more expensive because they have to maintain target boundary words at both ends of a partial translation (Chiang, 2007; Huang and Chiang, 2007). Moreo</context>
</contexts>
<marker>Galley, Graehl, Knight, Marcu, DeNeefe, Wang, Thayer, 2006</marker>
<rawString>Michel Galley, Jonathan Graehl, Kevin Knight, Daniel Marcu, Steve DeNeefe, Wei Wang, and Ignacio Thayer. 2006. Scalable inference and training of context-rich syntactic translation models. In Proc. ofACL 2006.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Kevin Gimpel</author>
<author>Noah A Smith</author>
</authors>
<title>Quasisynchronous phrase dependency grammars for machine translation.</title>
<date>2011</date>
<booktitle>In Proc. of EMNLP</booktitle>
<contexts>
<context citStr="Gimpel and Smith (2011)" endWordPosition="4298" position="26146" startWordPosition="4295">s to parse partial translations at the same time. One challenge is that MST parsing itself is not incremental, making it expensive to identify loops during hypothesis expansion. On the contrary, shiftreduce parsing is naturally incremental and can be seamlessly integrated into left-to-right phrasebased decoding. More importantly, in our work dependency trees are memorized for phrases rather than being generated word by word on the fly in decoding. This treatment might not only reduce decoding complexity but also potentially revolve local parsing ambiguity. Our decoding algorithm is similar to Gimpel and Smith (2011)’s lattice parsing algorithm as we divide decoding into two steps: hypergraph generation and hypergraph rescoring. The major difference is that our hypergraph is not a phrasal lattice because each phrase pair is associated with a dependency structure on the target side. In other words, our second pass is to find the Viterbi derivation with addition features rather than parsing the phrasal lattice. In addition, their algorithm produces phrasal dependency parse trees while the leaves of our dependency trees are words, making dependency language models can be directly used. Shift-reduce parsing h</context>
</contexts>
<marker>Gimpel, Smith, 2011</marker>
<rawString>Kevin Gimpel and Noah A. Smith. 2011. Quasisynchronous phrase dependency grammars for machine translation. In Proc. of EMNLP 2011.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Liang Huang</author>
<author>David Chiang</author>
</authors>
<title>Forest rescoring: Faster decoding with integrated language models.</title>
<date>2007</date>
<booktitle>In Proc. of ACL</booktitle>
<contexts>
<context citStr="Huang and Chiang, 2007" endWordPosition="369" position="2602" startWordPosition="366">al., 2005; Galley et al., 2006; Liu et al., 2006; Huang et al., 2006; Shen et al., 2008; Mi and Huang, 2008; Zhang et al., 2008). As syntactic information can be exploited to provide linguistically-motivated reordering rules, predicting non-local permutation is computationally tractable in syntax-based approaches. Unfortunately, as syntax-based decoders often generate target-language words in a bottom-up way using the CKY algorithm, integrating n-gram language models becomes more expensive because they have to maintain target boundary words at both ends of a partial translation (Chiang, 2007; Huang and Chiang, 2007). Moreover, syntax-based approaches often suffer from the rule coverage problem since syntactic constraints rule out a large portion of nonsyntactic phrase pairs, which might help decoders generalize well to unseen data (Marcu et al., 2006). Furthermore, the introduction of nonterminals makes the grammar size significantly bigger than phrase tables and leads to higher memory requirement (Chiang, 2007). As a result, incremental decoding with hierarchical structures has attracted increasing attention in recent years. While some authors try to integrate syntax into phrase-based decoding (Galley a</context>
<context citStr="Huang and Chiang, 2007" endWordPosition="3048" position="18122" startWordPosition="3045">at has a score worse than: 1. β multiplied with the best score in the stack, or 2. the score of b-th best state in the stack. As the stack of a state keeps changing during the decoding process, the context information needed to calculate dependency language model and maximum entropy model probabilities (e.g., root word, leftmost child, etc.) changes dynamically as well. As a result, the chance of risk-free hypothesis recombination (Koehn et al., 2003) significantly decreases because complicated contextual information is much less likely to be identical. Therefore, we use hypergraph reranking (Huang and Chiang, 2007; Huang, 2008), which proves to be effective for integrating non-local features into dynamic programming, to alleviate this problem. The decoding process is divided into two passes. In the first pass, only standard features (i.e., features 1-7 in the list in the beginning of this section) are used to produce a hypergraph. 3 In the second pass, we use the hypergraph reranking algorithm (Huang, 2008) to find promising translations using additional dependency features (i.e., features 8-10 in the list). As hypergraph is capable of storing exponentially many derivations compactly, the negative effe</context>
</contexts>
<marker>Huang, Chiang, 2007</marker>
<rawString>Liang Huang and David Chiang. 2007. Forest rescoring: Faster decoding with integrated language models. In Proc. of ACL 2007.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Liang Huang</author>
<author>Haitao Mi</author>
</authors>
<title>Efficient incremental decoding for tree-to-string translation.</title>
<date>2010</date>
<booktitle>In Proc. of EMNLP</booktitle>
<contexts>
<context citStr="Huang and Mi, 2010" endWordPosition="485" position="3370" startWordPosition="482">hrase pairs, which might help decoders generalize well to unseen data (Marcu et al., 2006). Furthermore, the introduction of nonterminals makes the grammar size significantly bigger than phrase tables and leads to higher memory requirement (Chiang, 2007). As a result, incremental decoding with hierarchical structures has attracted increasing attention in recent years. While some authors try to integrate syntax into phrase-based decoding (Galley and Manning, 2008; Galley and Manning, 2009; Feng et al., 2010), others develop incremental algorithms for syntax-based models (Watanabe et al., 2006; Huang and Mi, 2010; Dyer and Resnik, 2010; Feng et al., 2012). Despite these successful efforts, challenges still remain for both directions. While parsing algorithms can be used to parse partial translations in phrase-based decoding, the search space is significantly enlarged since there are exponentially many parse trees for exponentially many translations. On the other hand, although target words can be generated left-to-right by altering the way of tree transversal in syntaxbased models, it is still difficult to reach full rule coverage as compared with phrase table. 1 Proceedings of the 51st Annual Meeting</context>
<context citStr="Huang and Mi, 2010" endWordPosition="4479" position="27328" startWordPosition="4476">irectly used. Shift-reduce parsing has been successfully used in phrase-based decoding but limited to adding structural constraints. Galley and Manning (2008) propose a shift-reduce algorithm to integrate a hierarchical reordering model into phrase-based systems. Feng et al. (2010) use shift-reduce parsing to impose ITG (Wu, 1997) constraints on phrase permutation. Our work differs from theirs by going further to incorporate linguistic syntax into phrase-based decoding. Along another line, a number of authors have developed incremental algorithms for syntaxbased models (Watanabe et al., 2006; Huang and Mi, 2010; Dyer and Resnik, 2010; Feng et al., 2012). Watanabe et al. (2006) introduce an Earlystyle top-down parser based on binary-branching Greibach Normal Form. Huang et al. (2010), Dyer 34.50 34.00 33.50 33.00 32.50 32.00 31.50 31.00 30.50 this work Moses 8 and Resnik (2010), and Feng et al. (2012) use dotted rules to change the tree transversal to generate target words left-to-right, either top-down or bottom-up. 7 Conclusion We have presented a shift-reduce parsing algorithm for phrase-based string-to-dependency translation. The algorithm generates dependency structures incrementally using strin</context>
</contexts>
<marker>Huang, Mi, 2010</marker>
<rawString>Liang Huang and Haitao Mi. 2010. Efficient incremental decoding for tree-to-string translation. In Proc. of EMNLP 2010.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Liang Huang</author>
<author>Kenji Sagae</author>
</authors>
<title>Dynamic programming for linear-time incremental parsing.</title>
<date>2010</date>
<booktitle>In Proc. of ACL</booktitle>
<marker>Huang, Sagae, 2010</marker>
<rawString>Liang Huang and Kenji Sagae. 2010. Dynamic programming for linear-time incremental parsing. In Proc. of ACL 2010.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Liang Huang</author>
<author>Kevin Knight</author>
<author>Aravind Joshi</author>
</authors>
<title>Statistical syntax-directed translation with extended domain of locality.</title>
<date>2006</date>
<booktitle>In Proc. of AMTA</booktitle>
<contexts>
<context citStr="Huang et al., 2006" endWordPosition="288" position="2047" startWordPosition="285">nguage models into phrase-based decoders in which translation always grows left-to-right. As a result, phrase-based decoders only need to maintain the boundary words on one end to calculate language model probabilities. However, as phrase-based decoding usually casts translation as a string concatenation problem and permits arbitrary permutation, it proves to be NP-complete (Knight, 1999). Syntax-based approaches, on the other hand, model the hierarchical structure of natural languages (Wu, 1997; Yamada and Knight, 2001; Chiang, 2005; Quirk et al., 2005; Galley et al., 2006; Liu et al., 2006; Huang et al., 2006; Shen et al., 2008; Mi and Huang, 2008; Zhang et al., 2008). As syntactic information can be exploited to provide linguistically-motivated reordering rules, predicting non-local permutation is computationally tractable in syntax-based approaches. Unfortunately, as syntax-based decoders often generate target-language words in a bottom-up way using the CKY algorithm, integrating n-gram language models becomes more expensive because they have to maintain target boundary words at both ends of a partial translation (Chiang, 2007; Huang and Chiang, 2007). Moreover, syntax-based approaches often suf</context>
</contexts>
<marker>Huang, Knight, Joshi, 2006</marker>
<rawString>Liang Huang, Kevin Knight, and Aravind Joshi. 2006. Statistical syntax-directed translation with extended domain of locality. In Proc. of AMTA 2006.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Liang Huang</author>
<author>Wenbin Jiang</author>
<author>Qun Liu</author>
</authors>
<title>Bilingually-constrained (monolingual) shift-reduce parsing.</title>
<date>2009</date>
<booktitle>In Proc. of EMNLP</booktitle>
<contexts>
<context citStr="Huang et al., 2009" endWordPosition="1372" position="8845" startWordPosition="1369">s the left dependant of its head “visit”, it is a left floating structure. To integrate the advantages of phrase-based and string-to-dependency models, we propose a shift-reduce algorithm for phrase-based string-todependency translation. Figure 2 shows an example. We describe a state (i.e., parser configuration) as a tuple (S, C) where S is a stack that stores items and C is a coverage vector that indicates which source words have been translated. Each item s E S is a well-formed dependency structure. The algorithm starts with an empty state. At each step, it chooses one of the three actions (Huang et al., 2009) to extend a state: 1. shift (S): move a target dependency structure onto the stack; 2. reduce left (Rl): combine the two items on the stack, st and st−1 (t &gt; 2), with the root of st as the head and replace them with a combined item; 3. reduce right (Rr): combine the two items on the stack, st and st−1 (t &gt; 2), with the root of st−1 as the head and replace them with a combined item. The decoding process terminates when all source words are covered and there is a complete dependency tree in the stack. Note that unlike monolingual shift-reduce parsers (Nivre, 2004; Zhang and Clark, 2008; Huang e</context>
<context citStr="Huang et al., 2009" endWordPosition="1894" position="11666" startWordPosition="1891">y structures present in the stacks, it is possible to use dependency language models to encourage linguistically plausible phrase reordering. 3 A Maximum Entropy Based Shift-Reduce Parsing Model Shift-reduce parsing is efficient but suffers from parsing errors caused by syntactic ambiguity. Figure 3 shows two (partial) derivations for a dependency tree. Consider the item on the top, the algorithm can either apply a shift action to move a new item or apply a reduce left action to obtain a bigger structure. This is often referred to as conflict in the shift-reduce dependency parsing literature (Huang et al., 2009). In this work, the shift-reduce parser faces four types of conflicts: 1. shift vs. shift; 2. shift vs. reduce left; 3. shift vs. reduce right; 4. reduce left vs. reduce right. Fortunately, if we distinguish between left and right floating structures, it is possible to rule out most conflicts. Table 1 shows the relationship between conflicts, dependency structures and actions. We use st and st−1 to denote the top two 4 [The President will visit London][in April] DT NNP MD VB NNP IN IN type feature templates Unigram c Wh(St) Wh(St−1) Wlc(St) Wrc(St−1) Th(St) Th(St−1) Tlc(St) Trc(St−1) Bigram Wh</context>
<context citStr="Huang et al., 2009" endWordPosition="2490" position="14945" startWordPosition="2487">) and Tl,(·) returns the word and tag of the left most child of the root, Wr,(·) 2The shift-shift conflicts always exist because there are usually multiple rules that can be shifted. This can be revolved using standard features in phrase-based models. word and tag of the right most child of the root. In this example, c = true, Wh(st) = in, Th(st) = IN, Wh(st−1) = visit, Wl,(st−1) = London. To train the model, we need an “oracle” or goldstandard action sequence for each training example. Unfortunately, such oracle turns out to be non-unique even for monolingual shift-reduce dependency parsing (Huang et al., 2009). The situation for phrase-based shift-reduce parsing aggravates because there are usually multiple ways of segmenting sentence into phrases. To alleviate this problem, we introduce a structure called derivation graph to compactly represent all derivations of a training example. Figure 3 shows a (partial) derivation graph, in which a node corresponds to a state and an edge corresponds to an action. The graph begins with an empty state and ends with the given training example. More formally, a derivation graph is a directed acyclic graph G = (V, E) where V is a set of nodes and E is a set of ed</context>
<context citStr="Huang et al. (2009)" endWordPosition="2786" position="16530" startWordPosition="2783">ocessed state until reaches the completed state. During the process, states that violate the training example are discarded. Even so, there are still exponentially many states for a training example, especially for long sentences. Fortunately, we and Tr,(·) returns the 5 Algorithm 1 Beam-search shift-reduce parsing. 1: procedure PARSE(f) 2: V ← 0 3: ADD(vo, V[0]) 4: k ← 0 5: while V[k] =� 0 do 6: for all v E V[k] do 7: for all a E {S, Rl, Rr} do 8: EXTEND(f, v, a, V) 9: end for 10: end for 11: k ← k + 1 12: end while 13: end procedure only need to focus on “h+h” states. In addition, we follow Huang et al. (2009) to use the heuristic of “shortest stack” to always prefer Rl to S. 4 Decoding Our decoder is based on a linear model (Och, 2003) with the following features: 1. relative frequencies in two directions; 2. lexical weights in two directions; 3. phrase penalty; 4. distance-based reordering model; 5. lexicaized reordering model; 6. n-gram language model model; 7. word penalty; 8. ill-formed structure penalty; 9. dependency language model; 10. maximum entropy parsing model. In practice, we extend deterministic shiftreduce parsing with beam search (Zhang and Clark, 2008; Huang et al., 2009). As show</context>
</contexts>
<marker>Huang, Jiang, Liu, 2009</marker>
<rawString>Liang Huang, Wenbin Jiang, and Qun Liu. 2009. Bilingually-constrained (monolingual) shift-reduce parsing. In Proc. of EMNLP 2009.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Liang Huang</author>
</authors>
<title>Forest reranking: Discriminative parsing with non-local features.</title>
<date>2008</date>
<booktitle>In Proc. ofACL</booktitle>
<contexts>
<context citStr="Huang, 2008" endWordPosition="296" position="2086" startWordPosition="295">ich translation always grows left-to-right. As a result, phrase-based decoders only need to maintain the boundary words on one end to calculate language model probabilities. However, as phrase-based decoding usually casts translation as a string concatenation problem and permits arbitrary permutation, it proves to be NP-complete (Knight, 1999). Syntax-based approaches, on the other hand, model the hierarchical structure of natural languages (Wu, 1997; Yamada and Knight, 2001; Chiang, 2005; Quirk et al., 2005; Galley et al., 2006; Liu et al., 2006; Huang et al., 2006; Shen et al., 2008; Mi and Huang, 2008; Zhang et al., 2008). As syntactic information can be exploited to provide linguistically-motivated reordering rules, predicting non-local permutation is computationally tractable in syntax-based approaches. Unfortunately, as syntax-based decoders often generate target-language words in a bottom-up way using the CKY algorithm, integrating n-gram language models becomes more expensive because they have to maintain target boundary words at both ends of a partial translation (Chiang, 2007; Huang and Chiang, 2007). Moreover, syntax-based approaches often suffer from the rule coverage problem sinc</context>
<context citStr="Huang, 2008" endWordPosition="3050" position="18136" startWordPosition="3049">n: 1. β multiplied with the best score in the stack, or 2. the score of b-th best state in the stack. As the stack of a state keeps changing during the decoding process, the context information needed to calculate dependency language model and maximum entropy model probabilities (e.g., root word, leftmost child, etc.) changes dynamically as well. As a result, the chance of risk-free hypothesis recombination (Koehn et al., 2003) significantly decreases because complicated contextual information is much less likely to be identical. Therefore, we use hypergraph reranking (Huang and Chiang, 2007; Huang, 2008), which proves to be effective for integrating non-local features into dynamic programming, to alleviate this problem. The decoding process is divided into two passes. In the first pass, only standard features (i.e., features 1-7 in the list in the beginning of this section) are used to produce a hypergraph. 3 In the second pass, we use the hypergraph reranking algorithm (Huang, 2008) to find promising translations using additional dependency features (i.e., features 8-10 in the list). As hypergraph is capable of storing exponentially many derivations compactly, the negative effect of propagat</context>
</contexts>
<marker>Huang, 2008</marker>
<rawString>Liang Huang. 2008. Forest reranking: Discriminative parsing with non-local features. In Proc. ofACL 2008.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Dan Klein</author>
<author>Christopher Manning</author>
</authors>
<title>Accurate unlexicalized parsing.</title>
<date>2003</date>
<booktitle>In Proc. ofACL</booktitle>
<contexts>
<context citStr="Klein and Manning, 2003" endWordPosition="3257" position="19459" startWordPosition="3254">we follow Shen et al. (2008) to use ill-formed structures in decoding. If an ill-formed structure has a single root, it can treated as a (pseudo) fixed structure; otherwise it is transformed to one (pseudo) left floating structure and one (pseudo) right floating structure. We use a feature to count how many ill-formed structures are used in decoding. 5 Experiments We evaluated our phrase-based string-todependency translation system on ChineseEnglish translation. The training data consists of 2.9M pairs of sentences with 76.0M Chinese words and 82.2M English words. We used the Stanford parser (Klein and Manning, 2003) to get dependency trees for English sentences. We used the SRILM toolkit (Stolcke, 2002) to train a 3Note that the first pass does not work like a phrase-based decoder because it yields dependency trees on the target side. A uniform model (i.e., each action has a fixed probability of 1/3) is used to resolve “h+h” conflicts. 6 system MT02 (tune) MT03 MT04 MT05 BLEU TER BLEU TER BLEU TER BLEU TER phrase 34.88 57.00 33.82 57.19 35.48 56.48 32.52 57.62 dependency 35.23 56.12 34.20 56.36 36.01 55.55 33.06 56.94 this work 35.71** 55.87** 34.81**+ 55.94**+ 36.37** 55.02**+ 33.53** 56.58** Table 2: C</context>
</contexts>
<marker>Klein, Manning, 2003</marker>
<rawString>Dan Klein and Christopher Manning. 2003. Accurate unlexicalized parsing. In Proc. ofACL 2003.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Kevin Knight</author>
</authors>
<title>Decoding complexity in wordreplacement translation models. Computational Linguistics.</title>
<date>1999</date>
<contexts>
<context citStr="Knight, 1999" endWordPosition="250" position="1820" startWordPosition="249">et al., 2003; Och and Ney, 2004). As phrases are capable of memorizing local context, phrase-based approaches excel at handling local word selection and reordering. In addition, it is straightforward to integrate n-gram language models into phrase-based decoders in which translation always grows left-to-right. As a result, phrase-based decoders only need to maintain the boundary words on one end to calculate language model probabilities. However, as phrase-based decoding usually casts translation as a string concatenation problem and permits arbitrary permutation, it proves to be NP-complete (Knight, 1999). Syntax-based approaches, on the other hand, model the hierarchical structure of natural languages (Wu, 1997; Yamada and Knight, 2001; Chiang, 2005; Quirk et al., 2005; Galley et al., 2006; Liu et al., 2006; Huang et al., 2006; Shen et al., 2008; Mi and Huang, 2008; Zhang et al., 2008). As syntactic information can be exploited to provide linguistically-motivated reordering rules, predicting non-local permutation is computationally tractable in syntax-based approaches. Unfortunately, as syntax-based decoders often generate target-language words in a bottom-up way using the CKY algorithm, inte</context>
</contexts>
<marker>Knight, 1999</marker>
<rawString>Kevin Knight. 1999. Decoding complexity in wordreplacement translation models. Computational Linguistics.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Philipp Koehn</author>
<author>Franz Och</author>
<author>Daniel Marcu</author>
</authors>
<title>Statistical phrase-based translation.</title>
<date>2003</date>
<booktitle>In Proc. of NAACL</booktitle>
<contexts>
<context citStr="Koehn et al., 2003" endWordPosition="161" position="1219" startWordPosition="158">y language models. To resolve conflicts in shift-reduce parsing, we propose a maximum entropy model trained on the derivation graph of training data. As our approach combines the merits of phrase-based and string-todependency models, it achieves significant improvements over the two baselines on the NIST Chinese-English datasets. 1 Introduction Modern statistical machine translation approaches can be roughly divided into two broad categories: phrase-based and syntax-based. Phrase-based approaches treat phrase, which is usually a sequence of consecutive words, as the basic unit of translation (Koehn et al., 2003; Och and Ney, 2004). As phrases are capable of memorizing local context, phrase-based approaches excel at handling local word selection and reordering. In addition, it is straightforward to integrate n-gram language models into phrase-based decoders in which translation always grows left-to-right. As a result, phrase-based decoders only need to maintain the boundary words on one end to calculate language model probabilities. However, as phrase-based decoding usually casts translation as a string concatenation problem and permits arbitrary permutation, it proves to be NP-complete (Knight, 1999</context>
<context citStr="Koehn et al., 2003" endWordPosition="3024" position="17955" startWordPosition="3021">Then, the states in the stack are iteratively extended until there are no incomplete states (lines 4-12). The search space is constrained by discarding any state that has a score worse than: 1. β multiplied with the best score in the stack, or 2. the score of b-th best state in the stack. As the stack of a state keeps changing during the decoding process, the context information needed to calculate dependency language model and maximum entropy model probabilities (e.g., root word, leftmost child, etc.) changes dynamically as well. As a result, the chance of risk-free hypothesis recombination (Koehn et al., 2003) significantly decreases because complicated contextual information is much less likely to be identical. Therefore, we use hypergraph reranking (Huang and Chiang, 2007; Huang, 2008), which proves to be effective for integrating non-local features into dynamic programming, to alleviate this problem. The decoding process is divided into two passes. In the first pass, only standard features (i.e., features 1-7 in the list in the beginning of this section) are used to produce a hypergraph. 3 In the second pass, we use the hypergraph reranking algorithm (Huang, 2008) to find promising translations </context>
</contexts>
<marker>Koehn, Och, Marcu, 2003</marker>
<rawString>Philipp Koehn, Franz Och, and Daniel Marcu. 2003. Statistical phrase-based translation. In Proc. of NAACL 2003.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Philipp Koehn</author>
<author>Hieu Hoang</author>
<author>Alexandra Birch</author>
<author>Chris Callison-Burch</author>
<author>Marcello Federico</author>
<author>Nicola Bertoldi</author>
<author>Brooke Cowan</author>
<author>Wade Shen</author>
</authors>
<title>Moses: Open source toolkit for statistical machine translation.</title>
<date>2007</date>
<booktitle>In Proc. of ACL</booktitle>
<location>Christine Moran, Richard Zens, Chris Dyer, Ondrej Bojar, Alexandra</location>
<contexts>
<context citStr="Koehn et al., 2007" endWordPosition="845" position="5674" startWordPosition="842">a dependency structure on the target side. The algorithm generates well-formed dependency structures for partial translations left-to-right using string-todependency phrase pairs. Therefore, our approach is capable of combining the advantages of both phrase-based and syntax-based approaches: 1. compact rule table: our rule table is a subset of the original string-to-dependency grammar (Shen et al., 2008; Shen et al., 2010) by excluding rules with non-terminals. 2. full rule coverage: all phrase pairs, both syntactic and non-syntactic, can be used in our algorithm. This is the same with Moses (Koehn et al., 2007). 3. efficient integration of n-gram language model: as translation grows left-to-right in our algorithm, integrating n-gram language models is straightforward. 4. exploiting syntactic information: as the shift-reduce parsing algorithm generates target language dependency trees in decoding, dependency language models (Shen et al., 2008; Shen et al., 2010) can be used to encourage linguistically-motivated reordering. 5. resolving local parsing ambiguity: as dependency trees for phrases are memorized in rules, our approach avoids resolving local parsing ambiguity and explores in a smaller search</context>
<context citStr="Koehn et al., 2007" endWordPosition="3365" position="20100" startWordPosition="3362">es for English sentences. We used the SRILM toolkit (Stolcke, 2002) to train a 3Note that the first pass does not work like a phrase-based decoder because it yields dependency trees on the target side. A uniform model (i.e., each action has a fixed probability of 1/3) is used to resolve “h+h” conflicts. 6 system MT02 (tune) MT03 MT04 MT05 BLEU TER BLEU TER BLEU TER BLEU TER phrase 34.88 57.00 33.82 57.19 35.48 56.48 32.52 57.62 dependency 35.23 56.12 34.20 56.36 36.01 55.55 33.06 56.94 this work 35.71** 55.87** 34.81**+ 55.94**+ 36.37** 55.02**+ 33.53** 56.58** Table 2: Comparison with Moses (Koehn et al., 2007) and a re-implementation of the bottom-up stringto-dependency decoder (Shen et al., 2008) in terms of uncased BLEU and TER. We use randomization test (Riezler and Maxwell, 2005) to calculate statistical significance. *: significantly better than Moses (p &lt; 0.05), **: significantly better than Moses (p &lt; 0.01), +: significantly better than string-todependency (p &lt; 0.05), ++: significantly better than string-to-dependency (p &lt; 0.01). features BLEU TER standard 34.79 56.93 + depLM 35.29* 56.17** + maxent 35.40** 56.09** + depLM &amp; maxent 35.71** 55.87** Table 3: Contribution of maximum entropy shi</context>
<context citStr="Koehn et al., 2007" endWordPosition="3602" position="21637" startWordPosition="3599">ua portion of the GIGAWORD coprus, which contians 238M English words. A 3-gram dependency language model was trained on the English dependency trees. We used the 2002 NIST MT ChineseEnglish dataset as the development set and the 2003-2005 NIST datasets as the testsets. We evaluated translation quality using uncased BLEU (Papineni et al., 2002) and TER (Snover et al., 2006). The features were optimized with respect to BLEU using the minimum error rate training algorithm (Och, 2003). We chose the following two systems that are closest to our work as baselines: 1. The Moses phrase-based decoder (Koehn et al., 2007). 2. A re-implementation of bottom-up string-todependency decoder (Shen et al., 2008). All the three systems share with the same targetside parsed, word-aligned training data. The histogram pruning parameter b is set to 100 and rules coverage BLEU TER well-formed 44.87 34.42 57.35 all 100.00 35.71** 55.87** Table 4: Comparison of well-formed and illformed structures. Using all rules significantly outperforms using only well-formed structures. BLEU and TER scores are calculated on the development set. phrase table limit is set to 20 for all the three systems. Moses shares the same feature set w</context>
</contexts>
<marker>Koehn, Hoang, Birch, Callison-Burch, Federico, Bertoldi, Cowan, Shen, 2007</marker>
<rawString>Philipp Koehn, Hieu Hoang, Alexandra Birch, Chris Callison-Burch, Marcello Federico, Nicola Bertoldi, Brooke Cowan, Wade Shen, Christine Moran, Richard Zens, Chris Dyer, Ondrej Bojar, Alexandra Constantin, and Evan Herbst. 2007. Moses: Open source toolkit for statistical machine translation. In Proc. of ACL 2007.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Daniel Marcu</author>
<author>Wei Wang</author>
<author>Abdessamad Echihabi</author>
<author>Kevin Knight</author>
</authors>
<title>Spmt: Statistical machine translation with syntactified target language phrases.</title>
<date>2006</date>
<booktitle>In Proc. of EMNLP</booktitle>
<contexts>
<context citStr="Marcu et al., 2006" endWordPosition="406" position="2842" startWordPosition="403">al permutation is computationally tractable in syntax-based approaches. Unfortunately, as syntax-based decoders often generate target-language words in a bottom-up way using the CKY algorithm, integrating n-gram language models becomes more expensive because they have to maintain target boundary words at both ends of a partial translation (Chiang, 2007; Huang and Chiang, 2007). Moreover, syntax-based approaches often suffer from the rule coverage problem since syntactic constraints rule out a large portion of nonsyntactic phrase pairs, which might help decoders generalize well to unseen data (Marcu et al., 2006). Furthermore, the introduction of nonterminals makes the grammar size significantly bigger than phrase tables and leads to higher memory requirement (Chiang, 2007). As a result, incremental decoding with hierarchical structures has attracted increasing attention in recent years. While some authors try to integrate syntax into phrase-based decoding (Galley and Manning, 2008; Galley and Manning, 2009; Feng et al., 2010), others develop incremental algorithms for syntax-based models (Watanabe et al., 2006; Huang and Mi, 2010; Dyer and Resnik, 2010; Feng et al., 2012). Despite these successful ef</context>
</contexts>
<marker>Marcu, Wang, Echihabi, Knight, 2006</marker>
<rawString>Daniel Marcu, Wei Wang, Abdessamad Echihabi, and Kevin Knight. 2006. Spmt: Statistical machine translation with syntactified target language phrases. In Proc. of EMNLP 2006.</rawString>
</citation>
<citation valid="true">
<authors>
<author>R McDonald</author>
<author>F Pereira</author>
<author>K Ribarov</author>
<author>J Hajic</author>
</authors>
<title>Non-projective dependency parsing using spanning tree algorithms.</title>
<date>2005</date>
<booktitle>In Proc. of EMNLP</booktitle>
<contexts>
<context citStr="McDonald et al., 2005" endWordPosition="4189" position="25435" startWordPosition="4186">m, well-formed structures account for 43.58% (fixed 33.21%, floating left 9.01%, and floating right 1.36%) and illformed structures 56.42%. As shown in Table 4, using all rules clearly outperforms using only well-formed structures. Figure 5 shows the performance of Moses and our system with various distortion limits on the development set. Our system consistently outperforms Moses in all cases, suggesting that adding dependency helps improve phrase reordering. 6 Related Work The work of Galley and Manning (2009) is closest in spirit to ours. They introduce maximum spanning tree (MST) parsing (McDonald et al., 2005) into phrase-based translation. The system is phrase-based except that an MST parser runs to parse partial translations at the same time. One challenge is that MST parsing itself is not incremental, making it expensive to identify loops during hypothesis expansion. On the contrary, shiftreduce parsing is naturally incremental and can be seamlessly integrated into left-to-right phrasebased decoding. More importantly, in our work dependency trees are memorized for phrases rather than being generated word by word on the fly in decoding. This treatment might not only reduce decoding complexity but</context>
</contexts>
<marker>McDonald, Pereira, Ribarov, Hajic, 2005</marker>
<rawString>R. McDonald, F. Pereira, K. Ribarov, and J. Hajic. 2005. Non-projective dependency parsing using spanning tree algorithms. In Proc. of EMNLP 2005.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Haitao Mi</author>
<author>Liang Huang</author>
</authors>
<title>Forest-based translation.</title>
<date>2008</date>
<booktitle>In Proc. ofACL</booktitle>
<contexts>
<context citStr="Mi and Huang, 2008" endWordPosition="296" position="2086" startWordPosition="293">s in which translation always grows left-to-right. As a result, phrase-based decoders only need to maintain the boundary words on one end to calculate language model probabilities. However, as phrase-based decoding usually casts translation as a string concatenation problem and permits arbitrary permutation, it proves to be NP-complete (Knight, 1999). Syntax-based approaches, on the other hand, model the hierarchical structure of natural languages (Wu, 1997; Yamada and Knight, 2001; Chiang, 2005; Quirk et al., 2005; Galley et al., 2006; Liu et al., 2006; Huang et al., 2006; Shen et al., 2008; Mi and Huang, 2008; Zhang et al., 2008). As syntactic information can be exploited to provide linguistically-motivated reordering rules, predicting non-local permutation is computationally tractable in syntax-based approaches. Unfortunately, as syntax-based decoders often generate target-language words in a bottom-up way using the CKY algorithm, integrating n-gram language models becomes more expensive because they have to maintain target boundary words at both ends of a partial translation (Chiang, 2007; Huang and Chiang, 2007). Moreover, syntax-based approaches often suffer from the rule coverage problem sinc</context>
</contexts>
<marker>Mi, Huang, 2008</marker>
<rawString>Haitao Mi and Liang Huang. 2008. Forest-based translation. In Proc. ofACL 2008.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Joakim Nivre</author>
</authors>
<title>Incrementality in deterministic dependency parsing.</title>
<date>2004</date>
<booktitle>In Proc. of ACL 2004 Workshop Incremental Parsing: Bringning Engineering and Cognition Together.</booktitle>
<contexts>
<context citStr="Nivre, 2004" endWordPosition="1481" position="9413" startWordPosition="1480">e of the three actions (Huang et al., 2009) to extend a state: 1. shift (S): move a target dependency structure onto the stack; 2. reduce left (Rl): combine the two items on the stack, st and st−1 (t &gt; 2), with the root of st as the head and replace them with a combined item; 3. reduce right (Rr): combine the two items on the stack, st and st−1 (t &gt; 2), with the root of st−1 as the head and replace them with a combined item. The decoding process terminates when all source words are covered and there is a complete dependency tree in the stack. Note that unlike monolingual shift-reduce parsers (Nivre, 2004; Zhang and Clark, 2008; Huang et al., 2009), our algorithm does not maintain a queue for remaining words of the input because the future dependency structure to be shifted is unknown in advance in the translation scenario. Instead, we use a coverage vector on the source side to determine when to terminate the algorithm. For an input sentence of J words, the number of actions is 2K −1, where K is the number of rules used in decoding. 1 There are always K shifts and 1Empirically, we find that the average number of stacks for J words is about 1.5 × J on the Chinese-English data. 3 [The President</context>
</contexts>
<marker>Nivre, 2004</marker>
<rawString>Joakim Nivre. 2004. Incrementality in deterministic dependency parsing. In Proc. of ACL 2004 Workshop Incremental Parsing: Bringning Engineering and Cognition Together.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Franz Och</author>
<author>Hermann Ney</author>
</authors>
<title>The alignment template approach to statistical machine translation.</title>
<date>2004</date>
<journal>Computational Linguistics,</journal>
<volume>30</volume>
<issue>4</issue>
<contexts>
<context citStr="Och and Ney, 2004" endWordPosition="165" position="1239" startWordPosition="162">o resolve conflicts in shift-reduce parsing, we propose a maximum entropy model trained on the derivation graph of training data. As our approach combines the merits of phrase-based and string-todependency models, it achieves significant improvements over the two baselines on the NIST Chinese-English datasets. 1 Introduction Modern statistical machine translation approaches can be roughly divided into two broad categories: phrase-based and syntax-based. Phrase-based approaches treat phrase, which is usually a sequence of consecutive words, as the basic unit of translation (Koehn et al., 2003; Och and Ney, 2004). As phrases are capable of memorizing local context, phrase-based approaches excel at handling local word selection and reordering. In addition, it is straightforward to integrate n-gram language models into phrase-based decoders in which translation always grows left-to-right. As a result, phrase-based decoders only need to maintain the boundary words on one end to calculate language model probabilities. However, as phrase-based decoding usually casts translation as a string concatenation problem and permits arbitrary permutation, it proves to be NP-complete (Knight, 1999). Syntax-based appr</context>
</contexts>
<marker>Och, Ney, 2004</marker>
<rawString>Franz Och and Hermann Ney. 2004. The alignment template approach to statistical machine translation. Computational Linguistics, 30(4).</rawString>
</citation>
<citation valid="true">
<authors>
<author>Franz Och</author>
</authors>
<title>Minimum error rate training in statistical machine translation.</title>
<date>2003</date>
<booktitle>In Proc. of ACL</booktitle>
<contexts>
<context citStr="Och, 2003" endWordPosition="2811" position="16659" startWordPosition="2810">e are still exponentially many states for a training example, especially for long sentences. Fortunately, we and Tr,(·) returns the 5 Algorithm 1 Beam-search shift-reduce parsing. 1: procedure PARSE(f) 2: V ← 0 3: ADD(vo, V[0]) 4: k ← 0 5: while V[k] =� 0 do 6: for all v E V[k] do 7: for all a E {S, Rl, Rr} do 8: EXTEND(f, v, a, V) 9: end for 10: end for 11: k ← k + 1 12: end while 13: end procedure only need to focus on “h+h” states. In addition, we follow Huang et al. (2009) to use the heuristic of “shortest stack” to always prefer Rl to S. 4 Decoding Our decoder is based on a linear model (Och, 2003) with the following features: 1. relative frequencies in two directions; 2. lexical weights in two directions; 3. phrase penalty; 4. distance-based reordering model; 5. lexicaized reordering model; 6. n-gram language model model; 7. word penalty; 8. ill-formed structure penalty; 9. dependency language model; 10. maximum entropy parsing model. In practice, we extend deterministic shiftreduce parsing with beam search (Zhang and Clark, 2008; Huang et al., 2009). As shown in Algorithm 1, the algorithm maintains a list of stacks V and each stack groups states with the same number of accumulated act</context>
<context citStr="Och, 2003" endWordPosition="3579" position="21503" startWordPosition="3578">”) significantly improves BLEU and TER on the development set, both separately and jointly. 4-gram language model on the Xinhua portion of the GIGAWORD coprus, which contians 238M English words. A 3-gram dependency language model was trained on the English dependency trees. We used the 2002 NIST MT ChineseEnglish dataset as the development set and the 2003-2005 NIST datasets as the testsets. We evaluated translation quality using uncased BLEU (Papineni et al., 2002) and TER (Snover et al., 2006). The features were optimized with respect to BLEU using the minimum error rate training algorithm (Och, 2003). We chose the following two systems that are closest to our work as baselines: 1. The Moses phrase-based decoder (Koehn et al., 2007). 2. A re-implementation of bottom-up string-todependency decoder (Shen et al., 2008). All the three systems share with the same targetside parsed, word-aligned training data. The histogram pruning parameter b is set to 100 and rules coverage BLEU TER well-formed 44.87 34.42 57.35 all 100.00 35.71** 55.87** Table 4: Comparison of well-formed and illformed structures. Using all rules significantly outperforms using only well-formed structures. BLEU and TER scores</context>
</contexts>
<marker>Och, 2003</marker>
<rawString>Franz Och. 2003. Minimum error rate training in statistical machine translation. In Proc. of ACL 2003.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Kishore Papineni</author>
<author>Salim Roukos</author>
<author>Todd Ward</author>
<author>WeiJing Zhu</author>
</authors>
<title>Bleu: a method for automatic evaluation of machine translation.</title>
<date>2002</date>
<booktitle>In Proc. ofACL</booktitle>
<contexts>
<context citStr="Papineni et al., 2002" endWordPosition="3556" position="21363" startWordPosition="3553">s using standard features of phrase-based system. Adding dependency language model (“depLM”) and the maximum entropy shift-reduce parsing model (“maxent”) significantly improves BLEU and TER on the development set, both separately and jointly. 4-gram language model on the Xinhua portion of the GIGAWORD coprus, which contians 238M English words. A 3-gram dependency language model was trained on the English dependency trees. We used the 2002 NIST MT ChineseEnglish dataset as the development set and the 2003-2005 NIST datasets as the testsets. We evaluated translation quality using uncased BLEU (Papineni et al., 2002) and TER (Snover et al., 2006). The features were optimized with respect to BLEU using the minimum error rate training algorithm (Och, 2003). We chose the following two systems that are closest to our work as baselines: 1. The Moses phrase-based decoder (Koehn et al., 2007). 2. A re-implementation of bottom-up string-todependency decoder (Shen et al., 2008). All the three systems share with the same targetside parsed, word-aligned training data. The histogram pruning parameter b is set to 100 and rules coverage BLEU TER well-formed 44.87 34.42 57.35 all 100.00 35.71** 55.87** Table 4: Comparis</context>
</contexts>
<marker>Papineni, Roukos, Ward, Zhu, 2002</marker>
<rawString>Kishore Papineni, Salim Roukos, Todd Ward, and WeiJing Zhu. 2002. Bleu: a method for automatic evaluation of machine translation. In Proc. ofACL 2002.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Chris Quirk</author>
<author>Arul Menezes</author>
<author>Colin Cherry</author>
</authors>
<title>Dependency treelet translation: Syntactically informed phrasal smt.</title>
<date>2005</date>
<booktitle>In Proc. ofACL</booktitle>
<contexts>
<context citStr="Quirk et al., 2005" endWordPosition="276" position="1988" startWordPosition="273">. In addition, it is straightforward to integrate n-gram language models into phrase-based decoders in which translation always grows left-to-right. As a result, phrase-based decoders only need to maintain the boundary words on one end to calculate language model probabilities. However, as phrase-based decoding usually casts translation as a string concatenation problem and permits arbitrary permutation, it proves to be NP-complete (Knight, 1999). Syntax-based approaches, on the other hand, model the hierarchical structure of natural languages (Wu, 1997; Yamada and Knight, 2001; Chiang, 2005; Quirk et al., 2005; Galley et al., 2006; Liu et al., 2006; Huang et al., 2006; Shen et al., 2008; Mi and Huang, 2008; Zhang et al., 2008). As syntactic information can be exploited to provide linguistically-motivated reordering rules, predicting non-local permutation is computationally tractable in syntax-based approaches. Unfortunately, as syntax-based decoders often generate target-language words in a bottom-up way using the CKY algorithm, integrating n-gram language models becomes more expensive because they have to maintain target boundary words at both ends of a partial translation (Chiang, 2007; Huang and</context>
</contexts>
<marker>Quirk, Menezes, Cherry, 2005</marker>
<rawString>Chris Quirk, Arul Menezes, and Colin Cherry. 2005. Dependency treelet translation: Syntactically informed phrasal smt. In Proc. ofACL 2005.</rawString>
</citation>
<citation valid="true">
<authors>
<author>S Riezler</author>
<author>J Maxwell</author>
</authors>
<title>On some pitfalls in automatic evaluation and significance testing for mt.</title>
<date>2005</date>
<booktitle>In Proc. ofACL 2005 Workshop on Intrinsic and Extrinsic Evaluation Measures for Machine Translation and/or Summarization.</booktitle>
<contexts>
<context citStr="Riezler and Maxwell, 2005" endWordPosition="3394" position="20277" startWordPosition="3391">dency trees on the target side. A uniform model (i.e., each action has a fixed probability of 1/3) is used to resolve “h+h” conflicts. 6 system MT02 (tune) MT03 MT04 MT05 BLEU TER BLEU TER BLEU TER BLEU TER phrase 34.88 57.00 33.82 57.19 35.48 56.48 32.52 57.62 dependency 35.23 56.12 34.20 56.36 36.01 55.55 33.06 56.94 this work 35.71** 55.87** 34.81**+ 55.94**+ 36.37** 55.02**+ 33.53** 56.58** Table 2: Comparison with Moses (Koehn et al., 2007) and a re-implementation of the bottom-up stringto-dependency decoder (Shen et al., 2008) in terms of uncased BLEU and TER. We use randomization test (Riezler and Maxwell, 2005) to calculate statistical significance. *: significantly better than Moses (p &lt; 0.05), **: significantly better than Moses (p &lt; 0.01), +: significantly better than string-todependency (p &lt; 0.05), ++: significantly better than string-to-dependency (p &lt; 0.01). features BLEU TER standard 34.79 56.93 + depLM 35.29* 56.17** + maxent 35.40** 56.09** + depLM &amp; maxent 35.71** 55.87** Table 3: Contribution of maximum entropy shiftreduce parsing model. “standard” denotes using standard features of phrase-based system. Adding dependency language model (“depLM”) and the maximum entropy shift-reduce parsin</context>
<context citStr="Riezler and Maxwell, 2005" endWordPosition="3863" position="23310" startWordPosition="3860">fter extracting 32.6M events from the training data. 4 We set the iteration limit to 100. The accuracy on the training data is 90.18%. Table 2 gives the performance of Moses, the bottom-up string-to-dependency system, and our system in terms of uncased BLEU and TER scores. From the same training data, Moses extracted 103M bilingual phrases, the bottomup string-to-dependency system extracted 587M string-to-dependency rules, and our system extracted 124M phrase-based dependency rules. We find that our approach outperforms both baselines systematically on all testsets. We use randomization test (Riezler and Maxwell, 2005) to calculate statistical significance. As our system can take full advantage of lexicalized reordering and depen4http://homepages.inf.ed.ac.uk/lzhang10/maxent.html 7 BLEU 0 2 4 6 8 10 12 distortion limit Figure 5: Performance of Moses and our system with various distortion limits. dency language models without loss in rule coverage, it achieves significantly better results than Moses on all test sets. The gains in TER are much larger than BLEU because dependency language models do not model n-grams directly. Compared with the bottom-up string-to-dependency system, our system outperforms consi</context>
</contexts>
<marker>Riezler, Maxwell, 2005</marker>
<rawString>S. Riezler and J. Maxwell. 2005. On some pitfalls in automatic evaluation and significance testing for mt. In Proc. ofACL 2005 Workshop on Intrinsic and Extrinsic Evaluation Measures for Machine Translation and/or Summarization.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Libin Shen</author>
<author>Jinxi Xu</author>
<author>Ralph Weischedel</author>
</authors>
<title>A new string-to-dependency machine translation algorithm with a target dependency language model.</title>
<date>2008</date>
<booktitle>In Proc. ofACL</booktitle>
<contexts>
<context citStr="Shen et al., 2008" endWordPosition="292" position="2066" startWordPosition="289">hrase-based decoders in which translation always grows left-to-right. As a result, phrase-based decoders only need to maintain the boundary words on one end to calculate language model probabilities. However, as phrase-based decoding usually casts translation as a string concatenation problem and permits arbitrary permutation, it proves to be NP-complete (Knight, 1999). Syntax-based approaches, on the other hand, model the hierarchical structure of natural languages (Wu, 1997; Yamada and Knight, 2001; Chiang, 2005; Quirk et al., 2005; Galley et al., 2006; Liu et al., 2006; Huang et al., 2006; Shen et al., 2008; Mi and Huang, 2008; Zhang et al., 2008). As syntactic information can be exploited to provide linguistically-motivated reordering rules, predicting non-local permutation is computationally tractable in syntax-based approaches. Unfortunately, as syntax-based decoders often generate target-language words in a bottom-up way using the CKY algorithm, integrating n-gram language models becomes more expensive because they have to maintain target boundary words at both ends of a partial translation (Chiang, 2007; Huang and Chiang, 2007). Moreover, syntax-based approaches often suffer from the rule c</context>
<context citStr="Shen et al. (2008)" endWordPosition="708" position="4746" startWordPosition="705">ng yu siyue lai lundun fangwen The President will visit London in April source phrase target phrase dependency category r1 fangwen visit {} fixed r2 yu siyue in April {1 → 2} fixed r3 zongtong jiang The President will {2 → 1} floating left r4 yu siyue lai lundun London in April {2 → 3} floating right r5 zongtong jiang President will {} ill-formed Figure 1: A training example consisting of a (romanized) Chinese sentence, an English dependency tree, and the word alignment between them. Each translation rule is composed of a source phrase, a target phrase with a set of dependency arcs. Following Shen et al. (2008), we distinguish between fixed, floating, and ill-formed structures. In this paper, we propose a shift-reduce parsing algorithm for phrase-based string-to-dependency translation. The basic unit of translation in our model is string-to-dependency phrase pair, which consists of a phrase on the source side and a dependency structure on the target side. The algorithm generates well-formed dependency structures for partial translations left-to-right using string-todependency phrase pairs. Therefore, our approach is capable of combining the advantages of both phrase-based and syntax-based approaches</context>
<context citStr="Shen et al., 2008" endWordPosition="889" position="6011" startWordPosition="886">set of the original string-to-dependency grammar (Shen et al., 2008; Shen et al., 2010) by excluding rules with non-terminals. 2. full rule coverage: all phrase pairs, both syntactic and non-syntactic, can be used in our algorithm. This is the same with Moses (Koehn et al., 2007). 3. efficient integration of n-gram language model: as translation grows left-to-right in our algorithm, integrating n-gram language models is straightforward. 4. exploiting syntactic information: as the shift-reduce parsing algorithm generates target language dependency trees in decoding, dependency language models (Shen et al., 2008; Shen et al., 2010) can be used to encourage linguistically-motivated reordering. 5. resolving local parsing ambiguity: as dependency trees for phrases are memorized in rules, our approach avoids resolving local parsing ambiguity and explores in a smaller search space than parsing word-by-word on the fly in decoding (Galley and Manning, 2009). We evaluate our method on the NIST ChineseEnglish translation datasets. Experiments show that our approach significantly outperforms both phrase-based (Koehn et al., 2007) and string-todependency approaches (Shen et al., 2008) in terms of BLEU and TER. </context>
<context citStr="Shen et al. (2008)" endWordPosition="1774" position="10924" startWordPosition="1771">in shift-reduce parsing. Rl Rr st−1 st legal action(s) yes S h yes S l yes S r no h h yes S, Rl, Rr h l yes S h r yes Rr l h yes Rl l l yes S l r no r h no r l no r r no Table 1: Conflicts in shift-reduce parsing. st and st−1 are the top two items in the stack of a state. We use “h” to denote fixed structure, “l” to denote left floating structure, and “r” to denote right floating structure. It is clear that only “h+h” is ambiguous. K − 1 reductions. It is easy to verify that the reduce left and reduce right actions are equivalent to the left adjoining and right adjoining operations defined by Shen et al. (2008). They suffice to operate on wellformed structures and produce projective dependency parse trees. Therefore, with dependency structures present in the stacks, it is possible to use dependency language models to encourage linguistically plausible phrase reordering. 3 A Maximum Entropy Based Shift-Reduce Parsing Model Shift-reduce parsing is efficient but suffers from parsing errors caused by syntactic ambiguity. Figure 3 shows two (partial) derivations for a dependency tree. Consider the item on the top, the algorithm can either apply a shift action to move a new item or apply a reduce left act</context>
<context citStr="Shen et al. (2008)" endWordPosition="3165" position="18863" startWordPosition="3162"> problem. The decoding process is divided into two passes. In the first pass, only standard features (i.e., features 1-7 in the list in the beginning of this section) are used to produce a hypergraph. 3 In the second pass, we use the hypergraph reranking algorithm (Huang, 2008) to find promising translations using additional dependency features (i.e., features 8-10 in the list). As hypergraph is capable of storing exponentially many derivations compactly, the negative effect of propagating mistakes made in the first pass to the second pass can be minimized. To improve rule coverage, we follow Shen et al. (2008) to use ill-formed structures in decoding. If an ill-formed structure has a single root, it can treated as a (pseudo) fixed structure; otherwise it is transformed to one (pseudo) left floating structure and one (pseudo) right floating structure. We use a feature to count how many ill-formed structures are used in decoding. 5 Experiments We evaluated our phrase-based string-todependency translation system on ChineseEnglish translation. The training data consists of 2.9M pairs of sentences with 76.0M Chinese words and 82.2M English words. We used the Stanford parser (Klein and Manning, 2003) to </context>
<context citStr="Shen et al., 2008" endWordPosition="3378" position="20189" startWordPosition="3375">the first pass does not work like a phrase-based decoder because it yields dependency trees on the target side. A uniform model (i.e., each action has a fixed probability of 1/3) is used to resolve “h+h” conflicts. 6 system MT02 (tune) MT03 MT04 MT05 BLEU TER BLEU TER BLEU TER BLEU TER phrase 34.88 57.00 33.82 57.19 35.48 56.48 32.52 57.62 dependency 35.23 56.12 34.20 56.36 36.01 55.55 33.06 56.94 this work 35.71** 55.87** 34.81**+ 55.94**+ 36.37** 55.02**+ 33.53** 56.58** Table 2: Comparison with Moses (Koehn et al., 2007) and a re-implementation of the bottom-up stringto-dependency decoder (Shen et al., 2008) in terms of uncased BLEU and TER. We use randomization test (Riezler and Maxwell, 2005) to calculate statistical significance. *: significantly better than Moses (p &lt; 0.05), **: significantly better than Moses (p &lt; 0.01), +: significantly better than string-todependency (p &lt; 0.05), ++: significantly better than string-to-dependency (p &lt; 0.01). features BLEU TER standard 34.79 56.93 + depLM 35.29* 56.17** + maxent 35.40** 56.09** + depLM &amp; maxent 35.71** 55.87** Table 3: Contribution of maximum entropy shiftreduce parsing model. “standard” denotes using standard features of phrase-based system</context>
<context citStr="Shen et al., 2008" endWordPosition="3614" position="21722" startWordPosition="3611">ncy language model was trained on the English dependency trees. We used the 2002 NIST MT ChineseEnglish dataset as the development set and the 2003-2005 NIST datasets as the testsets. We evaluated translation quality using uncased BLEU (Papineni et al., 2002) and TER (Snover et al., 2006). The features were optimized with respect to BLEU using the minimum error rate training algorithm (Och, 2003). We chose the following two systems that are closest to our work as baselines: 1. The Moses phrase-based decoder (Koehn et al., 2007). 2. A re-implementation of bottom-up string-todependency decoder (Shen et al., 2008). All the three systems share with the same targetside parsed, word-aligned training data. The histogram pruning parameter b is set to 100 and rules coverage BLEU TER well-formed 44.87 34.42 57.35 all 100.00 35.71** 55.87** Table 4: Comparison of well-formed and illformed structures. Using all rules significantly outperforms using only well-formed structures. BLEU and TER scores are calculated on the development set. phrase table limit is set to 20 for all the three systems. Moses shares the same feature set with our system except for the dependency features. For the bottom-up string-to-depend</context>
</contexts>
<marker>Shen, Xu, Weischedel, 2008</marker>
<rawString>Libin Shen, Jinxi Xu, and Ralph Weischedel. 2008. A new string-to-dependency machine translation algorithm with a target dependency language model. In Proc. ofACL 2008.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Libin Shen</author>
<author>Jinxi Xu</author>
<author>Ralph Weischedel</author>
</authors>
<title>String-to-dependency statistical machine translation.</title>
<date>2010</date>
<journal>Computational Linguistics,</journal>
<volume>36</volume>
<issue>4</issue>
<contexts>
<context citStr="Shen et al., 2010" endWordPosition="813" position="5481" startWordPosition="810"> algorithm for phrase-based string-to-dependency translation. The basic unit of translation in our model is string-to-dependency phrase pair, which consists of a phrase on the source side and a dependency structure on the target side. The algorithm generates well-formed dependency structures for partial translations left-to-right using string-todependency phrase pairs. Therefore, our approach is capable of combining the advantages of both phrase-based and syntax-based approaches: 1. compact rule table: our rule table is a subset of the original string-to-dependency grammar (Shen et al., 2008; Shen et al., 2010) by excluding rules with non-terminals. 2. full rule coverage: all phrase pairs, both syntactic and non-syntactic, can be used in our algorithm. This is the same with Moses (Koehn et al., 2007). 3. efficient integration of n-gram language model: as translation grows left-to-right in our algorithm, integrating n-gram language models is straightforward. 4. exploiting syntactic information: as the shift-reduce parsing algorithm generates target language dependency trees in decoding, dependency language models (Shen et al., 2008; Shen et al., 2010) can be used to encourage linguistically-motivated</context>
</contexts>
<marker>Shen, Xu, Weischedel, 2010</marker>
<rawString>Libin Shen, Jinxi Xu, and Ralph Weischedel. 2010. String-to-dependency statistical machine translation. Computational Linguistics, 36(4).</rawString>
</citation>
<citation valid="true">
<authors>
<author>Matthew Snover</author>
<author>Bonnie Dorr</author>
<author>Richard Schwartz</author>
<author>Linnea Micciulla</author>
<author>John Makhoul</author>
</authors>
<title>A study of translation edit rate with targeted human annotation.</title>
<date>2006</date>
<booktitle>In Proc. ofAMTA</booktitle>
<contexts>
<context citStr="Snover et al., 2006" endWordPosition="3562" position="21393" startWordPosition="3559">ase-based system. Adding dependency language model (“depLM”) and the maximum entropy shift-reduce parsing model (“maxent”) significantly improves BLEU and TER on the development set, both separately and jointly. 4-gram language model on the Xinhua portion of the GIGAWORD coprus, which contians 238M English words. A 3-gram dependency language model was trained on the English dependency trees. We used the 2002 NIST MT ChineseEnglish dataset as the development set and the 2003-2005 NIST datasets as the testsets. We evaluated translation quality using uncased BLEU (Papineni et al., 2002) and TER (Snover et al., 2006). The features were optimized with respect to BLEU using the minimum error rate training algorithm (Och, 2003). We chose the following two systems that are closest to our work as baselines: 1. The Moses phrase-based decoder (Koehn et al., 2007). 2. A re-implementation of bottom-up string-todependency decoder (Shen et al., 2008). All the three systems share with the same targetside parsed, word-aligned training data. The histogram pruning parameter b is set to 100 and rules coverage BLEU TER well-formed 44.87 34.42 57.35 all 100.00 35.71** 55.87** Table 4: Comparison of well-formed and illforme</context>
</contexts>
<marker>Snover, Dorr, Schwartz, Micciulla, Makhoul, 2006</marker>
<rawString>Matthew Snover, Bonnie Dorr, Richard Schwartz, Linnea Micciulla, and John Makhoul. 2006. A study of translation edit rate with targeted human annotation. In Proc. ofAMTA 2006.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Andreas Stolcke</author>
</authors>
<title>Srilm - an extensible language modeling toolkit.</title>
<date>2002</date>
<booktitle>In Proc. of ICSLP</booktitle>
<contexts>
<context citStr="Stolcke, 2002" endWordPosition="3271" position="19548" startWordPosition="3270">as a single root, it can treated as a (pseudo) fixed structure; otherwise it is transformed to one (pseudo) left floating structure and one (pseudo) right floating structure. We use a feature to count how many ill-formed structures are used in decoding. 5 Experiments We evaluated our phrase-based string-todependency translation system on ChineseEnglish translation. The training data consists of 2.9M pairs of sentences with 76.0M Chinese words and 82.2M English words. We used the Stanford parser (Klein and Manning, 2003) to get dependency trees for English sentences. We used the SRILM toolkit (Stolcke, 2002) to train a 3Note that the first pass does not work like a phrase-based decoder because it yields dependency trees on the target side. A uniform model (i.e., each action has a fixed probability of 1/3) is used to resolve “h+h” conflicts. 6 system MT02 (tune) MT03 MT04 MT05 BLEU TER BLEU TER BLEU TER BLEU TER phrase 34.88 57.00 33.82 57.19 35.48 56.48 32.52 57.62 dependency 35.23 56.12 34.20 56.36 36.01 55.55 33.06 56.94 this work 35.71** 55.87** 34.81**+ 55.94**+ 36.37** 55.02**+ 33.53** 56.58** Table 2: Comparison with Moses (Koehn et al., 2007) and a re-implementation of the bottom-up string</context>
</contexts>
<marker>Stolcke, 2002</marker>
<rawString>Andreas Stolcke. 2002. Srilm - an extensible language modeling toolkit. In Proc. of ICSLP 2002.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Taro Watanabe</author>
<author>Hajime Tsukuda</author>
<author>Hideki Isozaki</author>
</authors>
<title>Left-to-right target generation for hierarchical phrase-based translation.</title>
<date>2006</date>
<booktitle>In Proc. of ACL</booktitle>
<contexts>
<context citStr="Watanabe et al., 2006" endWordPosition="481" position="3350" startWordPosition="478">rtion of nonsyntactic phrase pairs, which might help decoders generalize well to unseen data (Marcu et al., 2006). Furthermore, the introduction of nonterminals makes the grammar size significantly bigger than phrase tables and leads to higher memory requirement (Chiang, 2007). As a result, incremental decoding with hierarchical structures has attracted increasing attention in recent years. While some authors try to integrate syntax into phrase-based decoding (Galley and Manning, 2008; Galley and Manning, 2009; Feng et al., 2010), others develop incremental algorithms for syntax-based models (Watanabe et al., 2006; Huang and Mi, 2010; Dyer and Resnik, 2010; Feng et al., 2012). Despite these successful efforts, challenges still remain for both directions. While parsing algorithms can be used to parse partial translations in phrase-based decoding, the search space is significantly enlarged since there are exponentially many parse trees for exponentially many translations. On the other hand, although target words can be generated left-to-right by altering the way of tree transversal in syntaxbased models, it is still difficult to reach full rule coverage as compared with phrase table. 1 Proceedings of the</context>
<context citStr="Watanabe et al., 2006" endWordPosition="4475" position="27308" startWordPosition="4472">anguage models can be directly used. Shift-reduce parsing has been successfully used in phrase-based decoding but limited to adding structural constraints. Galley and Manning (2008) propose a shift-reduce algorithm to integrate a hierarchical reordering model into phrase-based systems. Feng et al. (2010) use shift-reduce parsing to impose ITG (Wu, 1997) constraints on phrase permutation. Our work differs from theirs by going further to incorporate linguistic syntax into phrase-based decoding. Along another line, a number of authors have developed incremental algorithms for syntaxbased models (Watanabe et al., 2006; Huang and Mi, 2010; Dyer and Resnik, 2010; Feng et al., 2012). Watanabe et al. (2006) introduce an Earlystyle top-down parser based on binary-branching Greibach Normal Form. Huang et al. (2010), Dyer 34.50 34.00 33.50 33.00 32.50 32.00 31.50 31.00 30.50 this work Moses 8 and Resnik (2010), and Feng et al. (2012) use dotted rules to change the tree transversal to generate target words left-to-right, either top-down or bottom-up. 7 Conclusion We have presented a shift-reduce parsing algorithm for phrase-based string-to-dependency translation. The algorithm generates dependency structures incre</context>
</contexts>
<marker>Watanabe, Tsukuda, Isozaki, 2006</marker>
<rawString>Taro Watanabe, Hajime Tsukuda, and Hideki Isozaki. 2006. Left-to-right target generation for hierarchical phrase-based translation. In Proc. of ACL 2006.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Dekai Wu</author>
</authors>
<title>Stochastic inversion transduction grammars and bilingual parsing of parallel corpora.</title>
<date>1997</date>
<journal>Computational Linguistics.</journal>
<contexts>
<context citStr="Wu, 1997" endWordPosition="266" position="1929" startWordPosition="265">l at handling local word selection and reordering. In addition, it is straightforward to integrate n-gram language models into phrase-based decoders in which translation always grows left-to-right. As a result, phrase-based decoders only need to maintain the boundary words on one end to calculate language model probabilities. However, as phrase-based decoding usually casts translation as a string concatenation problem and permits arbitrary permutation, it proves to be NP-complete (Knight, 1999). Syntax-based approaches, on the other hand, model the hierarchical structure of natural languages (Wu, 1997; Yamada and Knight, 2001; Chiang, 2005; Quirk et al., 2005; Galley et al., 2006; Liu et al., 2006; Huang et al., 2006; Shen et al., 2008; Mi and Huang, 2008; Zhang et al., 2008). As syntactic information can be exploited to provide linguistically-motivated reordering rules, predicting non-local permutation is computationally tractable in syntax-based approaches. Unfortunately, as syntax-based decoders often generate target-language words in a bottom-up way using the CKY algorithm, integrating n-gram language models becomes more expensive because they have to maintain target boundary words at </context>
<context citStr="Wu, 1997" endWordPosition="4436" position="27042" startWordPosition="4435">our second pass is to find the Viterbi derivation with addition features rather than parsing the phrasal lattice. In addition, their algorithm produces phrasal dependency parse trees while the leaves of our dependency trees are words, making dependency language models can be directly used. Shift-reduce parsing has been successfully used in phrase-based decoding but limited to adding structural constraints. Galley and Manning (2008) propose a shift-reduce algorithm to integrate a hierarchical reordering model into phrase-based systems. Feng et al. (2010) use shift-reduce parsing to impose ITG (Wu, 1997) constraints on phrase permutation. Our work differs from theirs by going further to incorporate linguistic syntax into phrase-based decoding. Along another line, a number of authors have developed incremental algorithms for syntaxbased models (Watanabe et al., 2006; Huang and Mi, 2010; Dyer and Resnik, 2010; Feng et al., 2012). Watanabe et al. (2006) introduce an Earlystyle top-down parser based on binary-branching Greibach Normal Form. Huang et al. (2010), Dyer 34.50 34.00 33.50 33.00 32.50 32.00 31.50 31.00 30.50 this work Moses 8 and Resnik (2010), and Feng et al. (2012) use dotted rules t</context>
</contexts>
<marker>Wu, 1997</marker>
<rawString>Dekai Wu. 1997. Stochastic inversion transduction grammars and bilingual parsing of parallel corpora. Computational Linguistics.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Yue Zhang</author>
<author>Stephen Clark</author>
</authors>
<title>A tale of two parsers: investigating and combining graphbased and transition-based dependency parsing using beam search.</title>
<date>2008</date>
<booktitle>In Proc. of EMNLP</booktitle>
<contexts>
<context citStr="Zhang and Clark, 2008" endWordPosition="1485" position="9436" startWordPosition="1482">e actions (Huang et al., 2009) to extend a state: 1. shift (S): move a target dependency structure onto the stack; 2. reduce left (Rl): combine the two items on the stack, st and st−1 (t &gt; 2), with the root of st as the head and replace them with a combined item; 3. reduce right (Rr): combine the two items on the stack, st and st−1 (t &gt; 2), with the root of st−1 as the head and replace them with a combined item. The decoding process terminates when all source words are covered and there is a complete dependency tree in the stack. Note that unlike monolingual shift-reduce parsers (Nivre, 2004; Zhang and Clark, 2008; Huang et al., 2009), our algorithm does not maintain a queue for remaining words of the input because the future dependency structure to be shifted is unknown in advance in the translation scenario. Instead, we use a coverage vector on the source side to determine when to terminate the algorithm. For an input sentence of J words, the number of actions is 2K −1, where K is the number of rules used in decoding. 1 There are always K shifts and 1Empirically, we find that the average number of stacks for J words is about 1.5 × J on the Chinese-English data. 3 [The President] [will] [visit] S Rl [</context>
<context citStr="Zhang and Clark, 2008" endWordPosition="2874" position="17100" startWordPosition="2871"> states. In addition, we follow Huang et al. (2009) to use the heuristic of “shortest stack” to always prefer Rl to S. 4 Decoding Our decoder is based on a linear model (Och, 2003) with the following features: 1. relative frequencies in two directions; 2. lexical weights in two directions; 3. phrase penalty; 4. distance-based reordering model; 5. lexicaized reordering model; 6. n-gram language model model; 7. word penalty; 8. ill-formed structure penalty; 9. dependency language model; 10. maximum entropy parsing model. In practice, we extend deterministic shiftreduce parsing with beam search (Zhang and Clark, 2008; Huang et al., 2009). As shown in Algorithm 1, the algorithm maintains a list of stacks V and each stack groups states with the same number of accumulated actions (line 2). The stack list V initializes with an empty state vo (line 3). Then, the states in the stack are iteratively extended until there are no incomplete states (lines 4-12). The search space is constrained by discarding any state that has a score worse than: 1. β multiplied with the best score in the stack, or 2. the score of b-th best state in the stack. As the stack of a state keeps changing during the decoding process, the co</context>
</contexts>
<marker>Zhang, Clark, 2008</marker>
<rawString>Yue Zhang and Stephen Clark. 2008. A tale of two parsers: investigating and combining graphbased and transition-based dependency parsing using beam search. In Proc. of EMNLP 2008.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Min Zhang</author>
<author>Hongfei Jiang</author>
<author>Aiti Aw</author>
<author>Haizhou Li</author>
<author>Chew Lim Tan</author>
<author>Sheng Li</author>
</authors>
<title>A tree sequence alignment-based tree-to-tree translation model.</title>
<date>2008</date>
<booktitle>In Proc. of ACL</booktitle>
<contexts>
<context citStr="Zhang et al., 2008" endWordPosition="300" position="2107" startWordPosition="297">on always grows left-to-right. As a result, phrase-based decoders only need to maintain the boundary words on one end to calculate language model probabilities. However, as phrase-based decoding usually casts translation as a string concatenation problem and permits arbitrary permutation, it proves to be NP-complete (Knight, 1999). Syntax-based approaches, on the other hand, model the hierarchical structure of natural languages (Wu, 1997; Yamada and Knight, 2001; Chiang, 2005; Quirk et al., 2005; Galley et al., 2006; Liu et al., 2006; Huang et al., 2006; Shen et al., 2008; Mi and Huang, 2008; Zhang et al., 2008). As syntactic information can be exploited to provide linguistically-motivated reordering rules, predicting non-local permutation is computationally tractable in syntax-based approaches. Unfortunately, as syntax-based decoders often generate target-language words in a bottom-up way using the CKY algorithm, integrating n-gram language models becomes more expensive because they have to maintain target boundary words at both ends of a partial translation (Chiang, 2007; Huang and Chiang, 2007). Moreover, syntax-based approaches often suffer from the rule coverage problem since syntactic constrain</context>
</contexts>
<marker>Zhang, Jiang, Aw, Li, Tan, Li, 2008</marker>
<rawString>Min Zhang, Hongfei Jiang, Aiti Aw, Haizhou Li, Chew Lim Tan, and Sheng Li. 2008. A tree sequence alignment-based tree-to-tree translation model. In Proc. of ACL 2008.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>