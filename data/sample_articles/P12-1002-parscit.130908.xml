<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant confidence="0.000004" no="0">
<title confidence="0.998455">
Joint Feature Selection in Distributed Stochastic Learning
for Large-Scale Discriminative Training in SMT
</title>
<author confidence="0.998205">
Patrick Simianer and Stefan Riezler
</author>
<affiliation confidence="0.9904095">
Department of Computational Linguistics
Heidelberg University
</affiliation>
<address confidence="0.709688">
69120 Heidelberg, Germany
</address>
<email confidence="0.996494">
{simianer,riezler}@cl.uni-heidelberg.de
</email>
<author confidence="0.983113">
Chris Dyer
</author>
<affiliation confidence="0.980954">
Language Technologies Institute
Carnegie Mellon University
</affiliation>
<address confidence="0.573016">
Pittsburgh, PA, 15213, USA
</address>
<email confidence="0.999079">
cdyer@cs.cmu.edu
</email>
<sectionHeader confidence="0.995645" genericHeader="abstract">
Abstract
</sectionHeader>
<bodyText confidence="0.999800222222222">With a few exceptions, discriminative training in statistical machine translation (SMT) has been content with tuning weights for large feature sets on small development data. Evidence from machine learning indicates that increasing the training sample size results in better prediction. The goal of this paper is to show that this common wisdom can also be brought to bear upon SMT. We deploy local features for SCFG-based SMT that can be read off from rules at runtime, and present a learning algorithm that applies f1/Q2 regularization for joint feature selection over distributed stochastic learning processes. We present experiments on learning on 1.5 million training sentences, and show significant improvements over tuning discriminative models on small development sets.</bodyText>
<sectionHeader confidence="0.998993" genericHeader="introduction">
1 Introduction
</sectionHeader>
<bodyText confidence="0.999976958333334">The standard SMT training pipeline combines scores from large count-based translation models and language models with a few other features and tunes these using the well-understood line-search technique for error minimization of Och (2003). If only a handful of dense features need to be tuned, minimum error rate training can be done on small tuning sets and is hard to beat in terms of accuracy and efficiency. In contrast, the promise of largescale discriminative training for SMT is to scale to arbitrary types and numbers of features and to provide sufficient statistical support by parameter estimation on large sample sizes. Features may be lexicalized and sparse, non-local and overlapping, or be designed to generalize beyond surface statistics by incorporating part-of-speech or syntactic labels. The modeler’s goals might be to identify complex properties of translations, or to counter errors of pretrained translation models and language models by explicitly down-weighting translations that exhibit certain undesired properties. Various approaches to feature engineering for discriminative models have been presented (see Section 2), however, with a few exceptions, discriminative learning in SMT has been confined to training on small tuning sets of a few thousand examples. This contradicts theoretical and practical evidence from machine learning that suggests that larger training samples should be beneficial to improve prediction also in SMT. Why is this? One possible reason why discriminative SMT has mostly been content with small tuning sets lies in the particular design of the features themselves. For example, the features introduced by Chiang et al. (2008) and Chiang et al. (2009) for an SCFG model for Chinese/English translation are of two types: The first type explicitly counters overestimates of rule counts, or rules with bad overlap points, bad rewrites, or with undesired insertions of target-side terminals. These features are specified in handcrafted lists based on a thorough analysis of a tuning set. Such finely hand-crafted features will find sufficient statistical support on a few thousand examples and thus do not benefit from larger training sets. The second type of features deploys external information such as syntactic parses or word alignments to penalize bad reorderings or undesired translations of phrases that cross syntactic constraints. At large scale, extraction of such features quickly becomes infeasible because of costly generation and storage of linguistic annotations.</bodyText>
<page confidence="0.992766">
11
</page>
<note confidence="0.985194">
Proceedings of the 50th Annual Meeting of the Association for Computational Linguistics, pages 11–21,
Jeju, Republic of Korea, 8-14 July 2012. c�2012 Association for Computational Linguistics
</note>
<figure confidence="0.830995">
(1) X X1 hat X2 versprochen, X1 promised X2
(2) X X1 hat mir X2 versprochen,
X1 promised me X2
(3) X X1 versprach X2, X1 promised X2
</figure>
<figureCaption confidence="0.999049">
Figure 1: SCFG rules for translation.
</figureCaption>
<bodyText confidence="0.999936105263158">Another possible reason why large training data did not yet show the expected improvements in discriminative SMT is a special overfitting problem of current popular online learning techniques. This is due to stochastic learning on a per-example basis where a weight update on a misclassified example may apply only to a small fraction of data that have been seen before. Thus many features will not generalize well beyond the training examples on which they were introduced. The goal of this paper is to investigate if and how it is possible to benefit from scaling discriminative training for SMT to large training sets. We deploy generic features for SCFG-based SMT that can efficiently be read off from rules at runtime. Such features include rule ids, rule-local n-grams, or types of rule shapes. Another crucial ingredient of our approach is a combination of parallelized stochastic learning with feature selection inspired by multi-task learning. The simple but effective idea is to randomly divide training data into evenly sized shards, use stochastic learning on each shard in parallel, while performing f1/f2 regularization for joint feature selection on the shards after each epoch, before starting a new epoch with a reduced feature vector averaged across shards. Iterative feature selection procedure is the key to both efficiency and improved prediction: Without interleaving parallelized stochastic learning with feature selection our largest experiments would not be feasible. Selecting features jointly across shards and averaging does counter the overfitting effect that is inherent to stochastic updating. Our resulting models are learned on large data sets, but they are small and outperform models that tune feature sets of various sizes on small development sets. Our software is freely available as a part of the cdec1 framework.</bodyText>
<footnote confidence="0.948164">
1https://github.com/redpony/cdec
</footnote>
<sectionHeader confidence="0.996869" genericHeader="related work">
2 Related Work
</sectionHeader>
<bodyText confidence="0.999958815789474">The great promise of discriminative training for SMT is the possibility to design arbitrarily expressive, complex, or overlapping features in great numbers. The focus of many approaches thus has been on feature engineering and on adaptations of machine learning algorithms to the special case of SMT (where gold standard rankings have to be created automatically). Examples for adapted algorithms include Maximum-Entropy Models (Och and Ney, 2002; Blunsom et al., 2008), Pairwise Ranking Perceptrons (Shen et al., 2004; Watanabe et al., 2006; Hopkins and May, 2011), Structured Perceptrons (Liang et al., 2006a), Boosting (Duh and Kirchhoff, 2008; Wellington et al., 2009), Structured SVMs (Tillmann and Zhang, 2006; Hayashi et al., 2009), MIRA (Watanabe et al., 2007; Chiang et al., 2008; Chiang et al., 2009), and others. Adaptations of the loss functions underlying such algorithms to SMT have recently been described as particular forms of ramp loss optimization (McAllester and Keshet, 2011; Gimpel and Smith, 2012). All approaches have been shown to scale to large feature sets and all include some kind of regularization method. However, most approaches have been confined to training on small tuning sets. Exceptions where discriminative SMT has been used on large training data are Liang et al. (2006a) who trained 1.5 million features on 67,000 sentences, Blunsom et al. (2008) who trained 7.8 million rules on 100,000 sentences, or Tillmann and Zhang (2006) who used 230,000 sentences for training. Our approach is inspired by Duh et al. (2010) who applied multi-task learning for improved generalization in n-best reranking. In contrast to our work, Duh et al. (2010) did not incorporate multitask learning into distributed learning, but defined tasks as n-best lists, nor did they develop new algorithms, but used off-the-shelf multi-task tools.</bodyText>
<sectionHeader confidence="0.976933" genericHeader="method">
3 Local Features for Synchronous CFGs
</sectionHeader>
<bodyText confidence="0.999009">The work described in this paper is based on the SMT framework of hierarchical phrase-based translation (Chiang, 2005; Chiang, 2007). Translation rules are extracted from word-aligned parallel sentences and can be seen as productions of a synchronous CFG. Examples are rules like (1)-(3)</bodyText>
<page confidence="0.997554">
12
</page>
<bodyText confidence="0.999747291666667">shown in Figure 1. Local features are designed to be readable directly off the rule at decoding time. We use three rule templates in our work: Rule identifiers: These features identify each rule by a unique identifier. Such features correspond to the relative frequencies of rewrites rules used in standard models. Rule n-grams: These features identify n-grams of consecutive items in a rule. We use bigrams on source-sides of rules. Such features identify possible source side phrases and thus can give preference to rules including them.2 Rule shape: These features are indicators that abstract away from lexical items to templates that identify the location of sequences of terminal symbols in relation to non-terminal symbols, on both the sourceand target-sides of each rule used. For example, both rules (1) and (2) map to the same indicator, namely that a rule is being used that consists of a (NT, term*, NT, term*) pattern on its source side, and an (NT, term*, NT) pattern on its target side. Rule (3) maps to a different template, that of (NT, term*, NT) on source and target sides.</bodyText>
<sectionHeader confidence="0.816393" genericHeader="method">
4 Joint Feature Selection in Distributed
</sectionHeader>
<subsectionHeader confidence="0.916027">
Stochastic Learning
</subsectionHeader>
<bodyText confidence="0.997955">The following discussion of learning methods is based on pairwise ranking in a Stochastic Gradient Descent (SGD) framework. The resulting algorithms can be seen as variants of the perceptron algorithm. Let each translation candidate be represented by a feature vector x E IRD where preference pairs for training are prepared by sorting translations according to smoothed sentence-wise BLEU score (Liang et al., 2006a) against the reference. For a preference pair xj = (x(1)</bodyText>
<equation confidence="0.971209666666667">
j , xj
2)) where x(1)
j is pre-
ferred over x(2)
j , and ¯xj = x(1)
j − x(2)
</equation>
<bodyText confidence="0.890439">j , we consider the following hinge loss-type objective function:</bodyText>
<equation confidence="0.994322">
lj(w) = (− (w, ¯xj ))+
</equation>
<bodyText confidence="0.996484333333333">where (a)+ = max(0, a) , w E IRD is a weight vector, and (·, ·) denotes the standard vector dot product. Instantiating SGD to the following stochastic subgradient leads to the perceptron algorithm for pairwise ranking3 (Shen and Joshi, 2005): �</bodyText>
<footnote confidence="0.898096">
2Similar “monolingual parse features” have been used in
Dyer et al. (2011).
</footnote>
<equation confidence="0.995648666666667">
−¯xj if (w, ¯xj) G 0,
�lj(w) =
0 else.
</equation>
<bodyText confidence="0.89348325">Our baseline algorithm 1 (SDG) scales pairwise ranking to large scale scenarios. The algorithm takes an average over the final weight updates of each epoch instead of keeping a record of all weight updates for final averaging (Collins, 2002) or for voting (Freund and Schapire, 1999). Algorithm 1 SGD: int I, T, float 77 Initialize w0,0,0 F 0. for epochs t F 0 ... T − 1: do for all i E {0 ... I − 11: do Decode ith input with wt,i,0. for all pairs xj, j E {0 ... P// − 11: do</bodyText>
<equation confidence="0.992734571428571">
wt,i,j+1 F wt,i,j − ηVlj(Wt,i,j)
end for
wt,i+1,0 F wt,i,P
end for
wt+1,0,0 F wt,I,0
end for
return T1
</equation>
<bodyText confidence="0.979821333333333">While stochastic learning exhibits a runtime behavior that is linear in sample size (Bottou, 2004), very large datasets can make sequential processing infeasible. Algorithm 2 (MixSGD) addresses this problem by parallelization in the framework of MapReduce (Dean and Ghemawat, 2004). Algorithm 2 MixSGD: int I, T, Z, float 77 Partition data into Z shards, each of size S F I/Z; distribute to machines. for all shards z E {1 ... Z1: parallel do Initialize wz,0,0,0 F 0. for epochs t F 0 ... T − 1: do for all i E {0 ... S − 11: do Decode ith input with wz,t,i,0. for all pairs xj, j E {0 ... P −//11: do</bodyText>
<equation confidence="0.9507794">
wz,t,i,j+1 F wz,t,i,j − ηvljlWz,t,i,j)
end for
wz,t,i+1,0 F wz,t,i,P
end for
wz,t+1,0,0 F wz,t,S,0
end for
end for
Collect final weights from each machine,
E 1 1T E wz,t,0,0J .
z=1 t=1
</equation>
<footnote confidence="0.682772666666667">
3Other loss functions lead to stochastic versions of SVMs
(Collobert and Bengio, 2004; Shalev-Shwartz et al., 2007;
Chapelle and Keerthi, 2010).
</footnote>
<equation confidence="0.960677">
T
E
t=1
wt,0,0
return 1Z
</equation>
<page confidence="0.984307">
13
</page>
<bodyText confidence="0.999122125">Algorithm 2 is a variant of the SimuParallelSGD algorithm of Zinkevich et al. (2010) or equivalently of the parameter mixing algorithm of McDonald et al. (2010). The key idea of algorithm 2 is to partition the data into disjoint shards, then train SGD on each shard in parallel, and after training mix the final parameters from each shard by averaging. The algorithm requires no communication between machines until the end. McDonald et al. (2010) also present an iterative mixing algorithm where weights are mixed from each shard after training a single epoch of the perceptron in parallel on each shard. The mixed weight vector is re-sent to each shard to start another epoch of training in parallel on each shard. This algorithm corresponds to our algorithm 3 (IterMixSGD).</bodyText>
<figure confidence="0.775487777777778">
Algorithm 3 IterMixSGD: int I, T, Z, float 77
Partition data into Z shards, each of size S F I/Z;
distribute to machines.
Initialize v F 0.
for epochs t F 0 ... T − 1: do
for all shards z E {1 ... Z}: parallel do
wz,t,0,0 F v
for all i E {0 ... S − 1}: do
Decode ith input with wz,t,i,0.
for all pairs xj, j E {0 ... P −//1}: do
wz,t,i,j+1 F wz,t,i,j − ηvljlWz,t,i,j)
end for
wz,t,i+1,0 F wz,t,i,P
end for
end for
Collect weights v F 1Z
end for
return v
</figure>
<bodyText confidence="0.999970652173913">Parameter mixing by averaging will help to ease the feature sparsity problem, however, keeping feature vectors on the scale of several million features in memory can be prohibitive. If network latency is a bottleneck, the increased amount of information sent across the network after each epoch may be a further problem. Our algorithm 4 (IterSelSGD) introduces feature selection into distributed learning for increased efficiency and as a more radical measure against overfitting. The key idea is to view shards as tasks, and to apply methods for joint feature selection from multi-task learning to achieve small sets of features that are useful across all tasks or shards. Our algorithm represents weights in a Z-by-D matrix W = [wz1 |... |wzZ]T of stacked D-dimensional weight vectors across Z shards. We compute the f2 norm of the weights in each feature column, sort features by this value, and keep K features in the model. This feature selection procedure is done after each epoch. Reduced weight vectors are mixed and the result is re-sent to each shard to start another epoch of parallel training on each shard.</bodyText>
<table confidence="0.6283447">
Algorithm 4 IterSelSGD: int I, T, Z, K, float 77
Partition data into Z shards, each of size S = I/Z;
distribute to machines.
Initialize v F 0.
for epochs t F 0 ... T − 1: do
for all shards z E {1 ... Z}: parallel do
wz,t,0,0 F v
for all i E {0 ... S − 1}: do
Decode ith input with wz,t,i,0.
for all pairs xj, j E {0 ... P −//1}: do
wz,t,i,j+1 F wz,t,i,j − ηvlj(Wz,t,i,j)
end for
wz,t,i+1,0 F wz,t,i,P
end for
end for
Collect/stack weights W F [w1,t,S,0 |. . . |wZ,t,S,0]T
Select top K feature columns of W by 12 norm and
for k F 1 ... K do
v[k] = 1
Z
</table>
<tableCaption confidence="0.471737333333333">
end for
end for
return v
</tableCaption>
<bodyText confidence="0.9998458">This algorithm can be seen as an instance of f1/f2 regularization as follows: Let wd be the dth column vector of W, representing the weights for the dth feature across tasks/shards. f1/f2 regularization penalizes weights W by the weighted f1/f2 norm A||W||1,2 = A</bodyText>
<bodyText confidence="0.999946307692308">Each f2 norm of a weight column represents the relevance of the corresponding feature across tasks/shards. The f1 sum of the f2 norms enforces a selection among features based on these norms. Consider for example the two 5-feature, 3task weight matrices in Figure 2. Assuming the same loss for both matrices, the right-hand side matrix is preferred because of a smaller f1/f2 norm (12 instead of 18). This matrix shares features across tasks which leads to larger f2 norms for some columns (here ||w1||2 and ||w2||2) and forces other columns to zero. This results in shrinking the matrix to those features that are useful across all tasks.</bodyText>
<figure confidence="0.970377">
Z
E
z=1
wz,t,S,0.
Z
E
z=1
W[z][k].
D
E
d=1
||wd||2.
</figure>
<page confidence="0.966891">
14
</page>
<table confidence="0.991911666666667">
w1 w2 w3 w4 w5 w1 w2 w3 w4 w5
wz1 [ 6 4 0 0 0 ] [ 6 4 0 0 0 ]
wz2 [ 0 0 3 0 0 ] [ 3 0 0 0 0 ]
wx3 [ 0 0 0 2 3 ] [ 2 3 0 0 0 ]
column `2 norm: 6 4 3 2 3 7 5 0 0 0
`1 sum: =�. 18 =�. 12
</table>
<figureCaption confidence="0.939218">
Figure 2: f1/f2 regularization enforcing feature selection.
</figureCaption>
<bodyText confidence="0.999926625">Our algorithm is related to Obozinski et al. (2010)’s approach to f1/f2 regularization where feature columns are incrementally selected based on the f2 norms of the gradient vectors corresponding to feature columns. Their algorithm is itself an extension of gradient-based feature selection based on the f1 norm, e.g., Perkins et al. (2003).4 In contrast to these approaches we approximate the gradient by using the weights given by the ranking algorithm itself. This relates our work to weight-based recursive feature elimination (RFE) (Lal et al., 2006). Furthermore, algorithm 4 performs feature selection based on a choice of meta-parameter of K features instead of by thresholding a regularization meta-parameter A, however, these techniques are equivalent and can be transformed into each other.</bodyText>
<sectionHeader confidence="0.999812" genericHeader="evaluation and result">
5 Experiments
</sectionHeader>
<subsectionHeader confidence="0.971514">
5.1 Data, Systems, Experiment Settings
</subsectionHeader>
<bodyText confidence="0.99998325">The datasets used in our experiments are versions of the News Commentary (nc), News Crawl (crawl) and Europarl (ep) corpora described in Table 1. The translation direction is German-to-English. The SMT framework used in our experiments is hierarchical phrase-based translation (Chiang, 2007). We use the cdec decoder5 (Dyer et al., 2010) and induce SCFG grammars from two sets of symmetrized alignments using the method described by Chiang (2007). All data was tokenized and lowercased; German compounds were split (Dyer, 2009). For word alignment of the news-commentary data, we used GIZA++ (Och and Ney, 2000); for aligning the Europarl data, we used the Berkeley aligner (Liang et al., 2006b). Before training, we collect all the grammar rules necessary to translate each individual sentence into separate files (so-called per-sentence grammars) (Lopez, 2007).</bodyText>
<footnote confidence="0.98442575">
4Note that by definition of ||W||1,2, standard f1 regulariza-
tion is a special case of f1/f2 regularization for a single task.
5cdec metaparameters were set to a non-terminal span limit
of 15 and standard cube pruning with a pop limit of 200.
</footnote>
<bodyText confidence="0.997206636363636">When decoding, cdec loads the appropriate file immediately prior to translation of the sentence. The computational overhead is minimal compared to the expense of decoding. Also, deploying disk space instead of memory fits perfectly into the MapReduce framework we are working in. Furthermore, the extraction of grammars for training is done in a leave-one-out fashion (Zollmann and Sima’an, 2005) where rules are extracted for a parallel sentence pair only if the same rules are found in other sentences of the corpus as well.3-gram (news-commentary) and 5-gram (Europarl) language models are trained on the data described in Table 1, using the SRILM toolkit (Stolcke, 2002) and binarized for efficient querying using kenlm (Heafield, 2011). For the 5-gram language models, we replaced every word in the lm training data with &lt;unk&gt; that did not appear in the English part of the parallel training data to build an open vocabulary language model.</bodyText>
<figureCaption confidence="0.996674">
Figure 3: Multipartite pairwise ranking.
</figureCaption>
<bodyText confidence="0.999861">Training data for discriminative learning are prepared by comparing a 100-best list of translations against a single reference using smoothed persentence BLEU (Liang et al., 2006a). From the BLEU-reordered n-best list, translations were put into sets for the top 10% level (HI), the middle 80% level (MID), and the bottom 10% level (LOW). These level sets are used for multipartite ranking where translation pairs are built between the elements in HI-MID, HI-LOW, and MID-LOW, but not between translations inside sets on the same level.</bodyText>
<figure confidence="0.648244">
HI
MID
LOW
</figure>
<page confidence="0.828791">
15
</page>
<table confidence="0.987405833333333">
News Commentary(nc)
train-nc lm-train-nc dev-nc devtest-nc test-nc
Sentences 132,753 180,657 1057 1064 2007
Tokens de 3,530,907 – 27,782 28,415 53,989
Tokens en 3,293,363 4,394,428 26,098 26,219 50,443
Rule Count 14,350,552 (1G) – 2,322,912 2,320,264 3,274,771
Europarl(ep)
train-ep lm-train-ep dev-ep devtest-ep test-ep
Sentences 1,655,238 2,015,440 2000 2000 2000
Tokens de 45,293,925 – 57,723 56,783 59,297
Tokens en 45,374,649 54,728,786 58,825 58,100 60,240
Rule Count 203,552,525 (31.5G) – 17,738,763 17,682,176 18,273,078
News Crawl(crawl)
dev-crawl test-crawl10 test-crawl11
Sentences 2051 2489 3003
Tokens de 49,848 64,301 76,193
Tokens en 49,767 61,925 74,753
Rule Count 9,404,339 11,307,304 12,561,636
</table>
<tableCaption confidence="0.961388833333333">
Table 1: Overview of data used for train/dev/test. News Commentary (nc) and Europarl (ep) training data and
also News Crawl (crawl) dev/test data were taken from the WMT11 translation task (http://statmt.org/
wmt11/translation-task.html). The dev/test data of nc are the sets provided with the WMT07 shared
task (http://statmt.org/wmt07/shared-task.html). Ep dev/test data is from WMT08 shared task
(http://statmt.org/wmt08/shared-task.html). The numbers in brackets for the rule counts of ep/nc
training data are total counts of rules in the per-sentence grammars.
</tableCaption>
<bodyText confidence="0.99731235">This idea is depicted graphically in Figure 3. The intuition is to ensure that good translations are preferred over bad translations without teasing apart small differences. For evaluation, we used the mteval-v11b.pl script to compute lowercased BLEU-4 scores (Papineni et al., 2001). Statistical significance was measured using an Approximate Randomization test (Noreen, 1989; Riezler and Maxwell, 2005). All experiments for training on dev sets were carried out on a single computer. For grammar extraction and training of the full data set we used a 30 node hadoop Map/Reduce cluster that can handle 300 jobs at once. We split the data into 2290 shards for the ep runs and 141 shards for the nc runs, each shard holding about 1,000 sentences, which corresponds to the dev set size of the nc data set.</bodyText>
<subsectionHeader confidence="0.995246">
5.2 Experimental Results
</subsectionHeader>
<bodyText confidence="0.999934666666667">The baseline learner in our experiments is a pairwise ranking perceptron that is used on various features and training data and plugged into various metaalgorithms for distributed processing.</bodyText>
<equation confidence="0.573897666666667">
M
X
BLEU[%] 23.0 25.0 27.0 29.0
</equation>
<figureCaption confidence="0.9997605">
Figure 4: Boxplot of BLEU-4 results for 100 runs of
MIRA on news commentary data, depicting median (M),
mean (x), interquartile range (box), standard deviation
(whiskers), outliers (end points).
</figureCaption>
<bodyText confidence="0.9923152">The perceptron algorithm itself compares favorably to related learning techniques such as the MIRA adaptation of Chiang et al.(2008). Figure 4 gives a boxplot depicting BLEU-4 results for 100 runs of the MIRA implementation of the cdec package, tuned on dev-nc, and evaluated on the respective test set test-nc.6 We see a high variance (whiskers denote standard deviations) around a median of 27.2 BLEU and a mean of 27.1 BLEU. The fluctuation of results is due to sampling training examples from the translation hy6MIRA was used with default meta parameters: 250 hypothesis list to search for oracles, regularization strength C = 0.01 and using 15 passes over the input.It optimized IBM BLEU-4. The initial weight vector was 0.</bodyText>
<page confidence="0.99359">
16
</page>
<table confidence="0.9997889">
Algorithm Tuning set Features #Features devtest-nc test-nc
MIRA dev-nc default 12 – 27.10
dev-nc default 12 25.88 28.0
dev-nc +id 137k 25.53 27.6†23
1 dev-nc +ng 29k 25.82 27.42†234
dev-nc +shape 51 25.91 28.1
dev-nc +id,ng,shape 180k 25.71 28.1534
train-nc default 12 25.73 27.86
train-nc +id 4.1M 25.13 27.19†134
2 train-nc +ng 354k 26.09 28.03134
train-nc +shape 51 26.07 27.913
train-nc +id,ng,shape 4.7M 26.08 27.8634
train-nc default 12 26.09 @2 27.94†
train-nc +id 3.4M 26.1 @4 27.97†12
3 train-nc +ng 330k 26.33 @4 28.3412
train-nc +shape 51 26.39 @9 28.312
train-nc +id,ng,shape 4.7M 26.42 @9 28.55124
train-nc +id 100k 25.91 @7 27.82†2
4 train-nc +ng 100k 26.42 @4 28.37†12
train-nc +id,ng,shape 100k 26.8 @8 28.81123
</table>
<tableCaption confidence="0.969099">
Table 2: BLEU-4 results for algorithms 1 (SGD), 2 (MixSGD), 3 (IterMixSDG), and 4 (IterSelSGD) on news-
commentary (nc) data. Feature groups are 12 dense features (default), rule identifiers (id), rule n-gram (ng), and rule shape (shape). Statistical significance at p-level &lt; 0.05 of a result difference on the test set to a different algorithm applied to the same feature group is indicated by raised algorithm number. † indicates statistically significant differences to best result across features groups for same algorithm, indicated in bold face. @ indicates the optimal number of epochs chosen on the devtest set.</tableCaption>
<bodyText confidence="0.94343696969697">pergraph as is done in the cdec implementation of MIRA. We found similar fluctuations for the cdec implementations of PRO (Hopkins and May, 2011) or hypergraph-MERT (Kumar et al., 2009) both of which depend on hypergraph sampling. In contrast, the perceptron is deterministic when started from a zero-vector of weights and achieves favorable 28.0 BLEU on the news-commentary test set. Since we are interested in relative improvements over a stable baseline, we restrict our attention in all following experiments to the perceptron.7 Table 2 shows the results of the experimental comparison of the 4 algorithms of Section 4. The 7Absolute improvements would be possible, e.g., by using larger language models or by adding news data to the ep training set when evaluating on crawl test sets (see, e.g., Dyer et al. (2011)), however, this is not the focus of this paper. default features include 12 dense models defined on SCFG rules;8 The sparse features are the 3 templates described in Section 3. All feature weights were tuned together using algorithms 1-4. If not indicated otherwise, the perceptron was run for 10 epochs with learning rate q = 0.0001, started at zero weight vector, using deduplicated 100-best lists. The results on the news-commentary (nc) data show that training on the development set does not benefit from adding large feature sets – BLEU result differences between tuning 12 default features and tuning the full set of 180,000 features are not significant.</bodyText>
<footnote confidence="0.986337833333333">
8negative log relative frequency p(elf); log count(f); log
count(e, f); lexical translation probability p(f|e) and p(elf)
(Koehn et al., 2003); indicator variable on singleton phrase e;
indicator variable on singleton phrase pair f, e; word penalty;
language model weight; OOV count of language model; num-
ber of untranslated words; Hiero glue rules (Chiang, 2007).
</footnote>
<page confidence="0.990712">
17
</page>
<table confidence="0.994779">
Alg. Tuning set Features #Feats devtest-ep test-ep Tuning set test-crawl10 test-crawl11
1 dev-ep default 12 25.62 26.42† dev-crawl 15.39† 14.43†
dev-ep +id,ng,shape 300k 27.84 28.37 dev-crawl 17.84 16.834
4 train-ep +id,ng,shape 100k 28.0 @9 28.62 train-ep 19.121 17.331
</table>
<tableCaption confidence="0.868137">
Table 3: BLEU-4 results for algorithms 1 (SGD) and 4 (IterSelSGD) on Europarl (ep) and news crawl (crawl) test
data. Feature groups are 12 dense features (default), rule identifiers (id), rule n-gram (ng), and rule shape (shape).
Statistical significance at p-level &lt; 0.05 of a result difference on the test set to a different algorithm applied to the
same feature group is indicated by raised algorithm number. † indicates statistically significant differences to best
result across features groups for same algorithm, indicated in bold face. @ indicates the optimal number of epochs
chosen on the devtest set.
</tableCaption>
<bodyText confidence="0.999978064516129">However, scaling all features to the full training set shows significant improvements for algorithm 3, and especially for algorithm 4, which gains 0.8 BLEU points over tuning 12 features on the development set. The number of features rises to 4.7 million without feature selection, which iteratively selects 100,000 features with best f2 norm values across shards. Feature templates such as rule n-grams and rule shapes only work if iterative mixing (algorithm 3) or feature selection (algorithm 4) are used. Adding rule id features works in combination with other sparse features. Table 3 shows results for algorithms 1 and 4 on the Europarl data (ep) for different devtest and test sets. Europarl data were used in all runs for training and for setting the meta-parameter of number of epochs. Testing was done on the Europarl test set and news crawl test data from the years 2010 and 2011. Here tuning large feature sets on the respective dev sets yields significant improvements of around 2 BLEU points over tuning the 12 default features on the dev sets. Another 0.5 BLEU points (test-crawl11) or even 1.3 BLEU points (testcrawl10) are gained when scaling to the full training set using iterative features selection. Result differences on the Europarl test set were not significant for moving from dev to full train set. Algorithms 2 and 3 were infeasible to run on Europarl data beyond one epoch because features vectors grew too large to be kept in memory.</bodyText>
<sectionHeader confidence="0.998975" genericHeader="result">
6 Discussion
</sectionHeader>
<bodyText confidence="0.99999188">We presented an approach to scaling discriminative learning for SMT not only to large feature sets but also to large sets of parallel training data. Since inference for SMT (unlike many other learning problems) is very expensive, especially on large training sets, good parallelization is key. Our approach is made feasible and effective by applying joint feature selection across distributed stochastic learning processes. Furthermore, our local features are efficiently computable at runtime. Our algorithms and features are generic and can easily be reimplemented and make our results relevant across datasets and language pairs. In future work, we would like to investigate more sophisticated features, better learners, and in general improve the components of our system that have been neglected in the current investigation of relative improvements by scaling the size of data and feature sets. Ultimately, since our algorithms are inspired by multi-task learning, we would like to apply them to scenarios where a natural definition of tasks is given. For example, patent data can be characterized along the dimensions of patent classes and patent text fields (W¨aschle and Riezler, 2012) and thus are well suited for multi-task translation.</bodyText>
<sectionHeader confidence="0.984413" genericHeader="acknowledgments">
Acknowledgments
</sectionHeader>
<bodyText confidence="0.999578333333333">Stefan Riezler and Patrick Simianer were supported in part by DFG grant “Cross-language Learning-toRank for Patent Retrieval”. Chris Dyer was supported in part by a MURI grant “The linguisticcore approach to structured translation and analysis of low-resource languages” from the US Army Research Office and a grant “Unsupervised Induction of Multi-Nonterminal Grammars for SMT” from Google, Inc.</bodyText>
<page confidence="0.998973">
18
</page>
<sectionHeader confidence="0.956118" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.997810152380952">
Phil Blunsom, Trevor Cohn, and Miles Osborne. 2008.
A discriminative latent variable models for statistical
machine translation. In Proceedings of the 46th An-
nual Meeting of the Association for Computational
Linguistics: Human Language Technologies (ACL-
HLT’08), Columbus, OH.
L´eon Bottou. 2004. Stochastic learning. In Olivier
Bousquet, Ulrike von Luxburg, and Gunnar R¨atsch,
editors, Advanced Lectures on Machine Learning,
pages 146–168. Springer, Berlin.
Olivier Chapelle and S. Sathiya Keerthi. 2010. Efficient
algorithms for ranking with SVMs. Information Re-
trieval Journal.
David Chiang, Yuval Marton, and Philip Resnik. 2008.
Online large-margin training of syntactic and struc-
tural translation features. In Proceedings of the 2008
Conference on Empirical Methods in Natural Lan-
guage Processing (EMNLP’08), Waikiki, Honolulu,
Hawaii.
David Chiang, Kevin Knight, and Wei Wang. 2009.
11,001 new features for statistical machine transla-
tion. In Proceedings of the 2009 Annual Confer-
ence of the North American Chapter of the Associa-
tion for Computational Linguistics (NAACL-HLT’09),
Boulder, CO.
David Chiang. 2005. A hierarchical phrase-based model
for statistical machine translation. In Proceedings of
the 43rd Annual Meeting of the Association for Com-
putational Linguistics (ACL’05), Ann Arbor, MI.
David Chiang. 2007. Hierarchical phrase-based transla-
tion. Computational Linguistics, 33(2).
Michael Collins. 2002. Discriminative training methods
for hidden markov models: theory and experiments
with perceptron algorithms. In Proceedings of the con-
ference on Empirical Methods in Natural Language
Processing (EMNLP’02), Philadelphia, PA.
Ronan Collobert and Samy Bengio. 2004. Links be-
tween perceptrons, MLPs, and SVMs. In Proceed-
ings of the 21st International Conference on Machine
Learning (ICML’04), Banff, Canada.
Jeffrey Dean and Sanjay Ghemawat. 2004. Mapre-
duce: Simplified data processing on large clusters. In
Proceedings of the 6th Symposium on Operating Sys-
tem Design and Implementation (OSDI’04), San Fran-
cisco, CA.
Kevin Duh and Katrin Kirchhoff. 2008. Beyond log-
linear models: Boosted minimum error rate training
for n-best ranking. In Proceedings of the 46th Annual
Meeting of the Association for Computational Linguis-
tics (ACL’08), Short Paper Track, Columbus, OH.
Kevin Duh, Katsuhito Sudoh, Hajime Tsukada, Hideki
Isozaki, and Masaaki Nagata. 2010. N-best reranking
by multitask learning. In Proceedings of the 5th Joint
Workshop on Statistical Machine Translation and Met-
ricsMATR, Uppsala, Sweden.
Chris Dyer, Adam Lopez, Juri Ganitkevitch, Jonathan
Weese, Ferhan Ture, Phil Blunsom, Hendra Setiawan,
Vladimir Eidelman, and Philip Resnik. 2010. cdec: A
decoder, alignment, and learning framework for finite-
state and context-free translation models. In Proceed-
ings of the ACL 2010 System Demonstrations, Upp-
sala, Sweden.
Chris Dyer, Kevin Gimpel, Jonathan H. Clark, and
Noah A. Smith. 2011. The CMU-ARK german-
english translation system. In Proceedings of the 6th
Workshop on Machine Translation (WMT11), Edin-
burgh, UK.
Chris Dyer. 2009. Using a maximum entropy model to
build segmentation lattices for MT. In Proceedings
of the Conference of the North American Chapter of
the Association for Computational Linguistics - Hu-
man Language Technologies (NAACL-HLT’09), Boul-
der, CO.
Yoav Freund and Robert E. Schapire. 1999. Large
margin classification using the perceptron algorithm.
Journal of Machine Learning Research, 37:277–296.
Kevin Gimpel and Noah A. Smith. 2012. Structured
ramp loss minimization for machine translation. In
Proceedings of 2012 Conference of the North Amer-
ican Chapter of the Association for Computational
Linguistics: Human Language Technologies (NAACL-
HLT 2012), Montreal, Canada.
Katsuhiko Hayashi, Taro Watanabe, Hajime Tsukada,
and Hideki Isozaki. 2009. Structural support vector
machines for log-linear approach in statistical machine
translation. In Proceedings of IWSLT, Tokyo, Japan.
Kenneth Heafield. 2011. KenLM: faster and smaller lan-
guage model queries. In Proceedings of the EMNLP
2011 Sixth Workshop on Statistical Machine Transla-
tion (WMT’11), Edinburgh, UK.
Mark Hopkins and Jonathan May. 2011. Tuning as
ranking. In Proceedings of 2011 Conference on
Empirical Methods in Natural Language Processing
(EMNLP’11), Edinburgh, Scotland.
Philipp Koehn, Franz Josef Och, and Daniel Marcu.
2003. Statistical phrase-based translation. In Proceed-
ings of the Human Language Technology Conference
and the 3rd Meeting of the North American Chapter of
the Association for Computational Linguistics (HLT-
NAACL’03), Edmonton, Cananda.
Shankar Kumar, Wolfgang Macherey, Chris Dyer, and
Franz Och. 2009. Efficient minimum error rate train-
ing and minimum Bayes-risk decoding for translation
hypergraphs and lattices. In Proceedings of the 47th
Annual Meeting of the Association for Computational
</reference>
<page confidence="0.997454">
19
</page>
<note confidence="0.501156">
Linguistics and the 4th IJCNLP of the AFNLP (ACL-
IJCNLP’09, Suntec, Singapore.
</note>
<reference confidence="0.998258742857143">
Thomas Navin Lal, Olivier Chapelle, Jason Weston, and
Andr´e Elisseeff. 2006. Embedded methods. In I.M.
Guyon, S.R. Gunn, M. Nikravesh, and L. Zadeh, ed-
itors, Feature Extraction: Foundations and Applica-
tions. Springer.
Percy Liang, Alexandre Bouchard-Cˆot´e, Dan Klein, and
Ben Taskar. 2006a. An end-to-end discriminative
approach to machine translation. In Proceedings of
the joint conference of the International Committee
on Computational Linguistics and the Association for
Computational Linguistics (COLING-ACL’06), Syd-
ney, Australia.
Percy Liang, Ben Taskar, and Dan Klein. 2006b. Align-
ment by agreement. In Proceedings of the Human
Language Technology Conference - North American
Chapter of the Association for Computational Linguis-
tics annual meeting (HLT-NAACL’06), New York, NY.
Adam Lopez. 2007. Hierarchical phrase-based transla-
tion with suffix arrays. In Proceedings of EMNLP-
CoNLL, Prague, Czech Republic.
David McAllester and Joseph Keshet. 2011. Generaliza-
tion bounds and consistency for latent structural pro-
bit and ramp loss. In Proceedings of the 25th Annual
Conference on Neural Information Processing Sytems
(NIPS 2011), Granada, Spain.
Ryan McDonald, Keith Hall, and Gideon Mann. 2010.
Distributed training strategies for the structured per-
ceptron. In Proceedings of Human Language Tech-
nologies: The 11th Annual Conference of the North
American Chapter of the Association for Compu-
tational Linguistics (NAACL-HLT’10), Los Angeles,
CA.
Eric W. Noreen. 1989. Computer Intensive Methods
for Testing Hypotheses. An Introduction. Wiley, New
York.
Guillaume Obozinski, Ben Taskar, and Michael I. Jordan.
2010. Joint covariate selection and joint subspace se-
lection for multiple classification problems. Statistics
and Computing, 20:231–252.
Franz Josef Och and Hermann Ney. 2000. Improved sta-
tistical alignment models. In Proceedings of the 38th
Annual Meeting of the Association for Computational
Linguistics (ACL’00), Hongkong, China.
Franz Josef Och and Hermann Ney. 2002. Discrimina-
tive training and maximum entropy models for statis-
tical machine translation. In Proceedings of the 40th
Annual Meeting of the Association for Computational
Linguistics (ACL’02), Philadelphia, PA.
Franz Josef Och. 2003. Minimum error rate train-
ing in statistical machine translation. In Proceedings
of the Human Language Technology Conference and
the 3rd Meeting of the North American Chapter of
the Association for Computational Linguistics (HLT-
NAACL’03), Edmonton, Cananda.
Kishore Papineni, Salim Roukos, Todd Ward, and Wei-
Jing Zhu. 2001. Bleu: a method for automatic
evaluation of machine translation. Technical Report
IBM Research Division Technical Report, RC22176
(W0190-022), Yorktown Heights, N.Y.
Simon Perkins, Kevin Lacker, and James Theiler. 2003.
Grafting: Fast, incremental feature selection by gra-
dient descent in function space. Journal of Machine
Learning Research, 3:1333–1356.
Stefan Riezler and John Maxwell. 2005. On some pit-
falls in automatic evaluation and significance testing
for MT. In Proceedings of the ACL-05 Workshop on
Intrinsic and Extrinsic Evaluation Measures for MT
and/or Summarization, Ann Arbor, MI.
Shai Shalev-Shwartz, Yoram Singer, and Nathan Sre-
bro. 2007. Pegasos: Primal Estimated sub-GrAdient
SOlver for SVM. In Proceedings of the 24th Inter-
national Conference on Machine Learning (ICML’07),
Corvallis, OR.
Libin Shen and Aravind K. Joshi. 2005. Ranking and
reranking with perceptron. Journal of Machine Learn-
ing Research, 60(1-3):73–96.
Libin Shen, Anoop Sarkar, and Franz Josef Och. 2004.
Discriminative reranking for machine translation. In
Proceedings of the Human Language Technology con-
ference / North American chapter of the Associa-
tion for Computational Linguistics annual meeting
(HLT/NAACL’04), Boston, MA.
Andreas Stolcke. 2002. SRILM - an extensible language
modeling toolkit. In Proceedings of the International
Conference on Spoken Language Processing, Denver,
CO.
Christoph Tillmann and Tong Zhang. 2006. A dis-
criminatie global training algorithm for statistical MT.
In Proceedings of the joint conference of the In-
ternational Committee on Computational Linguistics
and the Association for Computational Linguistics
(COLING-ACL’06), Sydney, Australia.
Katharina W¨aschle and Stefan Riezler. 2012. Structural
and topical dimensions in multi-task patent translation.
In Proceedings of the 13th Conference of the European
Chapter of the Association for Computational Linguis-
tics, Avignon, France.
Taro Watanabe, Jun Suzuki, Hajime Tsukada, and Hideki
Isozaki. 2006. NTT statistical machine translation
for IWSLT 2006. In Proceedings of the International
Workshop on Spoken Language Translation (IWSLT),
Kyoto, Japan.
Taro Watanabe, Jun Suzuki, Hajime Tsukada, and Hideki
Isozaki. 2007. Online large-margin training for statis-
tical machine translation. In Proceedings of the 2007
</reference>
<page confidence="0.902783">
20
</page>
<reference confidence="0.999246666666667">
Joint Conference on Empirical Mehtods in Natural
Language Processing and Computational Language
Learning (EMNLP’07), Prague, Czech Republic.
Benjamin Wellington, Joseph Turian, and Dan Melamed.
2009. Toward purely discriminative training for tree-
structured translation models. In Cyril Goutte, Nicola
Cancedda, and Marc Dymetman, editors, Learning
Machine Translation, pages 132–149, Cambridge,
MA. The MIT Press.
Martin A. Zinkevich, Markus Weimer, Alex Smola, and
Lihong Li. 2010. Parallelized stochastic gradient de-
scent. In Proceedings of the 24th Annual Conference
on Neural Information Processing Sytems (NIPS’10),
Vancouver, Canada.
Andreas Zollmann and Khalil Sima’an. 2005. A consis-
tent and efficient estimator for data-oriented parsing.
Journal of Automata, Languages and Combinatorics,
10(2/3):367–388.
</reference>
<page confidence="0.999437">
21
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant confidence="0.213078" no="0">
<title confidence="0.997905">Joint Feature Selection in Distributed Stochastic for Large-Scale Discriminative Training in SMT</title>
<author confidence="0.926637">Simianer</author>
<affiliation confidence="0.999424">Department of Computational</affiliation>
<address confidence="0.970063">Heidelberg 69120 Heidelberg,</address>
<author confidence="0.356758">Chris</author>
<affiliation confidence="0.787571">Language Technologies Carnegie Mellon</affiliation>
<address confidence="0.996975">Pittsburgh, PA, 15213,</address>
<email confidence="0.998581">cdyer@cs.cmu.edu</email>
<abstract confidence="0.999419473684211">With a few exceptions, discriminative training in statistical machine translation (SMT) has been content with tuning weights for large feature sets on small development data. Evidence from machine learning indicates that increasing the training sample size results in better prediction. The goal of this paper is to show that this common wisdom can also be brought to bear upon SMT. We deploy local features for SCFG-based SMT that can be read off from rules at runtime, and present a learnalgorithm that applies regularization for joint feature selection over distributed stochastic learning processes. We present experiments on learning on 1.5 million training sentences, and show significant improvements over tuning discriminative models on small development sets.</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>Phil Blunsom</author>
<author>Trevor Cohn</author>
<author>Miles Osborne</author>
</authors>
<title>A discriminative latent variable models for statistical machine translation.</title>
<date>2008</date>
<booktitle>In Proceedings of the 46th Annual Meeting of the Association for Computational Linguistics: Human Language Technologies (ACLHLT’08),</booktitle>
<location>Columbus, OH.</location>
<contexts>
<context citStr="Blunsom et al., 2008" endWordPosition="983" position="6457" startWordPosition="980">ous sizes on small development sets. Our software is freely available as a part of the cdec1 framework. 1https://github.com/redpony/cdec 2 Related Work The great promise of discriminative training for SMT is the possibility to design arbitrarily expressive, complex, or overlapping features in great numbers. The focus of many approaches thus has been on feature engineering and on adaptations of machine learning algorithms to the special case of SMT (where gold standard rankings have to be created automatically). Examples for adapted algorithms include Maximum-Entropy Models (Och and Ney, 2002; Blunsom et al., 2008), Pairwise Ranking Perceptrons (Shen et al., 2004; Watanabe et al., 2006; Hopkins and May, 2011), Structured Perceptrons (Liang et al., 2006a), Boosting (Duh and Kirchhoff, 2008; Wellington et al., 2009), Structured SVMs (Tillmann and Zhang, 2006; Hayashi et al., 2009), MIRA (Watanabe et al., 2007; Chiang et al., 2008; Chiang et al., 2009), and others. Adaptations of the loss functions underlying such algorithms to SMT have recently been described as particular forms of ramp loss optimization (McAllester and Keshet, 2011; Gimpel and Smith, 2012). All approaches have been shown to scale to larg</context>
</contexts>
<marker>Blunsom, Cohn, Osborne, 2008</marker>
<rawString>Phil Blunsom, Trevor Cohn, and Miles Osborne. 2008. A discriminative latent variable models for statistical machine translation. In Proceedings of the 46th Annual Meeting of the Association for Computational Linguistics: Human Language Technologies (ACLHLT’08), Columbus, OH.</rawString>
</citation>
<citation valid="true">
<authors>
<author>L´eon Bottou</author>
</authors>
<title>Stochastic learning.</title>
<date>2004</date>
<booktitle>Advanced Lectures on Machine Learning,</booktitle>
<pages>146--168</pages>
<editor>In Olivier Bousquet, Ulrike von Luxburg, and Gunnar R¨atsch, editors,</editor>
<publisher>Springer,</publisher>
<location>Berlin.</location>
<contexts>
<context citStr="Bottou, 2004" endWordPosition="1759" position="11008" startWordPosition="1758">cale scenarios. The algorithm takes an average over the final weight updates of each epoch instead of keeping a record of all weight updates for final averaging (Collins, 2002) or for voting (Freund and Schapire, 1999). Algorithm 1 SGD: int I, T, float 77 Initialize w0,0,0 F 0. for epochs t F 0 ... T − 1: do for all i E {0 ... I − 11: do Decode ith input with wt,i,0. for all pairs xj, j E {0 ... P// − 11: do wt,i,j+1 F wt,i,j − ηVlj(Wt,i,j) end for wt,i+1,0 F wt,i,P end for wt+1,0,0 F wt,I,0 end for return T1 While stochastic learning exhibits a runtime behavior that is linear in sample size (Bottou, 2004), very large datasets can make sequential processing infeasible. Algorithm 2 (MixSGD) addresses this problem by parallelization in the framework of MapReduce (Dean and Ghemawat, 2004). Algorithm 2 MixSGD: int I, T, Z, float 77 Partition data into Z shards, each of size S F I/Z; distribute to machines. for all shards z E {1 ... Z1: parallel do Initialize wz,0,0,0 F 0. for epochs t F 0 ... T − 1: do for all i E {0 ... S − 11: do Decode ith input with wz,t,i,0. for all pairs xj, j E {0 ... P −//11: do wz,t,i,j+1 F wz,t,i,j − ηvljlWz,t,i,j) end for wz,t,i+1,0 F wz,t,i,P end for wz,t+1,0,0 F wz,t,S</context>
</contexts>
<marker>Bottou, 2004</marker>
<rawString>L´eon Bottou. 2004. Stochastic learning. In Olivier Bousquet, Ulrike von Luxburg, and Gunnar R¨atsch, editors, Advanced Lectures on Machine Learning, pages 146–168. Springer, Berlin.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Olivier Chapelle</author>
<author>S Sathiya Keerthi</author>
</authors>
<title>Efficient algorithms for ranking with SVMs.</title>
<date>2010</date>
<journal>Information Retrieval Journal.</journal>
<contexts>
<context citStr="Chapelle and Keerthi, 2010" endWordPosition="1912" position="11840" startWordPosition="1909">int I, T, Z, float 77 Partition data into Z shards, each of size S F I/Z; distribute to machines. for all shards z E {1 ... Z1: parallel do Initialize wz,0,0,0 F 0. for epochs t F 0 ... T − 1: do for all i E {0 ... S − 11: do Decode ith input with wz,t,i,0. for all pairs xj, j E {0 ... P −//11: do wz,t,i,j+1 F wz,t,i,j − ηvljlWz,t,i,j) end for wz,t,i+1,0 F wz,t,i,P end for wz,t+1,0,0 F wz,t,S,0 end for end for Collect final weights from each machine, E 1 1T E wz,t,0,0J . z=1 t=1 3Other loss functions lead to stochastic versions of SVMs (Collobert and Bengio, 2004; Shalev-Shwartz et al., 2007; Chapelle and Keerthi, 2010). T E t=1 wt,0,0 return 1Z 13 Algorithm 2 is a variant of the SimuParallelSGD algorithm of Zinkevich et al. (2010) or equivalently of the parameter mixing algorithm of McDonald et al. (2010). The key idea of algorithm 2 is to partition the data into disjoint shards, then train SGD on each shard in parallel, and after training mix the final parameters from each shard by averaging. The algorithm requires no communication between machines until the end. McDonald et al. (2010) also present an iterative mixing algorithm where weights are mixed from each shard after training a single epoch of the pe</context>
</contexts>
<marker>Chapelle, Keerthi, 2010</marker>
<rawString>Olivier Chapelle and S. Sathiya Keerthi. 2010. Efficient algorithms for ranking with SVMs. Information Retrieval Journal.</rawString>
</citation>
<citation valid="true">
<authors>
<author>David Chiang</author>
<author>Yuval Marton</author>
<author>Philip Resnik</author>
</authors>
<title>Online large-margin training of syntactic and structural translation features.</title>
<date>2008</date>
<booktitle>In Proceedings of the 2008 Conference on Empirical Methods in Natural Language Processing (EMNLP’08),</booktitle>
<location>Waikiki, Honolulu, Hawaii.</location>
<contexts>
<context citStr="Chiang et al. (2008)" endWordPosition="422" position="2871" startWordPosition="419"> feature engineering for discriminative models have been presented (see Section 2), however, with a few exceptions, discriminative learning in SMT has been confined to training on small tuning sets of a few thousand examples. This contradicts theoretical and practical evidence from machine learning that suggests that larger training samples should be beneficial to improve prediction also in SMT. Why is this? One possible reason why discriminative SMT has mostly been content with small tuning sets lies in the particular design of the features themselves. For example, the features introduced by Chiang et al. (2008) and Chiang et al. (2009) for an SCFG model for Chinese/English translation are of two types: The first type explicitly counters overestimates of rule counts, or rules with bad overlap points, bad rewrites, or with undesired insertions of target-side terminals. These features are specified in handcrafted lists based on a thorough analysis of a tuning set. Such finely hand-crafted features will find sufficient statistical support on a few thousand examples and thus do not benefit from larger training sets. The second type of features deploys external information such as syntactic parses or word</context>
<context citStr="Chiang et al., 2008" endWordPosition="1033" position="6776" startWordPosition="1030"> many approaches thus has been on feature engineering and on adaptations of machine learning algorithms to the special case of SMT (where gold standard rankings have to be created automatically). Examples for adapted algorithms include Maximum-Entropy Models (Och and Ney, 2002; Blunsom et al., 2008), Pairwise Ranking Perceptrons (Shen et al., 2004; Watanabe et al., 2006; Hopkins and May, 2011), Structured Perceptrons (Liang et al., 2006a), Boosting (Duh and Kirchhoff, 2008; Wellington et al., 2009), Structured SVMs (Tillmann and Zhang, 2006; Hayashi et al., 2009), MIRA (Watanabe et al., 2007; Chiang et al., 2008; Chiang et al., 2009), and others. Adaptations of the loss functions underlying such algorithms to SMT have recently been described as particular forms of ramp loss optimization (McAllester and Keshet, 2011; Gimpel and Smith, 2012). All approaches have been shown to scale to large feature sets and all include some kind of regularization method. However, most approaches have been confined to training on small tuning sets. Exceptions where discriminative SMT has been used on large training data are Liang et al. (2006a) who trained 1.5 million features on 67,000 sentences, Blunsom et al. (2008) </context>
<context citStr="Chiang et al. (2008)" endWordPosition="3671" position="22162" startWordPosition="3668">ds to the dev set size of the nc data set. 5.2 Experimental Results The baseline learner in our experiments is a pairwise ranking perceptron that is used on various features and training data and plugged into various metaM X BLEU[%] 23.0 25.0 27.0 29.0 Figure 4: Boxplot of BLEU-4 results for 100 runs of MIRA on news commentary data, depicting median (M), mean (x), interquartile range (box), standard deviation (whiskers), outliers (end points). algorithms for distributed processing. The perceptron algorithm itself compares favorably to related learning techniques such as the MIRA adaptation of Chiang et al. (2008). Figure 4 gives a boxplot depicting BLEU-4 results for 100 runs of the MIRA implementation of the cdec package, tuned on dev-nc, and evaluated on the respective test set test-nc.6 We see a high variance (whiskers denote standard deviations) around a median of 27.2 BLEU and a mean of 27.1 BLEU. The fluctuation of results is due to sampling training examples from the translation hy6MIRA was used with default meta parameters: 250 hypothesis list to search for oracles, regularization strength C = 0.01 and using 15 passes over the input. It optimized IBM BLEU-4. The initial weight vector was 0. 16</context>
</contexts>
<marker>Chiang, Marton, Resnik, 2008</marker>
<rawString>David Chiang, Yuval Marton, and Philip Resnik. 2008. Online large-margin training of syntactic and structural translation features. In Proceedings of the 2008 Conference on Empirical Methods in Natural Language Processing (EMNLP’08), Waikiki, Honolulu, Hawaii.</rawString>
</citation>
<citation valid="true">
<authors>
<author>David Chiang</author>
<author>Kevin Knight</author>
<author>Wei Wang</author>
</authors>
<title>11,001 new features for statistical machine translation.</title>
<date>2009</date>
<booktitle>In Proceedings of the 2009 Annual Conference of the North American Chapter of the Association for Computational Linguistics (NAACL-HLT’09),</booktitle>
<location>Boulder, CO.</location>
<contexts>
<context citStr="Chiang et al. (2009)" endWordPosition="427" position="2896" startWordPosition="424">discriminative models have been presented (see Section 2), however, with a few exceptions, discriminative learning in SMT has been confined to training on small tuning sets of a few thousand examples. This contradicts theoretical and practical evidence from machine learning that suggests that larger training samples should be beneficial to improve prediction also in SMT. Why is this? One possible reason why discriminative SMT has mostly been content with small tuning sets lies in the particular design of the features themselves. For example, the features introduced by Chiang et al. (2008) and Chiang et al. (2009) for an SCFG model for Chinese/English translation are of two types: The first type explicitly counters overestimates of rule counts, or rules with bad overlap points, bad rewrites, or with undesired insertions of target-side terminals. These features are specified in handcrafted lists based on a thorough analysis of a tuning set. Such finely hand-crafted features will find sufficient statistical support on a few thousand examples and thus do not benefit from larger training sets. The second type of features deploys external information such as syntactic parses or word alignments to penalize b</context>
<context citStr="Chiang et al., 2009" endWordPosition="1037" position="6798" startWordPosition="1034"> has been on feature engineering and on adaptations of machine learning algorithms to the special case of SMT (where gold standard rankings have to be created automatically). Examples for adapted algorithms include Maximum-Entropy Models (Och and Ney, 2002; Blunsom et al., 2008), Pairwise Ranking Perceptrons (Shen et al., 2004; Watanabe et al., 2006; Hopkins and May, 2011), Structured Perceptrons (Liang et al., 2006a), Boosting (Duh and Kirchhoff, 2008; Wellington et al., 2009), Structured SVMs (Tillmann and Zhang, 2006; Hayashi et al., 2009), MIRA (Watanabe et al., 2007; Chiang et al., 2008; Chiang et al., 2009), and others. Adaptations of the loss functions underlying such algorithms to SMT have recently been described as particular forms of ramp loss optimization (McAllester and Keshet, 2011; Gimpel and Smith, 2012). All approaches have been shown to scale to large feature sets and all include some kind of regularization method. However, most approaches have been confined to training on small tuning sets. Exceptions where discriminative SMT has been used on large training data are Liang et al. (2006a) who trained 1.5 million features on 67,000 sentences, Blunsom et al. (2008) who trained 7.8 millio</context>
</contexts>
<marker>Chiang, Knight, Wang, 2009</marker>
<rawString>David Chiang, Kevin Knight, and Wei Wang. 2009. 11,001 new features for statistical machine translation. In Proceedings of the 2009 Annual Conference of the North American Chapter of the Association for Computational Linguistics (NAACL-HLT’09), Boulder, CO.</rawString>
</citation>
<citation valid="true">
<authors>
<author>David Chiang</author>
</authors>
<title>A hierarchical phrase-based model for statistical machine translation.</title>
<date>2005</date>
<booktitle>In Proceedings of the 43rd Annual Meeting of the Association for Computational Linguistics (ACL’05),</booktitle>
<location>Ann Arbor, MI.</location>
<contexts>
<context citStr="Chiang, 2005" endWordPosition="1228" position="8002" startWordPosition="1227">8 million rules on 100,000 sentences, or Tillmann and Zhang (2006) who used 230,000 sentences for training. Our approach is inspired by Duh et al. (2010) who applied multi-task learning for improved generalization in n-best reranking. In contrast to our work, Duh et al. (2010) did not incorporate multitask learning into distributed learning, but defined tasks as n-best lists, nor did they develop new algorithms, but used off-the-shelf multi-task tools. 3 Local Features for Synchronous CFGs The work described in this paper is based on the SMT framework of hierarchical phrase-based translation (Chiang, 2005; Chiang, 2007). Translation rules are extracted from word-aligned parallel sentences and can be seen as productions of a synchronous CFG. Examples are rules like (1)-(3) 12 shown in Figure 1. Local features are designed to be readable directly off the rule at decoding time. We use three rule templates in our work: Rule identifiers: These features identify each rule by a unique identifier. Such features correspond to the relative frequencies of rewrites rules used in standard models. Rule n-grams: These features identify n-grams of consecutive items in a rule. We use bigrams on source-sides of</context>
</contexts>
<marker>Chiang, 2005</marker>
<rawString>David Chiang. 2005. A hierarchical phrase-based model for statistical machine translation. In Proceedings of the 43rd Annual Meeting of the Association for Computational Linguistics (ACL’05), Ann Arbor, MI.</rawString>
</citation>
<citation valid="true">
<authors>
<author>David Chiang</author>
</authors>
<title>Hierarchical phrase-based translation.</title>
<date>2007</date>
<journal>Computational Linguistics,</journal>
<volume>33</volume>
<issue>2</issue>
<contexts>
<context citStr="Chiang, 2007" endWordPosition="1230" position="8017" startWordPosition="1229">s on 100,000 sentences, or Tillmann and Zhang (2006) who used 230,000 sentences for training. Our approach is inspired by Duh et al. (2010) who applied multi-task learning for improved generalization in n-best reranking. In contrast to our work, Duh et al. (2010) did not incorporate multitask learning into distributed learning, but defined tasks as n-best lists, nor did they develop new algorithms, but used off-the-shelf multi-task tools. 3 Local Features for Synchronous CFGs The work described in this paper is based on the SMT framework of hierarchical phrase-based translation (Chiang, 2005; Chiang, 2007). Translation rules are extracted from word-aligned parallel sentences and can be seen as productions of a synchronous CFG. Examples are rules like (1)-(3) 12 shown in Figure 1. Local features are designed to be readable directly off the rule at decoding time. We use three rule templates in our work: Rule identifiers: These features identify each rule by a unique identifier. Such features correspond to the relative frequencies of rewrites rules used in standard models. Rule n-grams: These features identify n-grams of consecutive items in a rule. We use bigrams on source-sides of rules. Such fe</context>
<context citStr="Chiang, 2007" endWordPosition="2889" position="17148" startWordPosition="2888">FE) (Lal et al., 2006). Furthermore, algorithm 4 performs feature selection based on a choice of meta-parameter of K features instead of by thresholding a regularization meta-parameter A, however, these techniques are equivalent and can be transformed into each other. 5 Experiments 5.1 Data, Systems, Experiment Settings The datasets used in our experiments are versions of the News Commentary (nc), News Crawl (crawl) and Europarl (ep) corpora described in Table 1. The translation direction is German-to-English. The SMT framework used in our experiments is hierarchical phrase-based translation (Chiang, 2007). We use the cdec decoder5 (Dyer et al., 2010) and induce SCFG grammars from two sets of symmetrized alignments using the method described by Chiang (2007). All data was tokenized and lowercased; German compounds were split (Dyer, 2009). For word alignment of the news-commentary data, we used GIZA++ (Och and Ney, 2000); for aligning the Europarl data, we used the Berkeley aligner (Liang et al., 2006b). Before training, we collect all the grammar rules necessary to 4Note that by definition of ||W||1,2, standard f1 regularization is a special case of f1/f2 regularization for a single task. 5cdec</context>
<context citStr="Chiang, 2007" endWordPosition="4276" position="25890" startWordPosition="4275">ero weight vector, using deduplicated 100-best lists. The results on the news-commentary (nc) data show that training on the development set does not benefit from adding large feature sets – BLEU result differences between tuning 12 default features 8negative log relative frequency p(elf); log count(f); log count(e, f); lexical translation probability p(f|e) and p(elf) (Koehn et al., 2003); indicator variable on singleton phrase e; indicator variable on singleton phrase pair f, e; word penalty; language model weight; OOV count of language model; number of untranslated words; Hiero glue rules (Chiang, 2007). 17 Alg. Tuning set Features #Feats devtest-ep test-ep Tuning set test-crawl10 test-crawl11 1 dev-ep default 12 25.62 26.42† dev-crawl 15.39† 14.43† dev-ep +id,ng,shape 300k 27.84 28.37 dev-crawl 17.84 16.834 4 train-ep +id,ng,shape 100k 28.0 @9 28.62 train-ep 19.121 17.331 Table 3: BLEU-4 results for algorithms 1 (SGD) and 4 (IterSelSGD) on Europarl (ep) and news crawl (crawl) test data. Feature groups are 12 dense features (default), rule identifiers (id), rule n-gram (ng), and rule shape (shape). Statistical significance at p-level &lt; 0.05 of a result difference on the test set to a differe</context>
</contexts>
<marker>Chiang, 2007</marker>
<rawString>David Chiang. 2007. Hierarchical phrase-based translation. Computational Linguistics, 33(2).</rawString>
</citation>
<citation valid="true">
<authors>
<author>Michael Collins</author>
</authors>
<title>Discriminative training methods for hidden markov models: theory and experiments with perceptron algorithms.</title>
<date>2002</date>
<booktitle>In Proceedings of the conference on Empirical Methods in Natural Language Processing (EMNLP’02),</booktitle>
<location>Philadelphia, PA.</location>
<contexts>
<context citStr="Collins, 2002" endWordPosition="1668" position="10571" startWordPosition="1667"> (w, ¯xj ))+ where (a)+ = max(0, a) , w E IRD is a weight vector, and (·, ·) denotes the standard vector dot product. Instantiating SGD to the following stochastic 2Similar “monolingual parse features” have been used in Dyer et al. (2011). subgradient leads to the perceptron algorithm for pairwise ranking3 (Shen and Joshi, 2005): � −¯xj if (w, ¯xj) G 0, �lj(w) = 0 else. Our baseline algorithm 1 (SDG) scales pairwise ranking to large scale scenarios. The algorithm takes an average over the final weight updates of each epoch instead of keeping a record of all weight updates for final averaging (Collins, 2002) or for voting (Freund and Schapire, 1999). Algorithm 1 SGD: int I, T, float 77 Initialize w0,0,0 F 0. for epochs t F 0 ... T − 1: do for all i E {0 ... I − 11: do Decode ith input with wt,i,0. for all pairs xj, j E {0 ... P// − 11: do wt,i,j+1 F wt,i,j − ηVlj(Wt,i,j) end for wt,i+1,0 F wt,i,P end for wt+1,0,0 F wt,I,0 end for return T1 While stochastic learning exhibits a runtime behavior that is linear in sample size (Bottou, 2004), very large datasets can make sequential processing infeasible. Algorithm 2 (MixSGD) addresses this problem by parallelization in the framework of MapReduce (Dean</context>
</contexts>
<marker>Collins, 2002</marker>
<rawString>Michael Collins. 2002. Discriminative training methods for hidden markov models: theory and experiments with perceptron algorithms. In Proceedings of the conference on Empirical Methods in Natural Language Processing (EMNLP’02), Philadelphia, PA.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Ronan Collobert</author>
<author>Samy Bengio</author>
</authors>
<title>Links between perceptrons, MLPs, and SVMs.</title>
<date>2004</date>
<booktitle>In Proceedings of the 21st International Conference on Machine Learning (ICML’04),</booktitle>
<location>Banff, Canada.</location>
<contexts>
<context citStr="Collobert and Bengio, 2004" endWordPosition="1904" position="11782" startWordPosition="1901">MapReduce (Dean and Ghemawat, 2004). Algorithm 2 MixSGD: int I, T, Z, float 77 Partition data into Z shards, each of size S F I/Z; distribute to machines. for all shards z E {1 ... Z1: parallel do Initialize wz,0,0,0 F 0. for epochs t F 0 ... T − 1: do for all i E {0 ... S − 11: do Decode ith input with wz,t,i,0. for all pairs xj, j E {0 ... P −//11: do wz,t,i,j+1 F wz,t,i,j − ηvljlWz,t,i,j) end for wz,t,i+1,0 F wz,t,i,P end for wz,t+1,0,0 F wz,t,S,0 end for end for Collect final weights from each machine, E 1 1T E wz,t,0,0J . z=1 t=1 3Other loss functions lead to stochastic versions of SVMs (Collobert and Bengio, 2004; Shalev-Shwartz et al., 2007; Chapelle and Keerthi, 2010). T E t=1 wt,0,0 return 1Z 13 Algorithm 2 is a variant of the SimuParallelSGD algorithm of Zinkevich et al. (2010) or equivalently of the parameter mixing algorithm of McDonald et al. (2010). The key idea of algorithm 2 is to partition the data into disjoint shards, then train SGD on each shard in parallel, and after training mix the final parameters from each shard by averaging. The algorithm requires no communication between machines until the end. McDonald et al. (2010) also present an iterative mixing algorithm where weights are mix</context>
</contexts>
<marker>Collobert, Bengio, 2004</marker>
<rawString>Ronan Collobert and Samy Bengio. 2004. Links between perceptrons, MLPs, and SVMs. In Proceedings of the 21st International Conference on Machine Learning (ICML’04), Banff, Canada.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Jeffrey Dean</author>
<author>Sanjay Ghemawat</author>
</authors>
<title>Mapreduce: Simplified data processing on large clusters.</title>
<date>2004</date>
<booktitle>In Proceedings of the 6th Symposium on Operating System Design and Implementation (OSDI’04),</booktitle>
<location>San Francisco, CA.</location>
<contexts>
<context citStr="Dean and Ghemawat, 2004" endWordPosition="1785" position="11191" startWordPosition="1782">002) or for voting (Freund and Schapire, 1999). Algorithm 1 SGD: int I, T, float 77 Initialize w0,0,0 F 0. for epochs t F 0 ... T − 1: do for all i E {0 ... I − 11: do Decode ith input with wt,i,0. for all pairs xj, j E {0 ... P// − 11: do wt,i,j+1 F wt,i,j − ηVlj(Wt,i,j) end for wt,i+1,0 F wt,i,P end for wt+1,0,0 F wt,I,0 end for return T1 While stochastic learning exhibits a runtime behavior that is linear in sample size (Bottou, 2004), very large datasets can make sequential processing infeasible. Algorithm 2 (MixSGD) addresses this problem by parallelization in the framework of MapReduce (Dean and Ghemawat, 2004). Algorithm 2 MixSGD: int I, T, Z, float 77 Partition data into Z shards, each of size S F I/Z; distribute to machines. for all shards z E {1 ... Z1: parallel do Initialize wz,0,0,0 F 0. for epochs t F 0 ... T − 1: do for all i E {0 ... S − 11: do Decode ith input with wz,t,i,0. for all pairs xj, j E {0 ... P −//11: do wz,t,i,j+1 F wz,t,i,j − ηvljlWz,t,i,j) end for wz,t,i+1,0 F wz,t,i,P end for wz,t+1,0,0 F wz,t,S,0 end for end for Collect final weights from each machine, E 1 1T E wz,t,0,0J . z=1 t=1 3Other loss functions lead to stochastic versions of SVMs (Collobert and Bengio, 2004; Shalev-</context>
</contexts>
<marker>Dean, Ghemawat, 2004</marker>
<rawString>Jeffrey Dean and Sanjay Ghemawat. 2004. Mapreduce: Simplified data processing on large clusters. In Proceedings of the 6th Symposium on Operating System Design and Implementation (OSDI’04), San Francisco, CA.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Kevin Duh</author>
<author>Katrin Kirchhoff</author>
</authors>
<title>Beyond loglinear models: Boosted minimum error rate training for n-best ranking.</title>
<date>2008</date>
<booktitle>In Proceedings of the 46th Annual Meeting of the Association for Computational Linguistics (ACL’08), Short Paper Track,</booktitle>
<location>Columbus, OH.</location>
<contexts>
<context citStr="Duh and Kirchhoff, 2008" endWordPosition="1010" position="6634" startWordPosition="1007">scriminative training for SMT is the possibility to design arbitrarily expressive, complex, or overlapping features in great numbers. The focus of many approaches thus has been on feature engineering and on adaptations of machine learning algorithms to the special case of SMT (where gold standard rankings have to be created automatically). Examples for adapted algorithms include Maximum-Entropy Models (Och and Ney, 2002; Blunsom et al., 2008), Pairwise Ranking Perceptrons (Shen et al., 2004; Watanabe et al., 2006; Hopkins and May, 2011), Structured Perceptrons (Liang et al., 2006a), Boosting (Duh and Kirchhoff, 2008; Wellington et al., 2009), Structured SVMs (Tillmann and Zhang, 2006; Hayashi et al., 2009), MIRA (Watanabe et al., 2007; Chiang et al., 2008; Chiang et al., 2009), and others. Adaptations of the loss functions underlying such algorithms to SMT have recently been described as particular forms of ramp loss optimization (McAllester and Keshet, 2011; Gimpel and Smith, 2012). All approaches have been shown to scale to large feature sets and all include some kind of regularization method. However, most approaches have been confined to training on small tuning sets. Exceptions where discriminative </context>
</contexts>
<marker>Duh, Kirchhoff, 2008</marker>
<rawString>Kevin Duh and Katrin Kirchhoff. 2008. Beyond loglinear models: Boosted minimum error rate training for n-best ranking. In Proceedings of the 46th Annual Meeting of the Association for Computational Linguistics (ACL’08), Short Paper Track, Columbus, OH.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Kevin Duh</author>
<author>Katsuhito Sudoh</author>
<author>Hajime Tsukada</author>
<author>Hideki Isozaki</author>
<author>Masaaki Nagata</author>
</authors>
<title>N-best reranking by multitask learning.</title>
<date>2010</date>
<booktitle>In Proceedings of the 5th Joint Workshop on Statistical Machine Translation and MetricsMATR,</booktitle>
<location>Uppsala, Sweden.</location>
<contexts>
<context citStr="Duh et al. (2010)" endWordPosition="1156" position="7543" startWordPosition="1153">ms of ramp loss optimization (McAllester and Keshet, 2011; Gimpel and Smith, 2012). All approaches have been shown to scale to large feature sets and all include some kind of regularization method. However, most approaches have been confined to training on small tuning sets. Exceptions where discriminative SMT has been used on large training data are Liang et al. (2006a) who trained 1.5 million features on 67,000 sentences, Blunsom et al. (2008) who trained 7.8 million rules on 100,000 sentences, or Tillmann and Zhang (2006) who used 230,000 sentences for training. Our approach is inspired by Duh et al. (2010) who applied multi-task learning for improved generalization in n-best reranking. In contrast to our work, Duh et al. (2010) did not incorporate multitask learning into distributed learning, but defined tasks as n-best lists, nor did they develop new algorithms, but used off-the-shelf multi-task tools. 3 Local Features for Synchronous CFGs The work described in this paper is based on the SMT framework of hierarchical phrase-based translation (Chiang, 2005; Chiang, 2007). Translation rules are extracted from word-aligned parallel sentences and can be seen as productions of a synchronous CFG. Ex</context>
</contexts>
<marker>Duh, Sudoh, Tsukada, Isozaki, Nagata, 2010</marker>
<rawString>Kevin Duh, Katsuhito Sudoh, Hajime Tsukada, Hideki Isozaki, and Masaaki Nagata. 2010. N-best reranking by multitask learning. In Proceedings of the 5th Joint Workshop on Statistical Machine Translation and MetricsMATR, Uppsala, Sweden.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Chris Dyer</author>
<author>Adam Lopez</author>
<author>Juri Ganitkevitch</author>
<author>Jonathan Weese</author>
<author>Ferhan Ture</author>
<author>Phil Blunsom</author>
<author>Hendra Setiawan</author>
<author>Vladimir Eidelman</author>
<author>Philip Resnik</author>
</authors>
<title>cdec: A decoder, alignment, and learning framework for finitestate and context-free translation models.</title>
<date>2010</date>
<booktitle>In Proceedings of the ACL 2010 System Demonstrations,</booktitle>
<location>Uppsala,</location>
<contexts>
<context citStr="Dyer et al., 2010" endWordPosition="2898" position="17194" startWordPosition="2895">rithm 4 performs feature selection based on a choice of meta-parameter of K features instead of by thresholding a regularization meta-parameter A, however, these techniques are equivalent and can be transformed into each other. 5 Experiments 5.1 Data, Systems, Experiment Settings The datasets used in our experiments are versions of the News Commentary (nc), News Crawl (crawl) and Europarl (ep) corpora described in Table 1. The translation direction is German-to-English. The SMT framework used in our experiments is hierarchical phrase-based translation (Chiang, 2007). We use the cdec decoder5 (Dyer et al., 2010) and induce SCFG grammars from two sets of symmetrized alignments using the method described by Chiang (2007). All data was tokenized and lowercased; German compounds were split (Dyer, 2009). For word alignment of the news-commentary data, we used GIZA++ (Och and Ney, 2000); for aligning the Europarl data, we used the Berkeley aligner (Liang et al., 2006b). Before training, we collect all the grammar rules necessary to 4Note that by definition of ||W||1,2, standard f1 regularization is a special case of f1/f2 regularization for a single task. 5cdec metaparameters were set to a non-terminal spa</context>
</contexts>
<marker>Dyer, Lopez, Ganitkevitch, Weese, Ture, Blunsom, Setiawan, Eidelman, Resnik, 2010</marker>
<rawString>Chris Dyer, Adam Lopez, Juri Ganitkevitch, Jonathan Weese, Ferhan Ture, Phil Blunsom, Hendra Setiawan, Vladimir Eidelman, and Philip Resnik. 2010. cdec: A decoder, alignment, and learning framework for finitestate and context-free translation models. In Proceedings of the ACL 2010 System Demonstrations, Uppsala, Sweden.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Chris Dyer</author>
<author>Kevin Gimpel</author>
<author>Jonathan H Clark</author>
<author>Noah A Smith</author>
</authors>
<title>The CMU-ARK germanenglish translation system.</title>
<date>2011</date>
<booktitle>In Proceedings of the 6th Workshop on Machine Translation (WMT11),</booktitle>
<location>Edinburgh, UK.</location>
<contexts>
<context citStr="Dyer et al. (2011)" endWordPosition="1604" position="10195" startWordPosition="1601">ed by a feature vector x E IRD where preference pairs for training are prepared by sorting translations according to smoothed sentence-wise BLEU score (Liang et al., 2006a) against the reference. For a preference pair xj = (x(1) j , xj 2)) where x(1) j is preferred over x(2) j , and ¯xj = x(1) j − x(2) j , we consider the following hinge loss-type objective function: lj(w) = (− (w, ¯xj ))+ where (a)+ = max(0, a) , w E IRD is a weight vector, and (·, ·) denotes the standard vector dot product. Instantiating SGD to the following stochastic 2Similar “monolingual parse features” have been used in Dyer et al. (2011). subgradient leads to the perceptron algorithm for pairwise ranking3 (Shen and Joshi, 2005): � −¯xj if (w, ¯xj) G 0, �lj(w) = 0 else. Our baseline algorithm 1 (SDG) scales pairwise ranking to large scale scenarios. The algorithm takes an average over the final weight updates of each epoch instead of keeping a record of all weight updates for final averaging (Collins, 2002) or for voting (Freund and Schapire, 1999). Algorithm 1 SGD: int I, T, float 77 Initialize w0,0,0 F 0. for epochs t F 0 ... T − 1: do for all i E {0 ... I − 11: do Decode ith input with wt,i,0. for all pairs xj, j E {0 ... P</context>
<context citStr="Dyer et al. (2011)" endWordPosition="4124" position="24929" startWordPosition="4121">epend on hypergraph sampling. In contrast, the perceptron is deterministic when started from a zero-vector of weights and achieves favorable 28.0 BLEU on the news-commentary test set. Since we are interested in relative improvements over a stable baseline, we restrict our attention in all following experiments to the perceptron.7 Table 2 shows the results of the experimental comparison of the 4 algorithms of Section 4. The 7Absolute improvements would be possible, e.g., by using larger language models or by adding news data to the ep training set when evaluating on crawl test sets (see, e.g., Dyer et al. (2011)), however, this is not the focus of this paper. default features include 12 dense models defined on SCFG rules;8 The sparse features are the 3 templates described in Section 3. All feature weights were tuned together using algorithms 1-4. If not indicated otherwise, the perceptron was run for 10 epochs with learning rate q = 0.0001, started at zero weight vector, using deduplicated 100-best lists. The results on the news-commentary (nc) data show that training on the development set does not benefit from adding large feature sets – BLEU result differences between tuning 12 default features 8n</context>
</contexts>
<marker>Dyer, Gimpel, Clark, Smith, 2011</marker>
<rawString>Chris Dyer, Kevin Gimpel, Jonathan H. Clark, and Noah A. Smith. 2011. The CMU-ARK germanenglish translation system. In Proceedings of the 6th Workshop on Machine Translation (WMT11), Edinburgh, UK.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Chris Dyer</author>
</authors>
<title>Using a maximum entropy model to build segmentation lattices for MT.</title>
<date>2009</date>
<booktitle>In Proceedings of the Conference of the North American Chapter of the Association for Computational Linguistics - Human Language Technologies (NAACL-HLT’09),</booktitle>
<location>Boulder, CO.</location>
<contexts>
<context citStr="Dyer, 2009" endWordPosition="2927" position="17384" startWordPosition="2926">e transformed into each other. 5 Experiments 5.1 Data, Systems, Experiment Settings The datasets used in our experiments are versions of the News Commentary (nc), News Crawl (crawl) and Europarl (ep) corpora described in Table 1. The translation direction is German-to-English. The SMT framework used in our experiments is hierarchical phrase-based translation (Chiang, 2007). We use the cdec decoder5 (Dyer et al., 2010) and induce SCFG grammars from two sets of symmetrized alignments using the method described by Chiang (2007). All data was tokenized and lowercased; German compounds were split (Dyer, 2009). For word alignment of the news-commentary data, we used GIZA++ (Och and Ney, 2000); for aligning the Europarl data, we used the Berkeley aligner (Liang et al., 2006b). Before training, we collect all the grammar rules necessary to 4Note that by definition of ||W||1,2, standard f1 regularization is a special case of f1/f2 regularization for a single task. 5cdec metaparameters were set to a non-terminal span limit of 15 and standard cube pruning with a pop limit of 200. translate each individual sentence into separate files (so-called per-sentence grammars) (Lopez, 2007). When decoding, cdec l</context>
</contexts>
<marker>Dyer, 2009</marker>
<rawString>Chris Dyer. 2009. Using a maximum entropy model to build segmentation lattices for MT. In Proceedings of the Conference of the North American Chapter of the Association for Computational Linguistics - Human Language Technologies (NAACL-HLT’09), Boulder, CO.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Yoav Freund</author>
<author>Robert E Schapire</author>
</authors>
<title>Large margin classification using the perceptron algorithm.</title>
<date>1999</date>
<journal>Journal of Machine Learning Research,</journal>
<pages>37--277</pages>
<contexts>
<context citStr="Freund and Schapire, 1999" endWordPosition="1675" position="10613" startWordPosition="1672">0, a) , w E IRD is a weight vector, and (·, ·) denotes the standard vector dot product. Instantiating SGD to the following stochastic 2Similar “monolingual parse features” have been used in Dyer et al. (2011). subgradient leads to the perceptron algorithm for pairwise ranking3 (Shen and Joshi, 2005): � −¯xj if (w, ¯xj) G 0, �lj(w) = 0 else. Our baseline algorithm 1 (SDG) scales pairwise ranking to large scale scenarios. The algorithm takes an average over the final weight updates of each epoch instead of keeping a record of all weight updates for final averaging (Collins, 2002) or for voting (Freund and Schapire, 1999). Algorithm 1 SGD: int I, T, float 77 Initialize w0,0,0 F 0. for epochs t F 0 ... T − 1: do for all i E {0 ... I − 11: do Decode ith input with wt,i,0. for all pairs xj, j E {0 ... P// − 11: do wt,i,j+1 F wt,i,j − ηVlj(Wt,i,j) end for wt,i+1,0 F wt,i,P end for wt+1,0,0 F wt,I,0 end for return T1 While stochastic learning exhibits a runtime behavior that is linear in sample size (Bottou, 2004), very large datasets can make sequential processing infeasible. Algorithm 2 (MixSGD) addresses this problem by parallelization in the framework of MapReduce (Dean and Ghemawat, 2004). Algorithm 2 MixSGD: </context>
</contexts>
<marker>Freund, Schapire, 1999</marker>
<rawString>Yoav Freund and Robert E. Schapire. 1999. Large margin classification using the perceptron algorithm. Journal of Machine Learning Research, 37:277–296.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Kevin Gimpel</author>
<author>Noah A Smith</author>
</authors>
<title>Structured ramp loss minimization for machine translation.</title>
<date>2012</date>
<booktitle>In Proceedings of 2012 Conference of the North American Chapter of the Association for Computational Linguistics: Human Language Technologies (NAACLHLT 2012),</booktitle>
<location>Montreal, Canada.</location>
<contexts>
<context citStr="Gimpel and Smith, 2012" endWordPosition="1068" position="7008" startWordPosition="1065">include Maximum-Entropy Models (Och and Ney, 2002; Blunsom et al., 2008), Pairwise Ranking Perceptrons (Shen et al., 2004; Watanabe et al., 2006; Hopkins and May, 2011), Structured Perceptrons (Liang et al., 2006a), Boosting (Duh and Kirchhoff, 2008; Wellington et al., 2009), Structured SVMs (Tillmann and Zhang, 2006; Hayashi et al., 2009), MIRA (Watanabe et al., 2007; Chiang et al., 2008; Chiang et al., 2009), and others. Adaptations of the loss functions underlying such algorithms to SMT have recently been described as particular forms of ramp loss optimization (McAllester and Keshet, 2011; Gimpel and Smith, 2012). All approaches have been shown to scale to large feature sets and all include some kind of regularization method. However, most approaches have been confined to training on small tuning sets. Exceptions where discriminative SMT has been used on large training data are Liang et al. (2006a) who trained 1.5 million features on 67,000 sentences, Blunsom et al. (2008) who trained 7.8 million rules on 100,000 sentences, or Tillmann and Zhang (2006) who used 230,000 sentences for training. Our approach is inspired by Duh et al. (2010) who applied multi-task learning for improved generalization in n</context>
</contexts>
<marker>Gimpel, Smith, 2012</marker>
<rawString>Kevin Gimpel and Noah A. Smith. 2012. Structured ramp loss minimization for machine translation. In Proceedings of 2012 Conference of the North American Chapter of the Association for Computational Linguistics: Human Language Technologies (NAACLHLT 2012), Montreal, Canada.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Katsuhiko Hayashi</author>
<author>Taro Watanabe</author>
<author>Hajime Tsukada</author>
<author>Hideki Isozaki</author>
</authors>
<title>Structural support vector machines for log-linear approach in statistical machine translation.</title>
<date>2009</date>
<booktitle>In Proceedings of IWSLT,</booktitle>
<location>Tokyo, Japan.</location>
<contexts>
<context citStr="Hayashi et al., 2009" endWordPosition="1024" position="6726" startWordPosition="1021"> overlapping features in great numbers. The focus of many approaches thus has been on feature engineering and on adaptations of machine learning algorithms to the special case of SMT (where gold standard rankings have to be created automatically). Examples for adapted algorithms include Maximum-Entropy Models (Och and Ney, 2002; Blunsom et al., 2008), Pairwise Ranking Perceptrons (Shen et al., 2004; Watanabe et al., 2006; Hopkins and May, 2011), Structured Perceptrons (Liang et al., 2006a), Boosting (Duh and Kirchhoff, 2008; Wellington et al., 2009), Structured SVMs (Tillmann and Zhang, 2006; Hayashi et al., 2009), MIRA (Watanabe et al., 2007; Chiang et al., 2008; Chiang et al., 2009), and others. Adaptations of the loss functions underlying such algorithms to SMT have recently been described as particular forms of ramp loss optimization (McAllester and Keshet, 2011; Gimpel and Smith, 2012). All approaches have been shown to scale to large feature sets and all include some kind of regularization method. However, most approaches have been confined to training on small tuning sets. Exceptions where discriminative SMT has been used on large training data are Liang et al. (2006a) who trained 1.5 million fe</context>
</contexts>
<marker>Hayashi, Watanabe, Tsukada, Isozaki, 2009</marker>
<rawString>Katsuhiko Hayashi, Taro Watanabe, Hajime Tsukada, and Hideki Isozaki. 2009. Structural support vector machines for log-linear approach in statistical machine translation. In Proceedings of IWSLT, Tokyo, Japan.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Kenneth Heafield</author>
</authors>
<title>KenLM: faster and smaller language model queries.</title>
<date>2011</date>
<booktitle>In Proceedings of the EMNLP 2011 Sixth Workshop on Statistical Machine Translation (WMT’11),</booktitle>
<location>Edinburgh, UK.</location>
<contexts>
<context citStr="Heafield, 2011" endWordPosition="3141" position="18704" startWordPosition="3140"> minimal compared to the expense of decoding. Also, deploying disk space instead of memory fits perfectly into the MapReduce framework we are working in. Furthermore, the extraction of grammars for training is done in a leave-one-out fashion (Zollmann and Sima’an, 2005) where rules are extracted for a parallel sentence pair only if the same rules are found in other sentences of the corpus as well. 3-gram (news-commentary) and 5-gram (Europarl) language models are trained on the data described in Table 1, using the SRILM toolkit (Stolcke, 2002) and binarized for efficient querying using kenlm (Heafield, 2011). For the 5-gram language models, we replaced every word in the lm training data with &lt;unk&gt; that did not appear in the English part of the parallel training data to build an open vocabulary language model. Figure 3: Multipartite pairwise ranking. Training data for discriminative learning are prepared by comparing a 100-best list of translations against a single reference using smoothed persentence BLEU (Liang et al., 2006a). From the BLEU-reordered n-best list, translations were put into sets for the top 10% level (HI), the middle 80% level (MID), and the bottom 10% level (LOW). These level se</context>
</contexts>
<marker>Heafield, 2011</marker>
<rawString>Kenneth Heafield. 2011. KenLM: faster and smaller language model queries. In Proceedings of the EMNLP 2011 Sixth Workshop on Statistical Machine Translation (WMT’11), Edinburgh, UK.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Mark Hopkins</author>
<author>Jonathan May</author>
</authors>
<title>Tuning as ranking.</title>
<date>2011</date>
<booktitle>In Proceedings of 2011 Conference on Empirical Methods in Natural Language Processing (EMNLP’11),</booktitle>
<location>Edinburgh, Scotland.</location>
<contexts>
<context citStr="Hopkins and May, 2011" endWordPosition="999" position="6553" startWordPosition="996">amework. 1https://github.com/redpony/cdec 2 Related Work The great promise of discriminative training for SMT is the possibility to design arbitrarily expressive, complex, or overlapping features in great numbers. The focus of many approaches thus has been on feature engineering and on adaptations of machine learning algorithms to the special case of SMT (where gold standard rankings have to be created automatically). Examples for adapted algorithms include Maximum-Entropy Models (Och and Ney, 2002; Blunsom et al., 2008), Pairwise Ranking Perceptrons (Shen et al., 2004; Watanabe et al., 2006; Hopkins and May, 2011), Structured Perceptrons (Liang et al., 2006a), Boosting (Duh and Kirchhoff, 2008; Wellington et al., 2009), Structured SVMs (Tillmann and Zhang, 2006; Hayashi et al., 2009), MIRA (Watanabe et al., 2007; Chiang et al., 2008; Chiang et al., 2009), and others. Adaptations of the loss functions underlying such algorithms to SMT have recently been described as particular forms of ramp loss optimization (McAllester and Keshet, 2011; Gimpel and Smith, 2012). All approaches have been shown to scale to large feature sets and all include some kind of regularization method. However, most approaches have</context>
<context citStr="Hopkins and May, 2011" endWordPosition="4014" position="24255" startWordPosition="4011"> 12 dense features (default), rule identifiers (id), rule n-gram (ng), and rule shape (shape). Statistical significance at p-level &lt; 0.05 of a result difference on the test set to a different algorithm applied to the same feature group is indicated by raised algorithm number. † indicates statistically significant differences to best result across features groups for same algorithm, indicated in bold face. @ indicates the optimal number of epochs chosen on the devtest set. pergraph as is done in the cdec implementation of MIRA. We found similar fluctuations for the cdec implementations of PRO (Hopkins and May, 2011) or hypergraph-MERT (Kumar et al., 2009) both of which depend on hypergraph sampling. In contrast, the perceptron is deterministic when started from a zero-vector of weights and achieves favorable 28.0 BLEU on the news-commentary test set. Since we are interested in relative improvements over a stable baseline, we restrict our attention in all following experiments to the perceptron.7 Table 2 shows the results of the experimental comparison of the 4 algorithms of Section 4. The 7Absolute improvements would be possible, e.g., by using larger language models or by adding news data to the ep trai</context>
</contexts>
<marker>Hopkins, May, 2011</marker>
<rawString>Mark Hopkins and Jonathan May. 2011. Tuning as ranking. In Proceedings of 2011 Conference on Empirical Methods in Natural Language Processing (EMNLP’11), Edinburgh, Scotland.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Philipp Koehn</author>
<author>Franz Josef Och</author>
<author>Daniel Marcu</author>
</authors>
<title>Statistical phrase-based translation.</title>
<date>2003</date>
<booktitle>In Proceedings of the Human Language Technology Conference and the 3rd Meeting of the North American Chapter of the Association for Computational Linguistics (HLTNAACL’03),</booktitle>
<location>Edmonton, Cananda.</location>
<contexts>
<context citStr="Koehn et al., 2003" endWordPosition="4242" position="25669" startWordPosition="4239">rse features are the 3 templates described in Section 3. All feature weights were tuned together using algorithms 1-4. If not indicated otherwise, the perceptron was run for 10 epochs with learning rate q = 0.0001, started at zero weight vector, using deduplicated 100-best lists. The results on the news-commentary (nc) data show that training on the development set does not benefit from adding large feature sets – BLEU result differences between tuning 12 default features 8negative log relative frequency p(elf); log count(f); log count(e, f); lexical translation probability p(f|e) and p(elf) (Koehn et al., 2003); indicator variable on singleton phrase e; indicator variable on singleton phrase pair f, e; word penalty; language model weight; OOV count of language model; number of untranslated words; Hiero glue rules (Chiang, 2007). 17 Alg. Tuning set Features #Feats devtest-ep test-ep Tuning set test-crawl10 test-crawl11 1 dev-ep default 12 25.62 26.42† dev-crawl 15.39† 14.43† dev-ep +id,ng,shape 300k 27.84 28.37 dev-crawl 17.84 16.834 4 train-ep +id,ng,shape 100k 28.0 @9 28.62 train-ep 19.121 17.331 Table 3: BLEU-4 results for algorithms 1 (SGD) and 4 (IterSelSGD) on Europarl (ep) and news crawl (craw</context>
</contexts>
<marker>Koehn, Och, Marcu, 2003</marker>
<rawString>Philipp Koehn, Franz Josef Och, and Daniel Marcu. 2003. Statistical phrase-based translation. In Proceedings of the Human Language Technology Conference and the 3rd Meeting of the North American Chapter of the Association for Computational Linguistics (HLTNAACL’03), Edmonton, Cananda.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Shankar Kumar</author>
<author>Wolfgang Macherey</author>
<author>Chris Dyer</author>
<author>Franz Och</author>
</authors>
<title>Efficient minimum error rate training and minimum Bayes-risk decoding for translation hypergraphs and lattices.</title>
<date>2009</date>
<booktitle>In Proceedings of the 47th Annual Meeting of the Association for Computational</booktitle>
<contexts>
<context citStr="Kumar et al., 2009" endWordPosition="4020" position="24295" startWordPosition="4017">ers (id), rule n-gram (ng), and rule shape (shape). Statistical significance at p-level &lt; 0.05 of a result difference on the test set to a different algorithm applied to the same feature group is indicated by raised algorithm number. † indicates statistically significant differences to best result across features groups for same algorithm, indicated in bold face. @ indicates the optimal number of epochs chosen on the devtest set. pergraph as is done in the cdec implementation of MIRA. We found similar fluctuations for the cdec implementations of PRO (Hopkins and May, 2011) or hypergraph-MERT (Kumar et al., 2009) both of which depend on hypergraph sampling. In contrast, the perceptron is deterministic when started from a zero-vector of weights and achieves favorable 28.0 BLEU on the news-commentary test set. Since we are interested in relative improvements over a stable baseline, we restrict our attention in all following experiments to the perceptron.7 Table 2 shows the results of the experimental comparison of the 4 algorithms of Section 4. The 7Absolute improvements would be possible, e.g., by using larger language models or by adding news data to the ep training set when evaluating on crawl test s</context>
</contexts>
<marker>Kumar, Macherey, Dyer, Och, 2009</marker>
<rawString>Shankar Kumar, Wolfgang Macherey, Chris Dyer, and Franz Och. 2009. Efficient minimum error rate training and minimum Bayes-risk decoding for translation hypergraphs and lattices. In Proceedings of the 47th Annual Meeting of the Association for Computational</rawString>
</citation>
<citation valid="true">
<authors>
<author>Thomas Navin Lal</author>
<author>Olivier Chapelle</author>
<author>Jason Weston</author>
<author>Andr´e Elisseeff</author>
</authors>
<title>Embedded methods.</title>
<date>2006</date>
<editor>In I.M. Guyon, S.R. Gunn, M. Nikravesh, and L. Zadeh, editors, Feature</editor>
<publisher>Springer.</publisher>
<contexts>
<context citStr="Lal et al., 2006" endWordPosition="2804" position="16557" startWordPosition="2801">2 Figure 2: f1/f2 regularization enforcing feature selection. Our algorithm is related to Obozinski et al. (2010)’s approach to f1/f2 regularization where feature columns are incrementally selected based on the f2 norms of the gradient vectors corresponding to feature columns. Their algorithm is itself an extension of gradient-based feature selection based on the f1 norm, e.g., Perkins et al. (2003).4 In contrast to these approaches we approximate the gradient by using the weights given by the ranking algorithm itself. This relates our work to weight-based recursive feature elimination (RFE) (Lal et al., 2006). Furthermore, algorithm 4 performs feature selection based on a choice of meta-parameter of K features instead of by thresholding a regularization meta-parameter A, however, these techniques are equivalent and can be transformed into each other. 5 Experiments 5.1 Data, Systems, Experiment Settings The datasets used in our experiments are versions of the News Commentary (nc), News Crawl (crawl) and Europarl (ep) corpora described in Table 1. The translation direction is German-to-English. The SMT framework used in our experiments is hierarchical phrase-based translation (Chiang, 2007). We use </context>
</contexts>
<marker>Lal, Chapelle, Weston, Elisseeff, 2006</marker>
<rawString>Thomas Navin Lal, Olivier Chapelle, Jason Weston, and Andr´e Elisseeff. 2006. Embedded methods. In I.M. Guyon, S.R. Gunn, M. Nikravesh, and L. Zadeh, editors, Feature Extraction: Foundations and Applications. Springer.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Percy Liang</author>
<author>Alexandre Bouchard-Cˆot´e</author>
<author>Dan Klein</author>
<author>Ben Taskar</author>
</authors>
<title>An end-to-end discriminative approach to machine translation.</title>
<date>2006</date>
<booktitle>In Proceedings of the joint conference of the International Committee on Computational Linguistics and the Association for Computational Linguistics (COLING-ACL’06),</booktitle>
<location>Sydney, Australia.</location>
<marker>Liang, Bouchard-Cˆot´e, Klein, Taskar, 2006</marker>
<rawString>Percy Liang, Alexandre Bouchard-Cˆot´e, Dan Klein, and Ben Taskar. 2006a. An end-to-end discriminative approach to machine translation. In Proceedings of the joint conference of the International Committee on Computational Linguistics and the Association for Computational Linguistics (COLING-ACL’06), Sydney, Australia.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Percy Liang</author>
<author>Ben Taskar</author>
<author>Dan Klein</author>
</authors>
<title>Alignment by agreement.</title>
<date>2006</date>
<booktitle>In Proceedings of the Human Language Technology Conference - North American Chapter of the Association for Computational Linguistics annual meeting (HLT-NAACL’06),</booktitle>
<location>New York, NY.</location>
<contexts>
<context citStr="Liang et al., 2006" endWordPosition="1005" position="6597" startWordPosition="1002">ted Work The great promise of discriminative training for SMT is the possibility to design arbitrarily expressive, complex, or overlapping features in great numbers. The focus of many approaches thus has been on feature engineering and on adaptations of machine learning algorithms to the special case of SMT (where gold standard rankings have to be created automatically). Examples for adapted algorithms include Maximum-Entropy Models (Och and Ney, 2002; Blunsom et al., 2008), Pairwise Ranking Perceptrons (Shen et al., 2004; Watanabe et al., 2006; Hopkins and May, 2011), Structured Perceptrons (Liang et al., 2006a), Boosting (Duh and Kirchhoff, 2008; Wellington et al., 2009), Structured SVMs (Tillmann and Zhang, 2006; Hayashi et al., 2009), MIRA (Watanabe et al., 2007; Chiang et al., 2008; Chiang et al., 2009), and others. Adaptations of the loss functions underlying such algorithms to SMT have recently been described as particular forms of ramp loss optimization (McAllester and Keshet, 2011; Gimpel and Smith, 2012). All approaches have been shown to scale to large feature sets and all include some kind of regularization method. However, most approaches have been confined to training on small tuning s</context>
<context citStr="Liang et al., 2006" endWordPosition="1515" position="9747" startWordPosition="1512">and an (NT, term*, NT) pattern on its target side. Rule (3) maps to a different template, that of (NT, term*, NT) on source and target sides. 4 Joint Feature Selection in Distributed Stochastic Learning The following discussion of learning methods is based on pairwise ranking in a Stochastic Gradient Descent (SGD) framework. The resulting algorithms can be seen as variants of the perceptron algorithm. Let each translation candidate be represented by a feature vector x E IRD where preference pairs for training are prepared by sorting translations according to smoothed sentence-wise BLEU score (Liang et al., 2006a) against the reference. For a preference pair xj = (x(1) j , xj 2)) where x(1) j is preferred over x(2) j , and ¯xj = x(1) j − x(2) j , we consider the following hinge loss-type objective function: lj(w) = (− (w, ¯xj ))+ where (a)+ = max(0, a) , w E IRD is a weight vector, and (·, ·) denotes the standard vector dot product. Instantiating SGD to the following stochastic 2Similar “monolingual parse features” have been used in Dyer et al. (2011). subgradient leads to the perceptron algorithm for pairwise ranking3 (Shen and Joshi, 2005): � −¯xj if (w, ¯xj) G 0, �lj(w) = 0 else. Our baseline algo</context>
<context citStr="Liang et al., 2006" endWordPosition="2956" position="17550" startWordPosition="2953">c), News Crawl (crawl) and Europarl (ep) corpora described in Table 1. The translation direction is German-to-English. The SMT framework used in our experiments is hierarchical phrase-based translation (Chiang, 2007). We use the cdec decoder5 (Dyer et al., 2010) and induce SCFG grammars from two sets of symmetrized alignments using the method described by Chiang (2007). All data was tokenized and lowercased; German compounds were split (Dyer, 2009). For word alignment of the news-commentary data, we used GIZA++ (Och and Ney, 2000); for aligning the Europarl data, we used the Berkeley aligner (Liang et al., 2006b). Before training, we collect all the grammar rules necessary to 4Note that by definition of ||W||1,2, standard f1 regularization is a special case of f1/f2 regularization for a single task. 5cdec metaparameters were set to a non-terminal span limit of 15 and standard cube pruning with a pop limit of 200. translate each individual sentence into separate files (so-called per-sentence grammars) (Lopez, 2007). When decoding, cdec loads the appropriate file immediately prior to translation of the sentence. The computational overhead is minimal compared to the expense of decoding. Also, deploying</context>
<context citStr="Liang et al., 2006" endWordPosition="3212" position="19129" startWordPosition="3209">ry) and 5-gram (Europarl) language models are trained on the data described in Table 1, using the SRILM toolkit (Stolcke, 2002) and binarized for efficient querying using kenlm (Heafield, 2011). For the 5-gram language models, we replaced every word in the lm training data with &lt;unk&gt; that did not appear in the English part of the parallel training data to build an open vocabulary language model. Figure 3: Multipartite pairwise ranking. Training data for discriminative learning are prepared by comparing a 100-best list of translations against a single reference using smoothed persentence BLEU (Liang et al., 2006a). From the BLEU-reordered n-best list, translations were put into sets for the top 10% level (HI), the middle 80% level (MID), and the bottom 10% level (LOW). These level sets are used for multipartite ranking HI MID LOW 15 News Commentary(nc) train-nc lm-train-nc dev-nc devtest-nc test-nc Sentences 132,753 180,657 1057 1064 2007 Tokens de 3,530,907 – 27,782 28,415 53,989 Tokens en 3,293,363 4,394,428 26,098 26,219 50,443 Rule Count 14,350,552 (1G) – 2,322,912 2,320,264 3,274,771 Europarl(ep) train-ep lm-train-ep dev-ep devtest-ep test-ep Sentences 1,655,238 2,015,440 2000 2000 2000 Tokens d</context>
</contexts>
<marker>Liang, Taskar, Klein, 2006</marker>
<rawString>Percy Liang, Ben Taskar, and Dan Klein. 2006b. Alignment by agreement. In Proceedings of the Human Language Technology Conference - North American Chapter of the Association for Computational Linguistics annual meeting (HLT-NAACL’06), New York, NY.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Adam Lopez</author>
</authors>
<title>Hierarchical phrase-based translation with suffix arrays.</title>
<date>2007</date>
<booktitle>In Proceedings of EMNLPCoNLL,</booktitle>
<location>Prague, Czech Republic.</location>
<contexts>
<context citStr="Lopez, 2007" endWordPosition="3021" position="17961" startWordPosition="3020">n compounds were split (Dyer, 2009). For word alignment of the news-commentary data, we used GIZA++ (Och and Ney, 2000); for aligning the Europarl data, we used the Berkeley aligner (Liang et al., 2006b). Before training, we collect all the grammar rules necessary to 4Note that by definition of ||W||1,2, standard f1 regularization is a special case of f1/f2 regularization for a single task. 5cdec metaparameters were set to a non-terminal span limit of 15 and standard cube pruning with a pop limit of 200. translate each individual sentence into separate files (so-called per-sentence grammars) (Lopez, 2007). When decoding, cdec loads the appropriate file immediately prior to translation of the sentence. The computational overhead is minimal compared to the expense of decoding. Also, deploying disk space instead of memory fits perfectly into the MapReduce framework we are working in. Furthermore, the extraction of grammars for training is done in a leave-one-out fashion (Zollmann and Sima’an, 2005) where rules are extracted for a parallel sentence pair only if the same rules are found in other sentences of the corpus as well. 3-gram (news-commentary) and 5-gram (Europarl) language models are trai</context>
</contexts>
<marker>Lopez, 2007</marker>
<rawString>Adam Lopez. 2007. Hierarchical phrase-based translation with suffix arrays. In Proceedings of EMNLPCoNLL, Prague, Czech Republic.</rawString>
</citation>
<citation valid="true">
<authors>
<author>David McAllester</author>
<author>Joseph Keshet</author>
</authors>
<title>Generalization bounds and consistency for latent structural probit and ramp loss.</title>
<date>2011</date>
<booktitle>In Proceedings of the 25th Annual Conference on Neural Information Processing Sytems (NIPS 2011),</booktitle>
<location>Granada,</location>
<contexts>
<context citStr="McAllester and Keshet, 2011" endWordPosition="1064" position="6983" startWordPosition="1061">mples for adapted algorithms include Maximum-Entropy Models (Och and Ney, 2002; Blunsom et al., 2008), Pairwise Ranking Perceptrons (Shen et al., 2004; Watanabe et al., 2006; Hopkins and May, 2011), Structured Perceptrons (Liang et al., 2006a), Boosting (Duh and Kirchhoff, 2008; Wellington et al., 2009), Structured SVMs (Tillmann and Zhang, 2006; Hayashi et al., 2009), MIRA (Watanabe et al., 2007; Chiang et al., 2008; Chiang et al., 2009), and others. Adaptations of the loss functions underlying such algorithms to SMT have recently been described as particular forms of ramp loss optimization (McAllester and Keshet, 2011; Gimpel and Smith, 2012). All approaches have been shown to scale to large feature sets and all include some kind of regularization method. However, most approaches have been confined to training on small tuning sets. Exceptions where discriminative SMT has been used on large training data are Liang et al. (2006a) who trained 1.5 million features on 67,000 sentences, Blunsom et al. (2008) who trained 7.8 million rules on 100,000 sentences, or Tillmann and Zhang (2006) who used 230,000 sentences for training. Our approach is inspired by Duh et al. (2010) who applied multi-task learning for imp</context>
</contexts>
<marker>McAllester, Keshet, 2011</marker>
<rawString>David McAllester and Joseph Keshet. 2011. Generalization bounds and consistency for latent structural probit and ramp loss. In Proceedings of the 25th Annual Conference on Neural Information Processing Sytems (NIPS 2011), Granada, Spain.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Ryan McDonald</author>
<author>Keith Hall</author>
<author>Gideon Mann</author>
</authors>
<title>Distributed training strategies for the structured perceptron.</title>
<date>2010</date>
<booktitle>In Proceedings of Human Language Technologies: The 11th Annual Conference of the North American Chapter of the Association for Computational Linguistics (NAACL-HLT’10),</booktitle>
<location>Los Angeles, CA.</location>
<contexts>
<context citStr="McDonald et al. (2010)" endWordPosition="1945" position="12030" startWordPosition="1942"> for all i E {0 ... S − 11: do Decode ith input with wz,t,i,0. for all pairs xj, j E {0 ... P −//11: do wz,t,i,j+1 F wz,t,i,j − ηvljlWz,t,i,j) end for wz,t,i+1,0 F wz,t,i,P end for wz,t+1,0,0 F wz,t,S,0 end for end for Collect final weights from each machine, E 1 1T E wz,t,0,0J . z=1 t=1 3Other loss functions lead to stochastic versions of SVMs (Collobert and Bengio, 2004; Shalev-Shwartz et al., 2007; Chapelle and Keerthi, 2010). T E t=1 wt,0,0 return 1Z 13 Algorithm 2 is a variant of the SimuParallelSGD algorithm of Zinkevich et al. (2010) or equivalently of the parameter mixing algorithm of McDonald et al. (2010). The key idea of algorithm 2 is to partition the data into disjoint shards, then train SGD on each shard in parallel, and after training mix the final parameters from each shard by averaging. The algorithm requires no communication between machines until the end. McDonald et al. (2010) also present an iterative mixing algorithm where weights are mixed from each shard after training a single epoch of the perceptron in parallel on each shard. The mixed weight vector is re-sent to each shard to start another epoch of training in parallel on each shard. This algorithm corresponds to our algorithm</context>
</contexts>
<marker>McDonald, Hall, Mann, 2010</marker>
<rawString>Ryan McDonald, Keith Hall, and Gideon Mann. 2010. Distributed training strategies for the structured perceptron. In Proceedings of Human Language Technologies: The 11th Annual Conference of the North American Chapter of the Association for Computational Linguistics (NAACL-HLT’10), Los Angeles, CA.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Eric W Noreen</author>
</authors>
<title>Computer Intensive Methods for Testing Hypotheses. An Introduction.</title>
<date>1989</date>
<publisher>Wiley,</publisher>
<location>New York.</location>
<contexts>
<context citStr="Noreen, 1989" endWordPosition="3500" position="21157" startWordPosition="3499">le counts of ep/nc training data are total counts of rules in the per-sentence grammars. where translation pairs are built between the elements in HI-MID, HI-LOW, and MID-LOW, but not between translations inside sets on the same level. This idea is depicted graphically in Figure 3. The intuition is to ensure that good translations are preferred over bad translations without teasing apart small differences. For evaluation, we used the mteval-v11b.pl script to compute lowercased BLEU-4 scores (Papineni et al., 2001). Statistical significance was measured using an Approximate Randomization test (Noreen, 1989; Riezler and Maxwell, 2005). All experiments for training on dev sets were carried out on a single computer. For grammar extraction and training of the full data set we used a 30 node hadoop Map/Reduce cluster that can handle 300 jobs at once. We split the data into 2290 shards for the ep runs and 141 shards for the nc runs, each shard holding about 1,000 sentences, which corresponds to the dev set size of the nc data set. 5.2 Experimental Results The baseline learner in our experiments is a pairwise ranking perceptron that is used on various features and training data and plugged into variou</context>
</contexts>
<marker>Noreen, 1989</marker>
<rawString>Eric W. Noreen. 1989. Computer Intensive Methods for Testing Hypotheses. An Introduction. Wiley, New York.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Guillaume Obozinski</author>
<author>Ben Taskar</author>
<author>Michael I Jordan</author>
</authors>
<title>Joint covariate selection and joint subspace selection for multiple classification problems.</title>
<date>2010</date>
<journal>Statistics and Computing,</journal>
<pages>20--231</pages>
<contexts>
<context citStr="Obozinski et al. (2010)" endWordPosition="2724" position="16053" startWordPosition="2721">er f1/f2 norm (12 instead of 18). This matrix shares features across tasks which leads to larger f2 norms for some columns (here ||w1||2 and ||w2||2) and forces other columns to zero. This results in shrinking the matrix to those features that are useful across all tasks. Z E z=1 wz,t,S,0. Z E z=1 W[z][k]. D E d=1 ||wd||2. 14 w1 w2 w3 w4 w5 w1 w2 w3 w4 w5 wz1 [ 6 4 0 0 0 ] [ 6 4 0 0 0 ] wz2 [ 0 0 3 0 0 ] [ 3 0 0 0 0 ] wx3 [ 0 0 0 2 3 ] [ 2 3 0 0 0 ] column `2 norm: 6 4 3 2 3 7 5 0 0 0 `1 sum: =�. 18 =�. 12 Figure 2: f1/f2 regularization enforcing feature selection. Our algorithm is related to Obozinski et al. (2010)’s approach to f1/f2 regularization where feature columns are incrementally selected based on the f2 norms of the gradient vectors corresponding to feature columns. Their algorithm is itself an extension of gradient-based feature selection based on the f1 norm, e.g., Perkins et al. (2003).4 In contrast to these approaches we approximate the gradient by using the weights given by the ranking algorithm itself. This relates our work to weight-based recursive feature elimination (RFE) (Lal et al., 2006). Furthermore, algorithm 4 performs feature selection based on a choice of meta-parameter of K f</context>
</contexts>
<marker>Obozinski, Taskar, Jordan, 2010</marker>
<rawString>Guillaume Obozinski, Ben Taskar, and Michael I. Jordan. 2010. Joint covariate selection and joint subspace selection for multiple classification problems. Statistics and Computing, 20:231–252.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Franz Josef Och</author>
<author>Hermann Ney</author>
</authors>
<title>Improved statistical alignment models.</title>
<date>2000</date>
<booktitle>In Proceedings of the 38th Annual Meeting of the Association for Computational Linguistics (ACL’00), Hongkong,</booktitle>
<contexts>
<context citStr="Och and Ney, 2000" endWordPosition="2941" position="17468" startWordPosition="2938">ttings The datasets used in our experiments are versions of the News Commentary (nc), News Crawl (crawl) and Europarl (ep) corpora described in Table 1. The translation direction is German-to-English. The SMT framework used in our experiments is hierarchical phrase-based translation (Chiang, 2007). We use the cdec decoder5 (Dyer et al., 2010) and induce SCFG grammars from two sets of symmetrized alignments using the method described by Chiang (2007). All data was tokenized and lowercased; German compounds were split (Dyer, 2009). For word alignment of the news-commentary data, we used GIZA++ (Och and Ney, 2000); for aligning the Europarl data, we used the Berkeley aligner (Liang et al., 2006b). Before training, we collect all the grammar rules necessary to 4Note that by definition of ||W||1,2, standard f1 regularization is a special case of f1/f2 regularization for a single task. 5cdec metaparameters were set to a non-terminal span limit of 15 and standard cube pruning with a pop limit of 200. translate each individual sentence into separate files (so-called per-sentence grammars) (Lopez, 2007). When decoding, cdec loads the appropriate file immediately prior to translation of the sentence. The comp</context>
</contexts>
<marker>Och, Ney, 2000</marker>
<rawString>Franz Josef Och and Hermann Ney. 2000. Improved statistical alignment models. In Proceedings of the 38th Annual Meeting of the Association for Computational Linguistics (ACL’00), Hongkong, China.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Franz Josef Och</author>
<author>Hermann Ney</author>
</authors>
<title>Discriminative training and maximum entropy models for statistical machine translation.</title>
<date>2002</date>
<booktitle>In Proceedings of the 40th Annual Meeting of the Association for Computational Linguistics (ACL’02),</booktitle>
<location>Philadelphia, PA.</location>
<contexts>
<context citStr="Och and Ney, 2002" endWordPosition="979" position="6434" startWordPosition="976">eature sets of various sizes on small development sets. Our software is freely available as a part of the cdec1 framework. 1https://github.com/redpony/cdec 2 Related Work The great promise of discriminative training for SMT is the possibility to design arbitrarily expressive, complex, or overlapping features in great numbers. The focus of many approaches thus has been on feature engineering and on adaptations of machine learning algorithms to the special case of SMT (where gold standard rankings have to be created automatically). Examples for adapted algorithms include Maximum-Entropy Models (Och and Ney, 2002; Blunsom et al., 2008), Pairwise Ranking Perceptrons (Shen et al., 2004; Watanabe et al., 2006; Hopkins and May, 2011), Structured Perceptrons (Liang et al., 2006a), Boosting (Duh and Kirchhoff, 2008; Wellington et al., 2009), Structured SVMs (Tillmann and Zhang, 2006; Hayashi et al., 2009), MIRA (Watanabe et al., 2007; Chiang et al., 2008; Chiang et al., 2009), and others. Adaptations of the loss functions underlying such algorithms to SMT have recently been described as particular forms of ramp loss optimization (McAllester and Keshet, 2011; Gimpel and Smith, 2012). All approaches have been</context>
</contexts>
<marker>Och, Ney, 2002</marker>
<rawString>Franz Josef Och and Hermann Ney. 2002. Discriminative training and maximum entropy models for statistical machine translation. In Proceedings of the 40th Annual Meeting of the Association for Computational Linguistics (ACL’02), Philadelphia, PA.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Franz Josef Och</author>
</authors>
<title>Minimum error rate training in statistical machine translation.</title>
<date>2003</date>
<booktitle>In Proceedings of the Human Language Technology Conference and the 3rd Meeting of the North American Chapter of the Association for Computational Linguistics (HLTNAACL’03),</booktitle>
<location>Edmonton, Cananda.</location>
<contexts>
<context citStr="Och (2003)" endWordPosition="198" position="1426" startWordPosition="197">SMT that can be read off from rules at runtime, and present a learning algorithm that applies f1/Q2 regularization for joint feature selection over distributed stochastic learning processes. We present experiments on learning on 1.5 million training sentences, and show significant improvements over tuning discriminative models on small development sets. 1 Introduction The standard SMT training pipeline combines scores from large count-based translation models and language models with a few other features and tunes these using the well-understood line-search technique for error minimization of Och (2003). If only a handful of dense features need to be tuned, minimum error rate training can be done on small tuning sets and is hard to beat in terms of accuracy and efficiency. In contrast, the promise of largescale discriminative training for SMT is to scale to arbitrary types and numbers of features and to provide sufficient statistical support by parameter estimation on large sample sizes. Features may be lexicalized and sparse, non-local and overlapping, or be designed to generalize beyond surface statistics by incorporating part-of-speech or syntactic labels. The modeler’s goals might be to </context>
</contexts>
<marker>Och, 2003</marker>
<rawString>Franz Josef Och. 2003. Minimum error rate training in statistical machine translation. In Proceedings of the Human Language Technology Conference and the 3rd Meeting of the North American Chapter of the Association for Computational Linguistics (HLTNAACL’03), Edmonton, Cananda.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Kishore Papineni</author>
<author>Salim Roukos</author>
<author>Todd Ward</author>
<author>WeiJing Zhu</author>
</authors>
<title>Bleu: a method for automatic evaluation of machine translation.</title>
<date>2001</date>
<tech>Technical Report IBM Research Division Technical Report, RC22176 (W0190-022),</tech>
<location>Yorktown Heights, N.Y.</location>
<contexts>
<context citStr="Papineni et al., 2001" endWordPosition="3489" position="21064" startWordPosition="3485">s from WMT08 shared task (http://statmt.org/wmt08/shared-task.html). The numbers in brackets for the rule counts of ep/nc training data are total counts of rules in the per-sentence grammars. where translation pairs are built between the elements in HI-MID, HI-LOW, and MID-LOW, but not between translations inside sets on the same level. This idea is depicted graphically in Figure 3. The intuition is to ensure that good translations are preferred over bad translations without teasing apart small differences. For evaluation, we used the mteval-v11b.pl script to compute lowercased BLEU-4 scores (Papineni et al., 2001). Statistical significance was measured using an Approximate Randomization test (Noreen, 1989; Riezler and Maxwell, 2005). All experiments for training on dev sets were carried out on a single computer. For grammar extraction and training of the full data set we used a 30 node hadoop Map/Reduce cluster that can handle 300 jobs at once. We split the data into 2290 shards for the ep runs and 141 shards for the nc runs, each shard holding about 1,000 sentences, which corresponds to the dev set size of the nc data set. 5.2 Experimental Results The baseline learner in our experiments is a pairwise </context>
</contexts>
<marker>Papineni, Roukos, Ward, Zhu, 2001</marker>
<rawString>Kishore Papineni, Salim Roukos, Todd Ward, and WeiJing Zhu. 2001. Bleu: a method for automatic evaluation of machine translation. Technical Report IBM Research Division Technical Report, RC22176 (W0190-022), Yorktown Heights, N.Y.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Simon Perkins</author>
<author>Kevin Lacker</author>
<author>James Theiler</author>
</authors>
<title>Grafting: Fast, incremental feature selection by gradient descent in function space.</title>
<date>2003</date>
<journal>Journal of Machine Learning Research,</journal>
<pages>3--1333</pages>
<contexts>
<context citStr="Perkins et al. (2003)" endWordPosition="2769" position="16342" startWordPosition="2766">Z E z=1 W[z][k]. D E d=1 ||wd||2. 14 w1 w2 w3 w4 w5 w1 w2 w3 w4 w5 wz1 [ 6 4 0 0 0 ] [ 6 4 0 0 0 ] wz2 [ 0 0 3 0 0 ] [ 3 0 0 0 0 ] wx3 [ 0 0 0 2 3 ] [ 2 3 0 0 0 ] column `2 norm: 6 4 3 2 3 7 5 0 0 0 `1 sum: =�. 18 =�. 12 Figure 2: f1/f2 regularization enforcing feature selection. Our algorithm is related to Obozinski et al. (2010)’s approach to f1/f2 regularization where feature columns are incrementally selected based on the f2 norms of the gradient vectors corresponding to feature columns. Their algorithm is itself an extension of gradient-based feature selection based on the f1 norm, e.g., Perkins et al. (2003).4 In contrast to these approaches we approximate the gradient by using the weights given by the ranking algorithm itself. This relates our work to weight-based recursive feature elimination (RFE) (Lal et al., 2006). Furthermore, algorithm 4 performs feature selection based on a choice of meta-parameter of K features instead of by thresholding a regularization meta-parameter A, however, these techniques are equivalent and can be transformed into each other. 5 Experiments 5.1 Data, Systems, Experiment Settings The datasets used in our experiments are versions of the News Commentary (nc), News C</context>
</contexts>
<marker>Perkins, Lacker, Theiler, 2003</marker>
<rawString>Simon Perkins, Kevin Lacker, and James Theiler. 2003. Grafting: Fast, incremental feature selection by gradient descent in function space. Journal of Machine Learning Research, 3:1333–1356.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Stefan Riezler</author>
<author>John Maxwell</author>
</authors>
<title>On some pitfalls in automatic evaluation and significance testing for MT.</title>
<date>2005</date>
<booktitle>In Proceedings of the ACL-05 Workshop on Intrinsic and Extrinsic Evaluation Measures for MT and/or Summarization,</booktitle>
<location>Ann Arbor, MI.</location>
<contexts>
<context citStr="Riezler and Maxwell, 2005" endWordPosition="3504" position="21185" startWordPosition="3501">p/nc training data are total counts of rules in the per-sentence grammars. where translation pairs are built between the elements in HI-MID, HI-LOW, and MID-LOW, but not between translations inside sets on the same level. This idea is depicted graphically in Figure 3. The intuition is to ensure that good translations are preferred over bad translations without teasing apart small differences. For evaluation, we used the mteval-v11b.pl script to compute lowercased BLEU-4 scores (Papineni et al., 2001). Statistical significance was measured using an Approximate Randomization test (Noreen, 1989; Riezler and Maxwell, 2005). All experiments for training on dev sets were carried out on a single computer. For grammar extraction and training of the full data set we used a 30 node hadoop Map/Reduce cluster that can handle 300 jobs at once. We split the data into 2290 shards for the ep runs and 141 shards for the nc runs, each shard holding about 1,000 sentences, which corresponds to the dev set size of the nc data set. 5.2 Experimental Results The baseline learner in our experiments is a pairwise ranking perceptron that is used on various features and training data and plugged into various metaM X BLEU[%] 23.0 25.0 </context>
</contexts>
<marker>Riezler, Maxwell, 2005</marker>
<rawString>Stefan Riezler and John Maxwell. 2005. On some pitfalls in automatic evaluation and significance testing for MT. In Proceedings of the ACL-05 Workshop on Intrinsic and Extrinsic Evaluation Measures for MT and/or Summarization, Ann Arbor, MI.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Shai Shalev-Shwartz</author>
<author>Yoram Singer</author>
<author>Nathan Srebro</author>
</authors>
<title>Pegasos: Primal Estimated sub-GrAdient SOlver for SVM.</title>
<date>2007</date>
<booktitle>In Proceedings of the 24th International Conference on Machine Learning (ICML’07),</booktitle>
<location>Corvallis, OR.</location>
<contexts>
<context citStr="Shalev-Shwartz et al., 2007" endWordPosition="1908" position="11811" startWordPosition="1905">, 2004). Algorithm 2 MixSGD: int I, T, Z, float 77 Partition data into Z shards, each of size S F I/Z; distribute to machines. for all shards z E {1 ... Z1: parallel do Initialize wz,0,0,0 F 0. for epochs t F 0 ... T − 1: do for all i E {0 ... S − 11: do Decode ith input with wz,t,i,0. for all pairs xj, j E {0 ... P −//11: do wz,t,i,j+1 F wz,t,i,j − ηvljlWz,t,i,j) end for wz,t,i+1,0 F wz,t,i,P end for wz,t+1,0,0 F wz,t,S,0 end for end for Collect final weights from each machine, E 1 1T E wz,t,0,0J . z=1 t=1 3Other loss functions lead to stochastic versions of SVMs (Collobert and Bengio, 2004; Shalev-Shwartz et al., 2007; Chapelle and Keerthi, 2010). T E t=1 wt,0,0 return 1Z 13 Algorithm 2 is a variant of the SimuParallelSGD algorithm of Zinkevich et al. (2010) or equivalently of the parameter mixing algorithm of McDonald et al. (2010). The key idea of algorithm 2 is to partition the data into disjoint shards, then train SGD on each shard in parallel, and after training mix the final parameters from each shard by averaging. The algorithm requires no communication between machines until the end. McDonald et al. (2010) also present an iterative mixing algorithm where weights are mixed from each shard after trai</context>
</contexts>
<marker>Shalev-Shwartz, Singer, Srebro, 2007</marker>
<rawString>Shai Shalev-Shwartz, Yoram Singer, and Nathan Srebro. 2007. Pegasos: Primal Estimated sub-GrAdient SOlver for SVM. In Proceedings of the 24th International Conference on Machine Learning (ICML’07), Corvallis, OR.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Libin Shen</author>
<author>Aravind K Joshi</author>
</authors>
<title>Ranking and reranking with perceptron.</title>
<date>2005</date>
<journal>Journal of Machine Learning Research,</journal>
<pages>60--1</pages>
<contexts>
<context citStr="Shen and Joshi, 2005" endWordPosition="1617" position="10287" startWordPosition="1614">g translations according to smoothed sentence-wise BLEU score (Liang et al., 2006a) against the reference. For a preference pair xj = (x(1) j , xj 2)) where x(1) j is preferred over x(2) j , and ¯xj = x(1) j − x(2) j , we consider the following hinge loss-type objective function: lj(w) = (− (w, ¯xj ))+ where (a)+ = max(0, a) , w E IRD is a weight vector, and (·, ·) denotes the standard vector dot product. Instantiating SGD to the following stochastic 2Similar “monolingual parse features” have been used in Dyer et al. (2011). subgradient leads to the perceptron algorithm for pairwise ranking3 (Shen and Joshi, 2005): � −¯xj if (w, ¯xj) G 0, �lj(w) = 0 else. Our baseline algorithm 1 (SDG) scales pairwise ranking to large scale scenarios. The algorithm takes an average over the final weight updates of each epoch instead of keeping a record of all weight updates for final averaging (Collins, 2002) or for voting (Freund and Schapire, 1999). Algorithm 1 SGD: int I, T, float 77 Initialize w0,0,0 F 0. for epochs t F 0 ... T − 1: do for all i E {0 ... I − 11: do Decode ith input with wt,i,0. for all pairs xj, j E {0 ... P// − 11: do wt,i,j+1 F wt,i,j − ηVlj(Wt,i,j) end for wt,i+1,0 F wt,i,P end for wt+1,0,0 F wt</context>
</contexts>
<marker>Shen, Joshi, 2005</marker>
<rawString>Libin Shen and Aravind K. Joshi. 2005. Ranking and reranking with perceptron. Journal of Machine Learning Research, 60(1-3):73–96.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Libin Shen</author>
<author>Anoop Sarkar</author>
<author>Franz Josef Och</author>
</authors>
<title>Discriminative reranking for machine translation.</title>
<date>2004</date>
<booktitle>In Proceedings of the Human Language Technology conference / North American chapter of the Association for Computational Linguistics annual meeting (HLT/NAACL’04),</booktitle>
<location>Boston, MA.</location>
<contexts>
<context citStr="Shen et al., 2004" endWordPosition="991" position="6506" startWordPosition="988">freely available as a part of the cdec1 framework. 1https://github.com/redpony/cdec 2 Related Work The great promise of discriminative training for SMT is the possibility to design arbitrarily expressive, complex, or overlapping features in great numbers. The focus of many approaches thus has been on feature engineering and on adaptations of machine learning algorithms to the special case of SMT (where gold standard rankings have to be created automatically). Examples for adapted algorithms include Maximum-Entropy Models (Och and Ney, 2002; Blunsom et al., 2008), Pairwise Ranking Perceptrons (Shen et al., 2004; Watanabe et al., 2006; Hopkins and May, 2011), Structured Perceptrons (Liang et al., 2006a), Boosting (Duh and Kirchhoff, 2008; Wellington et al., 2009), Structured SVMs (Tillmann and Zhang, 2006; Hayashi et al., 2009), MIRA (Watanabe et al., 2007; Chiang et al., 2008; Chiang et al., 2009), and others. Adaptations of the loss functions underlying such algorithms to SMT have recently been described as particular forms of ramp loss optimization (McAllester and Keshet, 2011; Gimpel and Smith, 2012). All approaches have been shown to scale to large feature sets and all include some kind of regul</context>
</contexts>
<marker>Shen, Sarkar, Och, 2004</marker>
<rawString>Libin Shen, Anoop Sarkar, and Franz Josef Och. 2004. Discriminative reranking for machine translation. In Proceedings of the Human Language Technology conference / North American chapter of the Association for Computational Linguistics annual meeting (HLT/NAACL’04), Boston, MA.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Andreas Stolcke</author>
</authors>
<title>SRILM - an extensible language modeling toolkit.</title>
<date>2002</date>
<booktitle>In Proceedings of the International Conference on Spoken Language Processing,</booktitle>
<location>Denver, CO.</location>
<contexts>
<context citStr="Stolcke, 2002" endWordPosition="3132" position="18638" startWordPosition="3130">ior to translation of the sentence. The computational overhead is minimal compared to the expense of decoding. Also, deploying disk space instead of memory fits perfectly into the MapReduce framework we are working in. Furthermore, the extraction of grammars for training is done in a leave-one-out fashion (Zollmann and Sima’an, 2005) where rules are extracted for a parallel sentence pair only if the same rules are found in other sentences of the corpus as well. 3-gram (news-commentary) and 5-gram (Europarl) language models are trained on the data described in Table 1, using the SRILM toolkit (Stolcke, 2002) and binarized for efficient querying using kenlm (Heafield, 2011). For the 5-gram language models, we replaced every word in the lm training data with &lt;unk&gt; that did not appear in the English part of the parallel training data to build an open vocabulary language model. Figure 3: Multipartite pairwise ranking. Training data for discriminative learning are prepared by comparing a 100-best list of translations against a single reference using smoothed persentence BLEU (Liang et al., 2006a). From the BLEU-reordered n-best list, translations were put into sets for the top 10% level (HI), the midd</context>
</contexts>
<marker>Stolcke, 2002</marker>
<rawString>Andreas Stolcke. 2002. SRILM - an extensible language modeling toolkit. In Proceedings of the International Conference on Spoken Language Processing, Denver, CO.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Christoph Tillmann</author>
<author>Tong Zhang</author>
</authors>
<title>A discriminatie global training algorithm for statistical MT.</title>
<date>2006</date>
<booktitle>In Proceedings of the joint conference of the International Committee on Computational Linguistics and the Association for Computational Linguistics (COLING-ACL’06),</booktitle>
<location>Sydney, Australia.</location>
<contexts>
<context citStr="Tillmann and Zhang, 2006" endWordPosition="1020" position="6703" startWordPosition="1017">ly expressive, complex, or overlapping features in great numbers. The focus of many approaches thus has been on feature engineering and on adaptations of machine learning algorithms to the special case of SMT (where gold standard rankings have to be created automatically). Examples for adapted algorithms include Maximum-Entropy Models (Och and Ney, 2002; Blunsom et al., 2008), Pairwise Ranking Perceptrons (Shen et al., 2004; Watanabe et al., 2006; Hopkins and May, 2011), Structured Perceptrons (Liang et al., 2006a), Boosting (Duh and Kirchhoff, 2008; Wellington et al., 2009), Structured SVMs (Tillmann and Zhang, 2006; Hayashi et al., 2009), MIRA (Watanabe et al., 2007; Chiang et al., 2008; Chiang et al., 2009), and others. Adaptations of the loss functions underlying such algorithms to SMT have recently been described as particular forms of ramp loss optimization (McAllester and Keshet, 2011; Gimpel and Smith, 2012). All approaches have been shown to scale to large feature sets and all include some kind of regularization method. However, most approaches have been confined to training on small tuning sets. Exceptions where discriminative SMT has been used on large training data are Liang et al. (2006a) who</context>
</contexts>
<marker>Tillmann, Zhang, 2006</marker>
<rawString>Christoph Tillmann and Tong Zhang. 2006. A discriminatie global training algorithm for statistical MT. In Proceedings of the joint conference of the International Committee on Computational Linguistics and the Association for Computational Linguistics (COLING-ACL’06), Sydney, Australia.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Katharina W¨aschle</author>
<author>Stefan Riezler</author>
</authors>
<title>Structural and topical dimensions in multi-task patent translation.</title>
<date>2012</date>
<booktitle>In Proceedings of the 13th Conference of the European Chapter of the Association for Computational Linguistics,</booktitle>
<location>Avignon, France.</location>
<marker>W¨aschle, Riezler, 2012</marker>
<rawString>Katharina W¨aschle and Stefan Riezler. 2012. Structural and topical dimensions in multi-task patent translation. In Proceedings of the 13th Conference of the European Chapter of the Association for Computational Linguistics, Avignon, France.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Taro Watanabe</author>
<author>Jun Suzuki</author>
<author>Hajime Tsukada</author>
<author>Hideki Isozaki</author>
</authors>
<title>NTT statistical machine translation for IWSLT</title>
<date>2006</date>
<booktitle>In Proceedings of the International Workshop on Spoken Language Translation (IWSLT),</booktitle>
<location>Kyoto, Japan.</location>
<contexts>
<context citStr="Watanabe et al., 2006" endWordPosition="995" position="6529" startWordPosition="992"> a part of the cdec1 framework. 1https://github.com/redpony/cdec 2 Related Work The great promise of discriminative training for SMT is the possibility to design arbitrarily expressive, complex, or overlapping features in great numbers. The focus of many approaches thus has been on feature engineering and on adaptations of machine learning algorithms to the special case of SMT (where gold standard rankings have to be created automatically). Examples for adapted algorithms include Maximum-Entropy Models (Och and Ney, 2002; Blunsom et al., 2008), Pairwise Ranking Perceptrons (Shen et al., 2004; Watanabe et al., 2006; Hopkins and May, 2011), Structured Perceptrons (Liang et al., 2006a), Boosting (Duh and Kirchhoff, 2008; Wellington et al., 2009), Structured SVMs (Tillmann and Zhang, 2006; Hayashi et al., 2009), MIRA (Watanabe et al., 2007; Chiang et al., 2008; Chiang et al., 2009), and others. Adaptations of the loss functions underlying such algorithms to SMT have recently been described as particular forms of ramp loss optimization (McAllester and Keshet, 2011; Gimpel and Smith, 2012). All approaches have been shown to scale to large feature sets and all include some kind of regularization method. Howev</context>
</contexts>
<marker>Watanabe, Suzuki, Tsukada, Isozaki, 2006</marker>
<rawString>Taro Watanabe, Jun Suzuki, Hajime Tsukada, and Hideki Isozaki. 2006. NTT statistical machine translation for IWSLT 2006. In Proceedings of the International Workshop on Spoken Language Translation (IWSLT), Kyoto, Japan.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Taro Watanabe</author>
<author>Jun Suzuki</author>
<author>Hajime Tsukada</author>
<author>Hideki Isozaki</author>
</authors>
<title>Online large-margin training for statistical machine translation.</title>
<date>2007</date>
<booktitle>In Proceedings of the 2007 Joint Conference on Empirical Mehtods in Natural Language Processing and Computational Language Learning (EMNLP’07),</booktitle>
<location>Prague, Czech Republic.</location>
<contexts>
<context citStr="Watanabe et al., 2007" endWordPosition="1029" position="6755" startWordPosition="1026">t numbers. The focus of many approaches thus has been on feature engineering and on adaptations of machine learning algorithms to the special case of SMT (where gold standard rankings have to be created automatically). Examples for adapted algorithms include Maximum-Entropy Models (Och and Ney, 2002; Blunsom et al., 2008), Pairwise Ranking Perceptrons (Shen et al., 2004; Watanabe et al., 2006; Hopkins and May, 2011), Structured Perceptrons (Liang et al., 2006a), Boosting (Duh and Kirchhoff, 2008; Wellington et al., 2009), Structured SVMs (Tillmann and Zhang, 2006; Hayashi et al., 2009), MIRA (Watanabe et al., 2007; Chiang et al., 2008; Chiang et al., 2009), and others. Adaptations of the loss functions underlying such algorithms to SMT have recently been described as particular forms of ramp loss optimization (McAllester and Keshet, 2011; Gimpel and Smith, 2012). All approaches have been shown to scale to large feature sets and all include some kind of regularization method. However, most approaches have been confined to training on small tuning sets. Exceptions where discriminative SMT has been used on large training data are Liang et al. (2006a) who trained 1.5 million features on 67,000 sentences, B</context>
</contexts>
<marker>Watanabe, Suzuki, Tsukada, Isozaki, 2007</marker>
<rawString>Taro Watanabe, Jun Suzuki, Hajime Tsukada, and Hideki Isozaki. 2007. Online large-margin training for statistical machine translation. In Proceedings of the 2007 Joint Conference on Empirical Mehtods in Natural Language Processing and Computational Language Learning (EMNLP’07), Prague, Czech Republic.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Benjamin Wellington</author>
<author>Joseph Turian</author>
<author>Dan Melamed</author>
</authors>
<title>Toward purely discriminative training for treestructured translation models.</title>
<date>2009</date>
<booktitle>Learning Machine Translation,</booktitle>
<pages>132--149</pages>
<editor>In Cyril Goutte, Nicola Cancedda, and Marc Dymetman, editors,</editor>
<publisher>The MIT Press.</publisher>
<location>Cambridge, MA.</location>
<contexts>
<context citStr="Wellington et al., 2009" endWordPosition="1014" position="6660" startWordPosition="1011"> SMT is the possibility to design arbitrarily expressive, complex, or overlapping features in great numbers. The focus of many approaches thus has been on feature engineering and on adaptations of machine learning algorithms to the special case of SMT (where gold standard rankings have to be created automatically). Examples for adapted algorithms include Maximum-Entropy Models (Och and Ney, 2002; Blunsom et al., 2008), Pairwise Ranking Perceptrons (Shen et al., 2004; Watanabe et al., 2006; Hopkins and May, 2011), Structured Perceptrons (Liang et al., 2006a), Boosting (Duh and Kirchhoff, 2008; Wellington et al., 2009), Structured SVMs (Tillmann and Zhang, 2006; Hayashi et al., 2009), MIRA (Watanabe et al., 2007; Chiang et al., 2008; Chiang et al., 2009), and others. Adaptations of the loss functions underlying such algorithms to SMT have recently been described as particular forms of ramp loss optimization (McAllester and Keshet, 2011; Gimpel and Smith, 2012). All approaches have been shown to scale to large feature sets and all include some kind of regularization method. However, most approaches have been confined to training on small tuning sets. Exceptions where discriminative SMT has been used on large</context>
</contexts>
<marker>Wellington, Turian, Melamed, 2009</marker>
<rawString>Benjamin Wellington, Joseph Turian, and Dan Melamed. 2009. Toward purely discriminative training for treestructured translation models. In Cyril Goutte, Nicola Cancedda, and Marc Dymetman, editors, Learning Machine Translation, pages 132–149, Cambridge, MA. The MIT Press.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Martin A Zinkevich</author>
<author>Markus Weimer</author>
<author>Alex Smola</author>
<author>Lihong Li</author>
</authors>
<title>Parallelized stochastic gradient descent.</title>
<date>2010</date>
<booktitle>In Proceedings of the 24th Annual Conference on Neural Information Processing Sytems (NIPS’10),</booktitle>
<location>Vancouver, Canada.</location>
<contexts>
<context citStr="Zinkevich et al. (2010)" endWordPosition="1933" position="11954" startWordPosition="1930">1 ... Z1: parallel do Initialize wz,0,0,0 F 0. for epochs t F 0 ... T − 1: do for all i E {0 ... S − 11: do Decode ith input with wz,t,i,0. for all pairs xj, j E {0 ... P −//11: do wz,t,i,j+1 F wz,t,i,j − ηvljlWz,t,i,j) end for wz,t,i+1,0 F wz,t,i,P end for wz,t+1,0,0 F wz,t,S,0 end for end for Collect final weights from each machine, E 1 1T E wz,t,0,0J . z=1 t=1 3Other loss functions lead to stochastic versions of SVMs (Collobert and Bengio, 2004; Shalev-Shwartz et al., 2007; Chapelle and Keerthi, 2010). T E t=1 wt,0,0 return 1Z 13 Algorithm 2 is a variant of the SimuParallelSGD algorithm of Zinkevich et al. (2010) or equivalently of the parameter mixing algorithm of McDonald et al. (2010). The key idea of algorithm 2 is to partition the data into disjoint shards, then train SGD on each shard in parallel, and after training mix the final parameters from each shard by averaging. The algorithm requires no communication between machines until the end. McDonald et al. (2010) also present an iterative mixing algorithm where weights are mixed from each shard after training a single epoch of the perceptron in parallel on each shard. The mixed weight vector is re-sent to each shard to start another epoch of tra</context>
</contexts>
<marker>Zinkevich, Weimer, Smola, Li, 2010</marker>
<rawString>Martin A. Zinkevich, Markus Weimer, Alex Smola, and Lihong Li. 2010. Parallelized stochastic gradient descent. In Proceedings of the 24th Annual Conference on Neural Information Processing Sytems (NIPS’10), Vancouver, Canada.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Andreas Zollmann</author>
<author>Khalil Sima’an</author>
</authors>
<title>A consistent and efficient estimator for data-oriented parsing.</title>
<date>2005</date>
<journal>Journal of Automata, Languages and Combinatorics,</journal>
<pages>10--2</pages>
<marker>Zollmann, Sima’an, 2005</marker>
<rawString>Andreas Zollmann and Khalil Sima’an. 2005. A consistent and efficient estimator for data-oriented parsing. Journal of Automata, Languages and Combinatorics, 10(2/3):367–388.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>